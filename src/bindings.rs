/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const __BT_FUNC_STATUS_OVERFLOW_ERROR: i32 = -75;
pub const __BT_FUNC_STATUS_MEMORY_ERROR: i32 = -12;
pub const __BT_FUNC_STATUS_USER_ERROR: i32 = -2;
pub const __BT_FUNC_STATUS_ERROR: i32 = -1;
pub const __BT_FUNC_STATUS_OK: u32 = 0;
pub const __BT_FUNC_STATUS_END: u32 = 1;
pub const __BT_FUNC_STATUS_NOT_FOUND: u32 = 2;
pub const __BT_FUNC_STATUS_INTERRUPTED: u32 = 4;
pub const __BT_FUNC_STATUS_NO_MATCH: u32 = 6;
pub const __BT_FUNC_STATUS_AGAIN: u32 = 11;
pub const __BT_FUNC_STATUS_UNKNOWN_OBJECT: u32 = 42;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const BT_TRUE: u32 = 1;
pub const BT_FALSE: u32 = 0;
pub const __BT_LOGGING_LEVEL_TRACE: u32 = 1;
pub const __BT_LOGGING_LEVEL_DEBUG: u32 = 2;
pub const __BT_LOGGING_LEVEL_INFO: u32 = 3;
pub const __BT_LOGGING_LEVEL_WARNING: u32 = 4;
pub const __BT_LOGGING_LEVEL_ERROR: u32 = 5;
pub const __BT_LOGGING_LEVEL_FATAL: u32 = 6;
pub const __BT_LOGGING_LEVEL_NONE: u32 = 255;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_clock_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_clock_snapshot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_class_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_class_sink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_class_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_descriptor_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_sink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_component_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_error {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_error_cause {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_event_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_event_header_field {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_enumeration_mapping {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_enumeration_signed_mapping {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_enumeration_unsigned_mapping {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_structure_member {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_variant_option {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_variant_with_selector_field_integer_signed_option {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_class_variant_with_selector_field_integer_unsigned_option {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_field_path_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_graph {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_integer_range_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_integer_range_set_signed {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_integer_range_set_unsigned {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_integer_range_signed {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_integer_range_unsigned {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_interrupter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_message {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_message_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_message_iterator_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_packet {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct bt_plugin {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct bt_plugin_set {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct bt_plugin_so_shared_lib_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_port_input {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_port_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_port_output_message_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_private_query_executor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_query_executor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_class_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_class_sink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_class_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_filter_configuration {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_port_input {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_port_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_sink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_sink_configuration {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_component_source_configuration {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_message_iterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_message_iterator_configuration {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_self_plugin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_stream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_stream_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_trace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_trace_class {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bt_value {
    _unused: [u8; 0],
}
#[doc = "@brief"]
#[doc = "\\bt_name boolean type."]
#[doc = ""]
#[doc = "The API uses #bt_bool instead of the C99 \\c bool type for"]
#[doc = "<a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\">application binary interface</a>"]
#[doc = "reasons."]
#[doc = ""]
#[doc = "Use #BT_TRUE and #BT_FALSE to set and compare #bt_bool variables."]
pub type bt_bool = ::std::os::raw::c_int;
#[doc = "@brief"]
#[doc = "Numeric ID which identifies a user listener function."]
#[doc = ""]
#[doc = "Some functions, such as bt_trace_add_destruction_listener(), return a"]
#[doc = "listener ID when you add a user listener function to some object. You"]
#[doc = "can then use this listener ID to remove the listener from the object."]
pub type bt_listener_id = u64;
#[doc = "@brief"]
#[doc = "A"]
#[doc = "<a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier\">UUID</a>,"]
#[doc = "that is, an array of 16&nbsp;constant bytes."]
pub type bt_uuid = *const u8;
pub mod bt_property_availability {
    #[doc = "@brief"]
    #[doc = "Availability of an object's property."]
    #[doc = ""]
    #[doc = "Some getter functions of the API, such as"]
    #[doc = "bt_event_class_get_log_level(), return, by output parameter, an optional"]
    #[doc = "object property which is not a pointer. In that case, the function"]
    #[doc = "either:"]
    #[doc = ""]
    #[doc = "- Returns #BT_PROPERTY_AVAILABILITY_AVAILABLE and sets an output"]
    #[doc = "parameter to the property's value."]
    #[doc = "- Returns #BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Property is available."]
    pub const BT_PROPERTY_AVAILABILITY_AVAILABLE: Type = 1;
    #[doc = "@brief"]
    #[doc = "Property is not available."]
    pub const BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE: Type = 0;
}
#[doc = "@brief"]
#[doc = "Array of constant \\bt_p_msg."]
#[doc = ""]
#[doc = "Such an array is filled by the"]
#[doc = "\\link api-msg-iter-cls-meth-next \"next\" method\\endlink of a"]
#[doc = "\\bt_msg_iter and consumed with bt_message_iterator_next() by another"]
#[doc = "message iterator or by a \\bt_sink_comp."]
pub type bt_message_array_const = *mut *const bt_message;
pub mod bt_component_class_type {
    #[doc = "@brief"]
    #[doc = "Component class type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "\\bt_c_src_comp_cls."]
    pub const BT_COMPONENT_CLASS_TYPE_SOURCE: Type = 1;
    #[doc = "@brief"]
    #[doc = "\\bt_c_flt_comp_cls."]
    pub const BT_COMPONENT_CLASS_TYPE_FILTER: Type = 2;
    #[doc = "@brief"]
    #[doc = "\\bt_c_sink_comp_cls."]
    pub const BT_COMPONENT_CLASS_TYPE_SINK: Type = 4;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the component class"]
    #[doc = "\\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to get the type enumerator."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_is_source() &mdash;"]
    #[doc = "Returns whether or not a component class is a \\bt_src_comp_cls."]
    #[doc = "@sa bt_component_class_is_filter() &mdash;"]
    #[doc = "Returns whether or not a component class is a \\bt_flt_comp_cls."]
    #[doc = "@sa bt_component_class_is_sink() &mdash;"]
    #[doc = "Returns whether or not a component class is a \\bt_sink_comp_cls."]
    pub fn bt_component_class_get_type(
        component_class: *const bt_component_class,
    ) -> bt_component_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the component class \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    pub fn bt_component_class_get_name(
        component_class: *const bt_component_class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the description of the component class"]
    #[doc = "\\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-prop-descr \"description\" property."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to get the description."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Description of \\bt_p{component_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    pub fn bt_component_class_get_description(
        component_class: *const bt_component_class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the help text of the component class \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-prop-help \"help text\" property."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to get the help text."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Help text of \\bt_p{component_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    pub fn bt_component_class_get_help(
        component_class: *const bt_component_class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component class \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Component class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a component class."]
    pub fn bt_component_class_get_ref(component_class: *const bt_component_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component class \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Component class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a component class."]
    pub fn bt_component_class_put_ref(component_class: *const bt_component_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_src_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Source component class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_source_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a source component class."]
    pub fn bt_component_class_source_get_ref(component_class: *const bt_component_class_source);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_src_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Source component class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_source_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a source component class."]
    pub fn bt_component_class_source_put_ref(component_class: *const bt_component_class_source);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_flt_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Filter component class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_filter_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a filter component class."]
    pub fn bt_component_class_filter_get_ref(component_class: *const bt_component_class_filter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_flt_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Filter component class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_filter_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a filter component class."]
    pub fn bt_component_class_filter_put_ref(component_class: *const bt_component_class_filter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_sink_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Sink component class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_sink_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a sink component class."]
    pub fn bt_component_class_sink_get_ref(component_class: *const bt_component_class_sink);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_sink_comp_cls \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "@parblock"]
    #[doc = "Sink component class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_sink_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a sink component class."]
    pub fn bt_component_class_sink_put_ref(component_class: *const bt_component_class_sink);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "\\em Takes the current thread's error, that is, moves its ownership"]
    #[doc = "from the library to the caller."]
    #[doc = ""]
    #[doc = "This function can return \\c NULL if the current thread has no error."]
    #[doc = ""]
    #[doc = "Once you are done with the returned error, do one of:"]
    #[doc = ""]
    #[doc = "- Call bt_error_release() to free the error object."]
    #[doc = ""]
    #[doc = "In <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">object-oriented programming</a>"]
    #[doc = "terms, this corresponds to catching an exception and discarding it."]
    #[doc = ""]
    #[doc = "- Call bt_current_thread_move_error() to move back the error object's"]
    #[doc = "ownership to the library."]
    #[doc = ""]
    #[doc = "In object-oriented programming terms, this corresponds to catching"]
    #[doc = "an exception and rethrowing it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Unique reference of the current thread's error, or \\c NULL if the"]
    #[doc = "current thread has no error."]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>If this function does not return <code>NULL</code></strong>,"]
    #[doc = "the caller owns the returned error."]
    #[doc = ""]
    #[doc = "@sa bt_error_release() &mdash;"]
    #[doc = "Releases (frees) an error."]
    #[doc = "@sa bt_current_thread_move_error() &mdash;"]
    #[doc = "Moves an error's ownership to the library."]
    pub fn bt_current_thread_take_error() -> *const bt_error;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Moves the ownership of the error \\bt_p{error} from the caller to"]
    #[doc = "the library."]
    #[doc = ""]
    #[doc = "After you call this function, you don't own \\bt_p{error} anymore."]
    #[doc = ""]
    #[doc = "In <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">object-oriented programming</a>"]
    #[doc = "terms, calling this function corresponds to catching an"]
    #[doc = "exception and rethrowing it."]
    #[doc = ""]
    #[doc = "You can instead release (free) the error with bt_error_release(), which,"]
    #[doc = "in object-oriented programming terms,"]
    #[doc = "corresponds to catching an exception and discarding it."]
    #[doc = ""]
    #[doc = "@param[in] error"]
    #[doc = "Error of which to move the ownership from you to the library."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error}"]
    #[doc = "@pre"]
    #[doc = "The caller owns \\bt_p{error}."]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "The library owns \\bt_p{error}."]
    #[doc = ""]
    #[doc = "@sa bt_error_release() &mdash;"]
    #[doc = "Releases (frees) an error."]
    #[doc = "@sa BT_CURRENT_THREAD_MOVE_ERROR_AND_RESET() &mdash;"]
    #[doc = "Calls this function and assigns \\c NULL to the expression."]
    pub fn bt_current_thread_move_error(error: *const bt_error);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Releases the current thread's error, if any."]
    #[doc = ""]
    #[doc = "This function is equivalent to:"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_error_release(bt_current_thread_take_error());"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "The current thread has no error."]
    #[doc = ""]
    #[doc = "@sa bt_error_release() &mdash;"]
    #[doc = "Releases (frees) an error."]
    #[doc = "@sa bt_current_thread_take_error &mdash;"]
    #[doc = "Takes the current thread's error, moving its ownership from the"]
    #[doc = "library to the caller."]
    pub fn bt_current_thread_clear_error();
}
pub mod bt_current_thread_error_append_cause_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the"]
    #[doc = "<code>bt_current_thread_error_append_cause_from_*()</code>"]
    #[doc = "functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an error cause to the current thread's error from a"]
    #[doc = "\\bt_comp method."]
    #[doc = ""]
    #[doc = "This this a <code>printf()</code>-like function starting from the"]
    #[doc = "format string parameter \\bt_p{message_format}."]
    #[doc = ""]
    #[doc = "On success, the appended error cause's module name"]
    #[doc = "(see bt_error_cause_get_module_name()) is:"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "NAME: CC-TYPE.PLUGIN-NAME.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "or"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "NAME: CC-TYPE.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "if no \\bt_plugin provides the class of \\bt_p{self_component}, with:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>\\c NAME</dt>"]
    #[doc = "<dd>Name of \\bt_p{self_component}.</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c CC-TYPE</dt>"]
    #[doc = "<dd>"]
    #[doc = "Type of the \\ref api-comp-cls \"class\" of \\bt_p{self_component}"]
    #[doc = "(\\c src, \\c flt, or \\c sink)."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c PLUGIN-NAME</dt>"]
    #[doc = "<dd>"]
    #[doc = "Name of the plugin which provides the class of"]
    #[doc = "\\bt_p{self_component}."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c CC-NAME</dt>"]
    #[doc = "<dd>Name of the class of \\bt_p{self_component}.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Self component of the appending method."]
    #[doc = "@param[in] file_name"]
    #[doc = "Name of the source file containing the method which appends the"]
    #[doc = "error cause."]
    #[doc = "@param[in] line_number"]
    #[doc = "Line number of the statement which appends the error cause."]
    #[doc = "@param[in] message_format"]
    #[doc = "Format string which specifies how the function converts the"]
    #[doc = "subsequent arguments (like <code>printf()</code>)."]
    #[doc = ""]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{file_name}"]
    #[doc = "@bt_pre_not_null{message_format}"]
    #[doc = "@bt_pre_valid_fmt{message_format}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the number of error causes in the"]
    #[doc = "current thread's error is incremented."]
    #[doc = ""]
    #[doc = "@sa BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_FROM_COMPONENT() &mdash;"]
    #[doc = "Calls this function with \\c __FILE__ and \\c __LINE__ as the"]
    #[doc = "\\bt_p{file_name} and \\bt_p{line_number} parameters."]
    pub fn bt_current_thread_error_append_cause_from_component(
        self_component: *mut bt_self_component,
        file_name: *const ::std::os::raw::c_char,
        line_number: u64,
        message_format: *const ::std::os::raw::c_char,
        ...
    ) -> bt_current_thread_error_append_cause_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an error cause to the current thread's error from a"]
    #[doc = "\\bt_msg_iter method."]
    #[doc = ""]
    #[doc = "This this a <code>printf()</code>-like function starting from the"]
    #[doc = "format string parameter \\bt_p{message_format}."]
    #[doc = ""]
    #[doc = "On success, the appended error cause's module name"]
    #[doc = "(see bt_error_cause_get_module_name()) is:"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "COMP-NAME (OUT-PORT-NAME): CC-TYPE.PLUGIN-NAME.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "or"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "COMP-NAME (OUT-PORT-NAME): CC-TYPE.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "if no \\bt_plugin provides the component class of"]
    #[doc = "\\bt_p{self_message_iterator}, with:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>\\c COMP-NAME</dt>"]
    #[doc = "<dd>Name of the \\bt_comp of \\bt_p{self_message_iterator}.</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c OUT-PORT-NAME</dt>"]
    #[doc = "<dd>"]
    #[doc = "Name of the \\bt_oport from which \\bt_p{self_message_iterator}."]
    #[doc = "was created."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c CC-TYPE</dt>"]
    #[doc = "<dd>"]
    #[doc = "Type of the \\bt_comp_cls of \\bt_p{self_message_iterator}"]
    #[doc = "(\\c src, \\c flt, or \\c sink)."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c PLUGIN-NAME</dt>"]
    #[doc = "<dd>"]
    #[doc = "Name of the plugin which provides the component class of"]
    #[doc = "\\bt_p{self_message_iterator}."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c CC-NAME</dt>"]
    #[doc = "<dd>Name of the component class of \\bt_p{self_message_iterator}.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator of the appending method."]
    #[doc = "@param[in] file_name"]
    #[doc = "Name of the source file containing the method which appends the"]
    #[doc = "error cause."]
    #[doc = "@param[in] line_number"]
    #[doc = "Line number of the statement which appends the error cause."]
    #[doc = "@param[in] message_format"]
    #[doc = "Format string which specifies how the function converts the"]
    #[doc = "subsequent arguments (like <code>printf()</code>)."]
    #[doc = ""]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{file_name}"]
    #[doc = "@bt_pre_not_null{message_format}"]
    #[doc = "@bt_pre_valid_fmt{message_format}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the number of error causes in the"]
    #[doc = "current thread's error is incremented."]
    #[doc = ""]
    #[doc = "@sa BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_FROM_MESSAGE_ITERATOR() &mdash;"]
    #[doc = "Calls this function with \\c __FILE__ and \\c __LINE__ as the"]
    #[doc = "\\bt_p{file_name} and \\bt_p{line_number} parameters."]
    pub fn bt_current_thread_error_append_cause_from_message_iterator(
        self_message_iterator: *mut bt_self_message_iterator,
        file_name: *const ::std::os::raw::c_char,
        line_number: u64,
        message_format: *const ::std::os::raw::c_char,
        ...
    ) -> bt_current_thread_error_append_cause_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an error cause to the current thread's error from a"]
    #[doc = "\\bt_comp_cls method."]
    #[doc = ""]
    #[doc = "This this a <code>printf()</code>-like function starting from the"]
    #[doc = "format string parameter \\bt_p{message_format}."]
    #[doc = ""]
    #[doc = "As of \\bt_name_version_min_maj, the only component class method is the"]
    #[doc = "\\ref api-qexec \"query\" method."]
    #[doc = ""]
    #[doc = "On success, the appended error cause's module name"]
    #[doc = "(see bt_error_cause_get_module_name()) is:"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "CC-TYPE.PLUGIN-NAME.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "or"]
    #[doc = ""]
    #[doc = "@code{.unparsed}"]
    #[doc = "CC-TYPE.CC-NAME"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "if no \\bt_plugin provides \\bt_p{self_component_class}, with:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>\\c CC-TYPE</dt>"]
    #[doc = "<dd>"]
    #[doc = "Type of \\bt_p{self_component_class} (\\c src, \\c flt, or \\c sink)."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c PLUGIN-NAME</dt>"]
    #[doc = "<dd>"]
    #[doc = "Name of the plugin which provides \\bt_p{self_component_class}."]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>\\c CC-NAME</dt>"]
    #[doc = "<dd>Name of \\bt_p{self_component_class}.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "@param[in] self_component_class"]
    #[doc = "Self component class of the appending method."]
    #[doc = "@param[in] file_name"]
    #[doc = "Name of the source file containing the method which appends the"]
    #[doc = "error cause."]
    #[doc = "@param[in] line_number"]
    #[doc = "Line number of the statement which appends the error cause."]
    #[doc = "@param[in] message_format"]
    #[doc = "Format string which specifies how the function converts the"]
    #[doc = "subsequent arguments (like <code>printf()</code>)."]
    #[doc = ""]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component_class}"]
    #[doc = "@bt_pre_not_null{file_name}"]
    #[doc = "@bt_pre_not_null{message_format}"]
    #[doc = "@bt_pre_valid_fmt{message_format}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the number of error causes in the"]
    #[doc = "current thread's error is incremented."]
    #[doc = ""]
    #[doc = "@sa BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_FROM_COMPONENT_CLASS() &mdash;"]
    #[doc = "Calls this function with \\c __FILE__ and \\c __LINE__ as the"]
    #[doc = "\\bt_p{file_name} and \\bt_p{line_number} parameters."]
    pub fn bt_current_thread_error_append_cause_from_component_class(
        self_component_class: *mut bt_self_component_class,
        file_name: *const ::std::os::raw::c_char,
        line_number: u64,
        message_format: *const ::std::os::raw::c_char,
        ...
    ) -> bt_current_thread_error_append_cause_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an error cause to the current thread's error from any"]
    #[doc = "function."]
    #[doc = ""]
    #[doc = "Use this function when you cannot use"]
    #[doc = "bt_current_thread_error_append_cause_from_component(),"]
    #[doc = "bt_current_thread_error_append_cause_from_message_iterator(),"]
    #[doc = "or bt_current_thread_error_append_cause_from_component_class()."]
    #[doc = ""]
    #[doc = "This this a <code>printf()</code>-like function starting from the"]
    #[doc = "format string parameter \\bt_p{message_format}."]
    #[doc = ""]
    #[doc = "@param[in] module_name"]
    #[doc = "Module name of the error cause to append."]
    #[doc = "@param[in] file_name"]
    #[doc = "Name of the source file containing the method which appends the"]
    #[doc = "error cause."]
    #[doc = "@param[in] line_number"]
    #[doc = "Line number of the statement which appends the error cause."]
    #[doc = "@param[in] message_format"]
    #[doc = "Format string which specifies how the function converts the"]
    #[doc = "subsequent arguments (like <code>printf()</code>)."]
    #[doc = ""]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{module_name}"]
    #[doc = "@bt_pre_not_null{file_name}"]
    #[doc = "@bt_pre_not_null{message_format}"]
    #[doc = "@bt_pre_valid_fmt{message_format}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the number of error causes in the"]
    #[doc = "current thread's error is incremented."]
    #[doc = ""]
    #[doc = "@sa BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_FROM_UNKNOWN() &mdash;"]
    #[doc = "Calls this function with \\c __FILE__ and \\c __LINE__ as the"]
    #[doc = "\\bt_p{file_name} and \\bt_p{line_number} parameters."]
    pub fn bt_current_thread_error_append_cause_from_unknown(
        module_name: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line_number: u64,
        message_format: *const ::std::os::raw::c_char,
        ...
    ) -> bt_current_thread_error_append_cause_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of error causes contained in the error"]
    #[doc = "\\bt_p{error}."]
    #[doc = ""]
    #[doc = "@param[in] error"]
    #[doc = "Error of which to get the number of contained error causes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained error causes in \\bt_p{error}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error}"]
    pub fn bt_error_get_cause_count(error: *const bt_error) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the error cause at index \\bt_p{index} from the"]
    #[doc = "error \\bt_p{error}."]
    #[doc = ""]
    #[doc = "@param[in] error"]
    #[doc = "Error from which to borrow the error cause at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the error cause to borrow from \\bt_p{error}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the error cause of"]
    #[doc = "\\bt_p{error} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{error} is modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of error causes in"]
    #[doc = "\\bt_p{error} (as returned by bt_error_get_cause_count())."]
    pub fn bt_error_borrow_cause_by_index(
        error: *const bt_error,
        index: u64,
    ) -> *const bt_error_cause;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Releases (frees) the error \\bt_p{error}."]
    #[doc = ""]
    #[doc = "After you call this function, \\bt_p{error} does not exist."]
    #[doc = ""]
    #[doc = "Take the current thread's error with bt_current_thread_take_error()."]
    #[doc = ""]
    #[doc = "In <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">object-oriented programming</a>"]
    #[doc = "terms, calling this function corresponds to catching an"]
    #[doc = "exception and discarding it."]
    #[doc = ""]
    #[doc = "You can instead move the ownership of \\bt_p{error} to the library with"]
    #[doc = "bt_current_thread_move_error(), which,"]
    #[doc = "in object-oriented programming terms,"]
    #[doc = "corresponds to catching an exception and rethrowing it."]
    #[doc = ""]
    #[doc = "@param[in] error"]
    #[doc = "Error to release (free)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "\\bt_p{error} does not exist."]
    #[doc = ""]
    #[doc = "@sa bt_current_thread_move_error() &mdash;"]
    #[doc = "Moves an error's ownership to the library."]
    pub fn bt_error_release(error: *const bt_error);
}
pub mod bt_error_cause_actor_type {
    #[doc = "@brief"]
    #[doc = "Error cause actor type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Any function."]
    pub const BT_ERROR_CAUSE_ACTOR_TYPE_UNKNOWN: Type = 1;
    #[doc = "@brief"]
    #[doc = "Component method."]
    pub const BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT: Type = 2;
    #[doc = "@brief"]
    #[doc = "Component class method."]
    pub const BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT_CLASS: Type = 4;
    #[doc = "@brief"]
    #[doc = "Message iterator method."]
    pub const BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR: Type = 8;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the actor type enumerator of the error cause"]
    #[doc = "\\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the actor type enumerator."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Actor type enumerator of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    pub fn bt_error_cause_get_actor_type(
        error_cause: *const bt_error_cause,
    ) -> bt_error_cause_actor_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the message of the error cause \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the message."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Message of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    pub fn bt_error_cause_get_message(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the module name of the error cause \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the module name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Module name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    pub fn bt_error_cause_get_module_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the source file which contains the function"]
    #[doc = "which appended the error cause \\bt_p{error_cause} to the"]
    #[doc = "current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the source file name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Source file name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    pub fn bt_error_cause_get_file_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the line number of the statement"]
    #[doc = "which appended the error cause \\bt_p{error_cause} to the"]
    #[doc = "current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the source statement's line number."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Source statement's line number of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    pub fn bt_error_cause_get_line_number(error_cause: *const bt_error_cause) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_comp of which a method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the current"]
    #[doc = "thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Component name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT."]
    pub fn bt_error_cause_component_actor_get_component_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the \\ref api-comp-cls \"class\" type of the"]
    #[doc = "\\bt_comp of which a method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class type."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component class type of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT."]
    pub fn bt_error_cause_component_actor_get_component_class_type(
        error_cause: *const bt_error_cause,
    ) -> bt_component_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the \\ref api-comp-cls \"class\" name of the"]
    #[doc = "\\bt_comp of which a method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Component class name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT."]
    pub fn bt_error_cause_component_actor_get_component_class_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_plugin which provides the"]
    #[doc = "\\ref api-comp-cls \"class\" of the \\bt_comp of which a method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the"]
    #[doc = "current thread's error."]
    #[doc = ""]
    #[doc = "This function returns \\c NULL if no plugin provides the error cause's"]
    #[doc = "component class."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the plugin name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Plugin name of \\bt_p{error_cause}, or \\c NULL if no plugin"]
    #[doc = "provides the component class of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT."]
    pub fn bt_error_cause_component_actor_get_plugin_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_oport from which was created"]
    #[doc = "the message iterator of which the method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the current"]
    #[doc = "thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the output port name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Output port name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR."]
    pub fn bt_error_cause_message_iterator_actor_get_component_output_port_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_comp of which a message iterator method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the current"]
    #[doc = "thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Component name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR."]
    pub fn bt_error_cause_message_iterator_actor_get_component_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the \\ref api-comp-cls \"class\" type of the"]
    #[doc = "\\bt_comp of which a message iterator method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class type."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component class type of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR."]
    pub fn bt_error_cause_message_iterator_actor_get_component_class_type(
        error_cause: *const bt_error_cause,
    ) -> bt_component_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the \\ref api-comp-cls \"class\" name of the"]
    #[doc = "\\bt_comp of which a message iterator method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Component class name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR."]
    pub fn bt_error_cause_message_iterator_actor_get_component_class_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_plugin which provides the"]
    #[doc = "\\ref api-comp-cls \"class\" of the \\bt_comp of which a"]
    #[doc = "message iterator method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the"]
    #[doc = "current thread's error."]
    #[doc = ""]
    #[doc = "This function returns \\c NULL if no plugin provides the error cause's"]
    #[doc = "component class."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the plugin name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Plugin name of \\bt_p{error_cause}, or \\c NULL if no plugin"]
    #[doc = "provides the component class of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR."]
    pub fn bt_error_cause_message_iterator_actor_get_plugin_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_comp_cls"]
    #[doc = "of which a method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component class name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT_CLASS."]
    pub fn bt_error_cause_component_class_actor_get_component_class_type(
        error_cause: *const bt_error_cause,
    ) -> bt_component_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_comp_cls"]
    #[doc = "of which a method appended the error cause"]
    #[doc = "\\bt_p{error_cause} to the current thread's error."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the component class name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Component class name of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT_CLASS."]
    pub fn bt_error_cause_component_class_actor_get_component_class_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_plugin which provides the"]
    #[doc = "\\bt_comp_cls of which a method"]
    #[doc = "appended the error cause \\bt_p{error_cause} to the"]
    #[doc = "current thread's error."]
    #[doc = ""]
    #[doc = "This function returns \\c NULL if no plugin provides the error cause's"]
    #[doc = "component class."]
    #[doc = ""]
    #[doc = "@param[in] error_cause"]
    #[doc = "Error cause of which to get the plugin name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Plugin name of \\bt_p{error_cause}, or \\c NULL if no plugin"]
    #[doc = "provides the component class of \\bt_p{error_cause}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as the error which"]
    #[doc = "contains \\bt_p{error_cause} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{error_cause}"]
    #[doc = "@pre"]
    #[doc = "The actor type of \\bt_p{error_cause} is"]
    #[doc = "#BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT_CLASS."]
    pub fn bt_error_cause_component_class_actor_get_plugin_name(
        error_cause: *const bt_error_cause,
    ) -> *const ::std::os::raw::c_char;
}
pub mod bt_logging_level {
    #[doc = "@brief"]
    #[doc = "Logging level enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "\\em TRACE level."]
    #[doc = ""]
    #[doc = "Low-level debugging context information."]
    #[doc = ""]
    #[doc = "The \\em TRACE logging statements can significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_TRACE: Type = 1;
    #[doc = "@brief"]
    #[doc = "\\em DEBUG level."]
    #[doc = ""]
    #[doc = "Debugging information, with a higher level of details than the"]
    #[doc = "\\em TRACE level."]
    #[doc = ""]
    #[doc = "The \\em DEBUG logging statements do not significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_DEBUG: Type = 2;
    #[doc = "@brief"]
    #[doc = "\\em INFO level."]
    #[doc = ""]
    #[doc = "Informational messages that highlight progress or important"]
    #[doc = "states of the application, plugins, or library."]
    #[doc = ""]
    #[doc = "The \\em INFO logging statements do not significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_INFO: Type = 3;
    #[doc = "@brief"]
    #[doc = "\\em WARNING level."]
    #[doc = ""]
    #[doc = "Unexpected situations which still allow the execution to"]
    #[doc = "continue."]
    #[doc = ""]
    #[doc = "The \\em WARNING logging statements do not significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_WARNING: Type = 4;
    #[doc = "@brief"]
    #[doc = "\\em ERROR level."]
    #[doc = ""]
    #[doc = "Errors that might still allow the execution to continue."]
    #[doc = ""]
    #[doc = "Usually, once one or more errors are reported at this level, the"]
    #[doc = "application, plugin, or library won't perform any more useful"]
    #[doc = "task, but it should still exit cleanly."]
    #[doc = ""]
    #[doc = "The \\em ERROR logging statements do not significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_ERROR: Type = 5;
    #[doc = "@brief"]
    #[doc = "\\em FATAL level."]
    #[doc = ""]
    #[doc = "Severe errors that lead the execution to abort immediately."]
    #[doc = ""]
    #[doc = "The \\em FATAL logging statements do not significantly"]
    #[doc = "impact performance."]
    pub const BT_LOGGING_LEVEL_FATAL: Type = 6;
    #[doc = "@brief"]
    #[doc = "Logging is disabled."]
    pub const BT_LOGGING_LEVEL_NONE: Type = 255;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the logging level of all the libbabeltrace2 modules to"]
    #[doc = "\\bt_p{logging_level}."]
    #[doc = ""]
    #[doc = "The library's global logging level"]
    #[doc = "\\ref api-logging-extra-lib \"does not affect\" the logging level of"]
    #[doc = "individual components and query operations."]
    #[doc = ""]
    #[doc = "@param[in] logging_level"]
    #[doc = "New library's global logging level."]
    #[doc = ""]
    #[doc = "@sa bt_logging_get_global_level() &mdash;"]
    #[doc = "Returns the current library's global logging level."]
    pub fn bt_logging_set_global_level(logging_level: bt_logging_level::Type);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the current logging level of all the libbabeltrace2 modules."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Library's current global logging level."]
    #[doc = ""]
    #[doc = "@sa bt_logging_set_global_level() &mdash;"]
    #[doc = "Sets the current library's global logging level."]
    pub fn bt_logging_get_global_level() -> bt_logging_level::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the library's minimal (build-time) logging level."]
    #[doc = ""]
    #[doc = "The library logging statements with a level that's less severe than the"]
    #[doc = "minimal logging level are \\em not built."]
    #[doc = ""]
    #[doc = "For example, if the minimal logging level is #BT_LOGGING_LEVEL_INFO, the"]
    #[doc = "#BT_LOGGING_LEVEL_TRACE and #BT_LOGGING_LEVEL_DEBUG logging statements"]
    #[doc = "are not built."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Library's minimal logging level."]
    #[doc = ""]
    #[doc = "@sa bt_logging_get_global_level() &mdash;"]
    #[doc = "Returns the current library's global logging level."]
    pub fn bt_logging_get_minimal_level() -> bt_logging_level::Type;
}
pub mod bt_component_class_sink_consume_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_component_class_sink_consume_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Sink component is finished processing."]
    pub const BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_END: Type = 1;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp consuming method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-consume \"consume\" method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "\\bt_c_sink_comp instance."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_END"]
#[doc = "Finished processing."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_create() &mdash;"]
#[doc = "Creates a \\bt_sink_comp."]
pub type bt_component_class_sink_consume_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_sink,
    ) -> bt_component_class_sink_consume_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_src_comp finalization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Source component instance."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = ""]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_component_class_source_set_finalize_method() &mdash;"]
#[doc = "Sets the finalization method of a source component class."]
pub type bt_component_class_source_finalize_method =
    ::std::option::Option<unsafe extern "C" fn(self_component: *mut bt_self_component_source)>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp finalization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Filter component instance."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = ""]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_finalize_method() &mdash;"]
#[doc = "Sets the finalization method of a filter component class."]
pub type bt_component_class_filter_finalize_method =
    ::std::option::Option<unsafe extern "C" fn(self_component: *mut bt_self_component_filter)>;
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp finalization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Sink component instance."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = ""]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_finalize_method() &mdash;"]
#[doc = "Sets the finalization method of a sink component class."]
pub type bt_component_class_sink_finalize_method =
    ::std::option::Option<unsafe extern "C" fn(self_component: *mut bt_self_component_sink)>;
pub mod bt_component_class_get_supported_mip_versions_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "#bt_component_class_source_get_supported_mip_versions_method,"]
    #[doc = "#bt_component_class_filter_get_supported_mip_versions_method, and"]
    #[doc = "#bt_component_class_sink_get_supported_mip_versions_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_src_comp_cls \\\"get supported \\bt_mip versions\\\" method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
#[doc = "method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, you can only add the range [0,&nbsp;0]"]
#[doc = "to \\bt_p{supported_versions}."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Source component class."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_component_descriptor_set_add_descriptor() or"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{init_method_data} parameter of"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = "@param[in] logging_level"]
#[doc = "Logging level to use during this method's execution, as passed"]
#[doc = "as the \\bt_p{logging_level} parameter of"]
#[doc = "bt_get_greatest_operative_mip_version()."]
#[doc = "@param[in] supported_versions"]
#[doc = "\\bt_c_uint_rs to which to add the ranges of supported MIP versions"]
#[doc = "of an eventual instance of \\bt_p{self_component_class} considering"]
#[doc = "\\bt_p{params} and \\bt_p{initialize_method_data}."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = "@bt_pre_not_null{supported_versions}"]
#[doc = "@pre"]
#[doc = "\\bt_p{supported_versions} is empty."]
#[doc = ""]
#[doc = "@sa bt_component_class_source_set_get_supported_mip_versions_method() &mdash;"]
#[doc = "Sets the \"get supported MIP versions\" method of a source"]
#[doc = "component class."]
pub type bt_component_class_source_get_supported_mip_versions_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component_class: *mut bt_self_component_class_source,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        supported_versions: *mut bt_integer_range_set_unsigned,
    ) -> bt_component_class_get_supported_mip_versions_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp_cls \\\"get supported \\bt_mip versions\\\" method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
#[doc = "method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, you can only add the range [0,&nbsp;0]"]
#[doc = "to \\bt_p{supported_versions}."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Filter component class."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_component_descriptor_set_add_descriptor() or"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{init_method_data} parameter of"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = "@param[in] logging_level"]
#[doc = "Logging level to use during this method's execution, as passed"]
#[doc = "as the \\bt_p{logging_level} parameter of"]
#[doc = "bt_get_greatest_operative_mip_version()."]
#[doc = "@param[in] supported_versions"]
#[doc = "\\bt_c_uint_rs to which to add the ranges of supported MIP versions"]
#[doc = "of an eventual instance of \\bt_p{self_component_class} considering"]
#[doc = "\\bt_p{params} and \\bt_p{initialize_method_data}."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = "@bt_pre_not_null{supported_versions}"]
#[doc = "@pre"]
#[doc = "\\bt_p{supported_versions} is empty."]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_get_supported_mip_versions_method() &mdash;"]
#[doc = "Sets the \"get supported MIP versions\" method of a filter"]
#[doc = "component class."]
pub type bt_component_class_filter_get_supported_mip_versions_method = ::std::option::Option<
    unsafe extern "C" fn(
        source_component_class: *mut bt_self_component_class_filter,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        supported_versions: *mut bt_integer_range_set_unsigned,
    ) -> bt_component_class_get_supported_mip_versions_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp_cls \\\"get supported \\bt_mip versions\\\" method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
#[doc = "method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, you can only add the range [0,&nbsp;0]"]
#[doc = "to \\bt_p{supported_versions}."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Sink component class."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_component_descriptor_set_add_descriptor() or"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{init_method_data} parameter of"]
#[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
#[doc = "@param[in] logging_level"]
#[doc = "Logging level to use during this method's execution, as passed"]
#[doc = "as the \\bt_p{logging_level} parameter of"]
#[doc = "bt_get_greatest_operative_mip_version()."]
#[doc = "@param[in] supported_versions"]
#[doc = "\\bt_c_uint_rs to which to add the ranges of supported MIP versions"]
#[doc = "of an eventual instance of \\bt_p{self_component_class} considering"]
#[doc = "\\bt_p{params} and \\bt_p{initialize_method_data}."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = "@bt_pre_not_null{supported_versions}"]
#[doc = "@pre"]
#[doc = "\\bt_p{supported_versions} is empty."]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_get_supported_mip_versions_method() &mdash;"]
#[doc = "Sets the \"get supported MIP versions\" method of a sink"]
#[doc = "component class."]
pub type bt_component_class_sink_get_supported_mip_versions_method = ::std::option::Option<
    unsafe extern "C" fn(
        source_component_class: *mut bt_self_component_class_sink,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        supported_versions: *mut bt_integer_range_set_unsigned,
    ) -> bt_component_class_get_supported_mip_versions_method_status::Type,
>;
pub mod bt_component_class_sink_graph_is_configured_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "#bt_component_class_sink_graph_is_configured_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp \"graph is configured\" method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-graph-configured"]
#[doc = "\"graph is configured\" method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Sink component instance."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_graph_is_configured_method() &mdash;"]
#[doc = "Sets the \"graph is configured\" method of a sink component class."]
pub type bt_component_class_sink_graph_is_configured_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_sink,
    ) -> bt_component_class_sink_graph_is_configured_method_status::Type,
>;
pub mod bt_component_class_initialize_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "#bt_component_class_source_initialize_method,"]
    #[doc = "#bt_component_class_filter_initialize_method, and"]
    #[doc = "#bt_component_class_sink_initialize_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_src_comp initialization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, the \\bt_p{configuration} parameter"]
#[doc = "is not used."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Source component instance."]
#[doc = "@param[in] configuration"]
#[doc = "Initial component configuration (unused)."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_graph_add_source_component() or"]
#[doc = "bt_graph_add_source_component_with_initialize_method_data()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{initialize_method_data} parameter of"]
#[doc = "bt_graph_add_source_component_with_initialize_method_data()."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{configuration}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = ""]
#[doc = "@sa bt_component_class_source_set_initialize_method() &mdash;"]
#[doc = "Sets the initialization method of a source component class."]
pub type bt_component_class_source_initialize_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_source,
        configuration: *mut bt_self_component_source_configuration,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
    ) -> bt_component_class_initialize_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp initialization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, the \\bt_p{configuration} parameter"]
#[doc = "is not used."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Filter component instance."]
#[doc = "@param[in] configuration"]
#[doc = "Initial component configuration (unused)."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_graph_add_filter_component() or"]
#[doc = "bt_graph_add_filter_component_with_initialize_method_data()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{initialize_method_data} parameter of"]
#[doc = "bt_graph_add_filter_component_with_initialize_method_data()."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{configuration}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_initialize_method() &mdash;"]
#[doc = "Sets the initialization method of a filter component class."]
pub type bt_component_class_filter_initialize_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_filter,
        configuration: *mut bt_self_component_filter_configuration,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
    ) -> bt_component_class_initialize_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp initialization method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, the \\bt_p{configuration} parameter"]
#[doc = "is not used."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Sink component instance."]
#[doc = "@param[in] configuration"]
#[doc = "Initial component configuration (unused)."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Initialization parameters, as passed as the \\bt_p{params} parameter"]
#[doc = "of bt_graph_add_sink_component(),"]
#[doc = "bt_graph_add_sink_component_with_initialize_method_data(), or"]
#[doc = "bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] initialize_method_data"]
#[doc = "User data for this method, as passed as the"]
#[doc = "\\bt_p{initialize_method_data} parameter of"]
#[doc = "bt_graph_add_sink_component_with_initialize_method_data()."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{configuration}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_is_map_val{params}"]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_initialize_method() &mdash;"]
#[doc = "Sets the initialization method of a sink component class."]
pub type bt_component_class_sink_initialize_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_sink,
        configuration: *mut bt_self_component_sink_configuration,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
    ) -> bt_component_class_initialize_method_status::Type,
>;
pub mod bt_component_class_port_connected_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "#bt_component_class_source_output_port_connected_method,"]
    #[doc = "#bt_component_class_filter_input_port_connected_method,"]
    #[doc = "#bt_component_class_filter_output_port_connected_method, and"]
    #[doc = "#bt_component_class_sink_input_port_connected_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_src_comp \"output port connected\" method."]
#[doc = ""]
#[doc = "See the"]
#[doc = "\\ref api-comp-cls-dev-meth-oport-connected \"output port connected\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Source component instance."]
#[doc = "@param[in] self_port"]
#[doc = "Connected \\bt_oport of \\bt_p{self_component}."]
#[doc = "@param[in] other_port"]
#[doc = "\\bt_c_conn's other (input) port."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{self_port}"]
#[doc = "@bt_pre_not_null{other_port}"]
#[doc = ""]
#[doc = "@sa bt_component_class_source_set_output_port_connected_method() &mdash;"]
#[doc = "Sets the \"output port connected\" method of a source component class."]
pub type bt_component_class_source_output_port_connected_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_source,
        self_port: *mut bt_self_component_port_output,
        other_port: *const bt_port_input,
    ) -> bt_component_class_port_connected_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp \"input port connected\" method."]
#[doc = ""]
#[doc = "See the"]
#[doc = "\\ref api-comp-cls-dev-meth-iport-connected \"input port connected\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Filter component instance."]
#[doc = "@param[in] self_port"]
#[doc = "Connected \\bt_iport of \\bt_p{self_component}."]
#[doc = "@param[in] other_port"]
#[doc = "\\bt_c_conn's other (output) port."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{self_port}"]
#[doc = "@bt_pre_not_null{other_port}"]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_input_port_connected_method() &mdash;"]
#[doc = "Sets the \"input port connected\" method of a filter component class."]
pub type bt_component_class_filter_input_port_connected_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_filter,
        self_port: *mut bt_self_component_port_input,
        other_port: *const bt_port_output,
    ) -> bt_component_class_port_connected_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp \"output port connected\" method."]
#[doc = ""]
#[doc = "See the"]
#[doc = "\\ref api-comp-cls-dev-meth-oport-connected \"output port connected\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Filter component instance."]
#[doc = "@param[in] self_port"]
#[doc = "Connected \\bt_oport of \\bt_p{self_component}."]
#[doc = "@param[in] other_port"]
#[doc = "\\bt_c_conn's other (input) port."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{self_port}"]
#[doc = "@bt_pre_not_null{other_port}"]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_output_port_connected_method() &mdash;"]
#[doc = "Sets the \"output port connected\" method of a filter component class."]
pub type bt_component_class_filter_output_port_connected_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_filter,
        self_port: *mut bt_self_component_port_output,
        other_port: *const bt_port_input,
    ) -> bt_component_class_port_connected_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp \"input port connected\" method."]
#[doc = ""]
#[doc = "See the"]
#[doc = "\\ref api-comp-cls-dev-meth-iport-connected \"input port connected\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_component"]
#[doc = "Sink component instance."]
#[doc = "@param[in] self_port"]
#[doc = "Connected \\bt_iport of \\bt_p{self_component}."]
#[doc = "@param[in] other_port"]
#[doc = "\\bt_c_conn's other (output) port."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component}"]
#[doc = "@bt_pre_not_null{self_port}"]
#[doc = "@bt_pre_not_null{other_port}"]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_input_port_connected_method() &mdash;"]
#[doc = "Sets the \"input port connected\" method of a sink component class."]
pub type bt_component_class_sink_input_port_connected_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component: *mut bt_self_component_sink,
        self_port: *mut bt_self_component_port_input,
        other_port: *const bt_port_output,
    ) -> bt_component_class_port_connected_method_status::Type,
>;
pub mod bt_component_class_query_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "#bt_component_class_source_query_method,"]
    #[doc = "#bt_component_class_filter_query_method, and"]
    #[doc = "#bt_component_class_sink_query_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Unknown object to query."]
    pub const BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_UNKNOWN_OBJECT: Type = 42;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_src_comp_cls query method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Source component class, as passed as the \\bt_p{component_class}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's \\ref api-qexec \"executor\"."]
#[doc = "@param[in] query_executor"]
#[doc = "Private view of this query operation's executor."]
#[doc = "@param[in] object_name"]
#[doc = "Name of the object to query, as passed as the \\bt_p{object_name}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Query parameters, as passed as the \\bt_p{params}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] method_data"]
#[doc = "User data for this method, as passed as the \\bt_p{method_data}"]
#[doc = "parameter of bt_query_executor_create_with_method_data() when"]
#[doc = "creating this query operation's executor."]
#[doc = "@param[out] result"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is"]
#[doc = "a \\em new reference of this query operation's result."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_UNKNOWN_OBJECT"]
#[doc = "\\bt_p{object_name} is unknown."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{query_executor}"]
#[doc = "@bt_pre_not_null{object_name}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_not_null{result}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is set."]
#[doc = ""]
#[doc = "@sa bt_component_class_source_set_query_method() &mdash;"]
#[doc = "Sets the query method of a source component class."]
pub type bt_component_class_source_query_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component_class: *mut bt_self_component_class_source,
        query_executor: *mut bt_private_query_executor,
        object_name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        method_data: *mut ::std::os::raw::c_void,
        result: *mut *const bt_value,
    ) -> bt_component_class_query_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_flt_comp_cls query method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Filter component class, as passed as the \\bt_p{component_class}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's \\ref api-qexec \"executor\"."]
#[doc = "@param[in] query_executor"]
#[doc = "Private view of this query operation's executor."]
#[doc = "@param[in] object_name"]
#[doc = "Name of the object to query, as passed as the \\bt_p{object_name}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Query parameters, as passed as the \\bt_p{params}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] method_data"]
#[doc = "User data for this method, as passed as the \\bt_p{method_data}"]
#[doc = "parameter of bt_query_executor_create_with_method_data() when"]
#[doc = "creating this query operation's executor."]
#[doc = "@param[out] result"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is"]
#[doc = "a \\em new reference of this query operation's result."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_UNKNOWN_OBJECT"]
#[doc = "\\bt_p{object_name} is unknown."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{query_executor}"]
#[doc = "@bt_pre_not_null{object_name}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_not_null{result}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is set."]
#[doc = ""]
#[doc = "@sa bt_component_class_filter_set_query_method() &mdash;"]
#[doc = "Sets the query method of a filter component class."]
pub type bt_component_class_filter_query_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component_class: *mut bt_self_component_class_filter,
        query_executor: *mut bt_private_query_executor,
        object_name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        method_data: *mut ::std::os::raw::c_void,
        result: *mut *const bt_value,
    ) -> bt_component_class_query_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_sink_comp_cls query method."]
#[doc = ""]
#[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
#[doc = ""]
#[doc = "@param[in] self_component_class"]
#[doc = "Sink component class, as passed as the \\bt_p{component_class}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's \\ref api-qexec \"executor\"."]
#[doc = "@param[in] query_executor"]
#[doc = "Private view of this query operation's executor."]
#[doc = "@param[in] object_name"]
#[doc = "Name of the object to query, as passed as the \\bt_p{object_name}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = "@param[in] params"]
#[doc = "@parblock"]
#[doc = "Query parameters, as passed as the \\bt_p{params}"]
#[doc = "parameter of bt_query_executor_create() or"]
#[doc = "bt_query_executor_create_with_method_data() when creating this query"]
#[doc = "operation's executor."]
#[doc = ""]
#[doc = "\\bt_p{params} is frozen."]
#[doc = "@endparblock"]
#[doc = "@param[in] method_data"]
#[doc = "User data for this method, as passed as the \\bt_p{method_data}"]
#[doc = "parameter of bt_query_executor_create_with_method_data() when"]
#[doc = "creating this query operation's executor."]
#[doc = "@param[out] result"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is"]
#[doc = "a \\em new reference of this query operation's result."]
#[doc = ""]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_UNKNOWN_OBJECT"]
#[doc = "\\bt_p{object_name} is unknown."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_component_class}"]
#[doc = "@bt_pre_not_null{query_executor}"]
#[doc = "@bt_pre_not_null{object_name}"]
#[doc = "@bt_pre_not_null{params}"]
#[doc = "@bt_pre_not_null{result}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*result} is set."]
#[doc = ""]
#[doc = "@sa bt_component_class_sink_set_query_method() &mdash;"]
#[doc = "Sets the query method of a sink component class."]
pub type bt_component_class_sink_query_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_component_class: *mut bt_self_component_class_sink,
        query_executor: *mut bt_private_query_executor,
        object_name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        method_data: *mut ::std::os::raw::c_void,
        result: *mut *const bt_value,
    ) -> bt_component_class_query_method_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_src_comp_cls named \\bt_p{name} and having the"]
    #[doc = "\\bt_msg_iter_cls \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "On success, the returned source component class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-name \"Name\""]
    #[doc = "<td>\\bt_p{name}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-descr \"Description\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-help \"Help text\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] name"]
    #[doc = "Name of the source component class to create (copied)."]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of the source component class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New source component class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{message_iterator_class}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_class_create() &mdash;"]
    #[doc = "Creates a message iterator class."]
    pub fn bt_component_class_source_create(
        name: *const ::std::os::raw::c_char,
        message_iterator_class: *mut bt_message_iterator_class,
    ) -> *mut bt_component_class_source;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_flt_comp_cls named \\bt_p{name} and having the"]
    #[doc = "\\bt_msg_iter_cls \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "On success, the returned filter component class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-name \"Name\""]
    #[doc = "<td>\\bt_p{name}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-descr \"Description\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-help \"Help text\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] name"]
    #[doc = "Name of the filter component class to create (copied)."]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of the filter component class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New filter component class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{message_iterator_class}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_class_create() &mdash;"]
    #[doc = "Creates a message iterator class."]
    pub fn bt_component_class_filter_create(
        name: *const ::std::os::raw::c_char,
        message_iterator_class: *mut bt_message_iterator_class,
    ) -> *mut bt_component_class_filter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_sink_comp_cls named \\bt_p{name} and having the"]
    #[doc = "\\ref api-comp-cls-dev-meth-consume \"consuming method\""]
    #[doc = "\\bt_p{consume_method}."]
    #[doc = ""]
    #[doc = "On success, the returned sink component class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-name \"Name\""]
    #[doc = "<td>\\bt_p{name}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-descr \"Description\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-comp-cls-prop-help \"Help text\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] name"]
    #[doc = "Name of the sink component class to create (copied)."]
    #[doc = "@param[in] consume_method"]
    #[doc = "Consuming method of the sink component class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New sink component class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{consume_method}"]
    pub fn bt_component_class_sink_create(
        name: *const ::std::os::raw::c_char,
        consume_method: bt_component_class_sink_consume_method,
    ) -> *mut bt_component_class_sink;
}
pub mod bt_component_class_set_description_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_component_class_set_description()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the description of the component class \\bt_p{component_class}"]
    #[doc = "to a copy of \\bt_p{description}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-prop-descr \"description\" property."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to set the description to"]
    #[doc = "\\bt_p{description}."]
    #[doc = "@param[in] description"]
    #[doc = "New description of \\bt_p{component_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{description}"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_get_description() &mdash;"]
    #[doc = "Returns the description of a component class."]
    pub fn bt_component_class_set_description(
        component_class: *mut bt_component_class,
        description: *const ::std::os::raw::c_char,
    ) -> bt_component_class_set_description_status::Type;
}
pub mod bt_component_class_set_help_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_component_class_set_help()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_SET_HELP_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_CLASS_SET_HELP_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the help text of the component class \\bt_p{component_class}"]
    #[doc = "to a copy of \\bt_p{help_text}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-prop-help \"help text\" property."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class of which to set the help text to"]
    #[doc = "\\bt_p{help_text}."]
    #[doc = "@param[in] help_text"]
    #[doc = "New help text of \\bt_p{component_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_HELP_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_HELP_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{help_text}"]
    #[doc = ""]
    #[doc = "@sa bt_component_class_get_help() &mdash;"]
    #[doc = "Returns the help text of a component class."]
    pub fn bt_component_class_set_help(
        component_class: *mut bt_component_class,
        help_text: *const ::std::os::raw::c_char,
    ) -> bt_component_class_set_help_status::Type;
}
pub mod bt_component_class_set_method_status {
    #[doc = "@brief"]
    #[doc = "Status code for the"]
    #[doc = "<code>bt_component_class_*_set_*_method()</code> functions."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional finalization method of the \\bt_src_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Source component class of which to set the finalization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New finalization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_source_set_finalize_method(
        component_class: *mut bt_component_class_source,
        method: bt_component_class_source_finalize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional finalization method of the \\bt_flt_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the finalization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New finalization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_finalize_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_finalize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional finalization method of the \\bt_sink_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-fini \"finalize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the finalization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New finalization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_finalize_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_finalize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the \\\"get supported \\bt_mip versions\\\" method of the"]
    #[doc = "\\bt_src_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Source component class of which to set the \"get supported MIP"]
    #[doc = "versions\" method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"get supported MIP versions\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_source_set_get_supported_mip_versions_method(
        component_class: *mut bt_component_class_source,
        method: bt_component_class_source_get_supported_mip_versions_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the \\\"get supported \\bt_mip versions\\\" method of the"]
    #[doc = "\\bt_flt_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the \"get supported MIP"]
    #[doc = "versions\" method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"get supported MIP versions\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_get_supported_mip_versions_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_get_supported_mip_versions_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the \\\"get supported \\bt_mip versions\\\" method of the"]
    #[doc = "\\bt_sink_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-mip \"get supported MIP versions\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the \"get supported MIP"]
    #[doc = "versions\" method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"get supported MIP versions\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_get_supported_mip_versions_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_get_supported_mip_versions_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the \"graph is configured\" method of the"]
    #[doc = "\\bt_sink_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-comp-cls-dev-meth-graph-configured \"graph is configured\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the \"graph is configured\""]
    #[doc = "method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"graph is configured\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_graph_is_configured_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_graph_is_configured_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional initialization method of the \\bt_src_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Source component class of which to set the initialization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New initialization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_source_set_initialize_method(
        component_class: *mut bt_component_class_source,
        method: bt_component_class_source_initialize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional initialization method of the \\bt_flt_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the initialization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New initialization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_initialize_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_initialize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional initialization method of the \\bt_sink_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-init \"initialize\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the initialization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New initialization method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_initialize_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_initialize_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"output port connected\" method of the"]
    #[doc = "\\bt_src_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-comp-cls-dev-meth-oport-connected \"output port connected\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Source component class of which to set the \"output port connected\""]
    #[doc = "method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"output port connected\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_source_set_output_port_connected_method(
        component_class: *mut bt_component_class_source,
        method: bt_component_class_source_output_port_connected_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"input port connected\" method of the"]
    #[doc = "\\bt_flt_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-comp-cls-dev-meth-iport-connected \"input port connected\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the \"input port connected\""]
    #[doc = "method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"input port connected\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_input_port_connected_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_input_port_connected_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"output port connected\" method of the"]
    #[doc = "\\bt_flt_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-comp-cls-dev-meth-oport-connected \"output port connected\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the \"output port connected\""]
    #[doc = "method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"output port connected\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_output_port_connected_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_output_port_connected_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"input port connected\" method of the"]
    #[doc = "\\bt_sink_comp_cls \\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-comp-cls-dev-meth-iport-connected \"input port connected\""]
    #[doc = "method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the \"input port connected\""]
    #[doc = "method to \\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New \"input port connected\" method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_input_port_connected_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_input_port_connected_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional query method of the \\bt_src_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Source component class of which to set the query method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New query method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_source_set_query_method(
        component_class: *mut bt_component_class_source,
        method: bt_component_class_source_query_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional query method of the \\bt_flt_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Filter component class of which to set the query method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New query method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_filter_set_query_method(
        component_class: *mut bt_component_class_filter,
        method: bt_component_class_filter_query_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional query method of the \\bt_sink_comp_cls"]
    #[doc = "\\bt_p{component_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-cls-dev-meth-query \"query\" method."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Sink component class of which to set the query method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New query method of \\bt_p{component_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_hot{component_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_component_class_sink_set_query_method(
        component_class: *mut bt_component_class_sink,
        method: bt_component_class_sink_query_method,
    ) -> bt_component_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an empty component descriptor set."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New component descriptor set reference, or \\c NULL on memory error."]
    pub fn bt_component_descriptor_set_create() -> *mut bt_component_descriptor_set;
}
pub mod bt_component_descriptor_set_add_descriptor_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_component_descriptor_set_add_descriptor()"]
    #[doc = "and"]
    #[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Alias of"]
    #[doc = "bt_component_descriptor_set_add_descriptor_with_initialize_method_data()"]
    #[doc = "with the \\bt_p{initialize_method_data} parameter set to \\c NULL."]
    pub fn bt_component_descriptor_set_add_descriptor(
        component_descriptor_set: *mut bt_component_descriptor_set,
        component_class: *const bt_component_class,
        params: *const bt_value,
    ) -> bt_component_descriptor_set_add_descriptor_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a descriptor of a \\bt_comp which would be an instance of the"]
    #[doc = "\\bt_comp_cls \\bt_p{component_class}, would receive the parameters"]
    #[doc = "\\bt_p{params} and the method data \\bt_p{initialize_method_data} at"]
    #[doc = "initialization time, to the component descriptor set"]
    #[doc = "\\bt_p{component_descriptor_set}."]
    #[doc = ""]
    #[doc = "@param[in] component_descriptor_set"]
    #[doc = "Component descriptor set to which to add a component descriptor."]
    #[doc = "@param[in] component_class"]
    #[doc = "\\bt_c_comp_cls which would be instantiated to create the"]
    #[doc = "described component."]
    #[doc = "@param[in] params"]
    #[doc = "@parblock"]
    #[doc = "Parameters which would be passed to the initialization method of"]
    #[doc = "the described component as the \\bt_p{params} parameter."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case it is equivalent to passing an empty"]
    #[doc = "\\bt_map_val."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] initialize_method_data"]
    #[doc = "User data which would be passed to the initialization method of"]
    #[doc = "the described component as the \\bt_p{initialize_method_data}"]
    #[doc = "parameter."]
    #[doc = ""]
    #[doc = "@retval #BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_descriptor_set}"]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{params} is a \\bt_map_val (bt_value_is_map() returns #BT_TRUE)"]
    #[doc = "or is \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{component_class}"]
    #[doc = "@bt_post_success_frozen{params}"]
    pub fn bt_component_descriptor_set_add_descriptor_with_initialize_method_data(
        component_descriptor_set: *mut bt_component_descriptor_set,
        component_class: *const bt_component_class,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
    ) -> bt_component_descriptor_set_add_descriptor_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component descriptor set \\bt_p{component_descriptor_set}."]
    #[doc = ""]
    #[doc = "@param[in] component_descriptor_set"]
    #[doc = "@parblock"]
    #[doc = "Component descriptor set of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_descriptor_set_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a component descriptor set."]
    pub fn bt_component_descriptor_set_get_ref(
        component_descriptor_set: *const bt_component_descriptor_set,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component descriptor set \\bt_p{component_descriptor_set}."]
    #[doc = ""]
    #[doc = "@param[in] component_descriptor_set"]
    #[doc = "@parblock"]
    #[doc = "Component descriptor set of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_descriptor_set_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a component descriptor set."]
    pub fn bt_component_descriptor_set_put_ref(
        component_descriptor_set: *const bt_component_descriptor_set,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the \\ref api-comp-cls \"class\" of"]
    #[doc = "the component \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Component of which to get the class's type enumerator."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of the class of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = ""]
    #[doc = "@sa bt_component_is_source() &mdash;"]
    #[doc = "Returns whether or not a component is a \\bt_src_comp."]
    #[doc = "@sa bt_component_is_filter() &mdash;"]
    #[doc = "Returns whether or not a component is a \\bt_flt_comp."]
    #[doc = "@sa bt_component_is_sink() &mdash;"]
    #[doc = "Returns whether or not a component is a \\bt_sink_comp."]
    pub fn bt_component_get_class_type(
        component: *const bt_component,
    ) -> bt_component_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-comp-cls \"class\" of the component"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Component of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_borrow_class_const(
        component: *const bt_component,
    ) -> *const bt_component_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the component \\bt_p{component}."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Component of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_get_name(component: *const bt_component) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the logging level of the component \\bt_p{component} and its"]
    #[doc = "\\bt_p_msg_iter, if any."]
    #[doc = ""]
    #[doc = "See the \\ref api-comp-prop-log-lvl \"logging level\" property."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Component of which to get the logging level."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Logging level of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_get_logging_level(component: *const bt_component)
        -> bt_logging_level::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Component of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a component."]
    pub fn bt_component_get_ref(component: *const bt_component);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the component \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Component of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a component."]
    pub fn bt_component_put_ref(component: *const bt_component);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-comp-cls \"class\" of the \\bt_src_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Source component of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_source_borrow_class_const(
        component: *const bt_component_source,
    ) -> *const bt_component_class_source;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_oport that the \\bt_src_comp"]
    #[doc = "\\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Source component of which to get the number of output ports."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of output ports that \\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_source_get_output_port_count(component: *const bt_component_source) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport at index \\bt_p{index} from the"]
    #[doc = "\\bt_src_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Source component from which to borrow the output port at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the output port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of output ports"]
    #[doc = "\\bt_p{component} has (as returned by"]
    #[doc = "bt_component_source_get_output_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_source_get_output_port_count() &mdash;"]
    #[doc = "Returns the number of output ports that a source component has."]
    pub fn bt_component_source_borrow_output_port_by_index_const(
        component: *const bt_component_source,
        index: u64,
    ) -> *const bt_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport named \\bt_p{name} from the \\bt_src_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{component} has no output port named \\bt_p{name}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Source component from which to borrow the output port"]
    #[doc = "named \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_component_source_borrow_output_port_by_name_const(
        component: *const bt_component_source,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_src_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Source component of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_source_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a source component."]
    pub fn bt_component_source_get_ref(component: *const bt_component_source);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_src_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Source component of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_source_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a source component."]
    pub fn bt_component_source_put_ref(component: *const bt_component_source);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-comp-cls \"class\" of the \\bt_flt_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_filter_borrow_class_const(
        component: *const bt_component_filter,
    ) -> *const bt_component_class_filter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_iport that the \\bt_flt_comp"]
    #[doc = "\\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component of which to get the number of input ports."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of input ports that \\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_filter_get_input_port_count(component: *const bt_component_filter) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_iport at index \\bt_p{index} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component from which to borrow the input port at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the input port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of input ports"]
    #[doc = "\\bt_p{component} has (as returned by"]
    #[doc = "bt_component_filter_get_input_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_get_input_port_count() &mdash;"]
    #[doc = "Returns the number of input ports that a filter component has."]
    pub fn bt_component_filter_borrow_input_port_by_index_const(
        component: *const bt_component_filter,
        index: u64,
    ) -> *const bt_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_iport named \\bt_p{name} from the \\bt_flt_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{component} has no input port named \\bt_p{name}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component from which to borrow the input port"]
    #[doc = "named \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the input port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_component_filter_borrow_input_port_by_name_const(
        component: *const bt_component_filter,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_oport that the \\bt_flt_comp"]
    #[doc = "\\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component of which to get the number of output ports."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of output ports that \\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_filter_get_output_port_count(component: *const bt_component_filter) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport at index \\bt_p{index} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component from which to borrow the output port at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the output port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of output ports"]
    #[doc = "\\bt_p{component} has (as returned by"]
    #[doc = "bt_component_filter_get_output_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_get_output_port_count() &mdash;"]
    #[doc = "Returns the number of output ports that a filter component has."]
    pub fn bt_component_filter_borrow_output_port_by_index_const(
        component: *const bt_component_filter,
        index: u64,
    ) -> *const bt_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport named \\bt_p{name} from the \\bt_flt_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{component} has no output port named \\bt_p{name}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Filter component from which to borrow the output port"]
    #[doc = "named \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_component_filter_borrow_output_port_by_name_const(
        component: *const bt_component_filter,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_flt_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Filter component of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a filter component."]
    pub fn bt_component_filter_get_ref(component: *const bt_component_filter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_flt_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Filter component of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a filter component."]
    pub fn bt_component_filter_put_ref(component: *const bt_component_filter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-comp-cls \"class\" of the \\bt_sink_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Sink component of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_sink_borrow_class_const(
        component: *const bt_component_sink,
    ) -> *const bt_component_class_sink;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_iport that the \\bt_sink_comp"]
    #[doc = "\\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Sink component of which to get the number of input ports."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of input ports that \\bt_p{component} has."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    pub fn bt_component_sink_get_input_port_count(component: *const bt_component_sink) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_iport at index \\bt_p{index} from the"]
    #[doc = "\\bt_sink_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Sink component from which to borrow the input port at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the input port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of input ports"]
    #[doc = "\\bt_p{component} has (as returned by"]
    #[doc = "bt_component_sink_get_input_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_sink_get_input_port_count() &mdash;"]
    #[doc = "Returns the number of input ports that a sink component has."]
    pub fn bt_component_sink_borrow_input_port_by_index_const(
        component: *const bt_component_sink,
        index: u64,
    ) -> *const bt_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport named \\bt_p{name} from the \\bt_sink_comp"]
    #[doc = "\\bt_p{component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{component} has no output port named \\bt_p{name}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "Sink component from which to borrow the output port"]
    #[doc = "named \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to borrow from \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_component_sink_borrow_input_port_by_name_const(
        component: *const bt_component_sink,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_sink_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Sink component of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_sink_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a sink component."]
    pub fn bt_component_sink_get_ref(component: *const bt_component_sink);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_sink_comp \\bt_p{component}."]
    #[doc = ""]
    #[doc = "@param[in] component"]
    #[doc = "@parblock"]
    #[doc = "Sink component of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_sink_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a sink component."]
    pub fn bt_component_sink_put_ref(component: *const bt_component_sink);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the upstream \\bt_iport of the connection \\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@param[in] connection"]
    #[doc = "Connection of which to borrow the upstream port."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the upstream port of \\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{connection}"]
    pub fn bt_connection_borrow_downstream_port_const(
        connection: *const bt_connection,
    ) -> *const bt_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the downstream \\bt_oport of the connection"]
    #[doc = "\\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@param[in] connection"]
    #[doc = "Connection of which to borrow the downstream port."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the downstream port of \\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{connection}"]
    pub fn bt_connection_borrow_upstream_port_const(
        connection: *const bt_connection,
    ) -> *const bt_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the connection \\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@param[in] connection"]
    #[doc = "@parblock"]
    #[doc = "Connection of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_connection_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a connection."]
    pub fn bt_connection_get_ref(connection: *const bt_connection);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the connection \\bt_p{connection}."]
    #[doc = ""]
    #[doc = "@param[in] connection"]
    #[doc = "@parblock"]
    #[doc = "Connection of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_connection_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a connection."]
    pub fn bt_connection_put_ref(connection: *const bt_connection);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default, empty trace processing graph honouring version"]
    #[doc = "\\bt_p{mip_version} of the \\bt_mip."]
    #[doc = ""]
    #[doc = "On success, the returned graph contains no components (see"]
    #[doc = "\\ref api-graph-lc-add \"Add components\")."]
    #[doc = ""]
    #[doc = "The graph is configured as operating following version"]
    #[doc = "\\bt_p{mip_version} of the Message Interchange Protocol, so that"]
    #[doc = "bt_self_component_get_graph_mip_version() returns this version when"]
    #[doc = "components call it."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "As of \\bt_name_version_min_maj, the only available MIP version is 0."]
    #[doc = ""]
    #[doc = "The returned graph has a default \\bt_intr. Any \\bt_comp you add with the"]
    #[doc = "<code>bt_graph_add_*_component*()</code> functions and all their"]
    #[doc = "\\bt_p_msg_iter also have this same default interrupter. Borrow the graph's"]
    #[doc = "default interrupter with bt_graph_borrow_default_interrupter()."]
    #[doc = ""]
    #[doc = "@param[in] mip_version"]
    #[doc = "Version of the Message Interchange Protocol to use within the"]
    #[doc = "graph to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New trace processing graph reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@pre"]
    #[doc = "\\bt_p{mip_version} is 0."]
    pub fn bt_graph_create(mip_version: u64) -> *mut bt_graph;
}
pub mod bt_graph_add_component_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the"]
    #[doc = "<code>bt_graph_add_*_component*()</code> functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_ADD_COMPONENT_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_ADD_COMPONENT_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Alias of bt_graph_add_source_component_with_initialize_method_data()"]
    #[doc = "with the \\bt_p{initialize_method_data} parameter set to \\c NULL."]
    pub fn bt_graph_add_source_component(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_source,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_source,
    ) -> bt_graph_add_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_src_comp from the"]
    #[doc = "\\ref api-tir-comp-cls \"class\" \\bt_p{component_class}"]
    #[doc = "with the initialization parameters \\bt_p{params}, the initialization"]
    #[doc = "user data \\bt_p{initialize_method_data}, and the initial"]
    #[doc = "logging level \\bt_p{logging_level}, adds it to the trace processing"]
    #[doc = "graph \\bt_p{graph} with the name \\bt_p{name}, and sets"]
    #[doc = "\\bt_p{*component} to the resulting component."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-add \"Add components\" to learn more about adding"]
    #[doc = "components to a trace processing graph."]
    #[doc = ""]
    #[doc = "This function calls the source component's"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization method\" after"]
    #[doc = "creating it."]
    #[doc = ""]
    #[doc = "The created source component's initialization method receives:"]
    #[doc = ""]
    #[doc = "- \\bt_p{params} as its own \\bt_p{params} parameter (or an empty"]
    #[doc = "\\bt_map_val if \\bt_p{params} is \\c NULL)."]
    #[doc = ""]
    #[doc = "- \\bt_p{initialize_method_data} as its own \\bt_p{initialize_method_data}"]
    #[doc = "parameter."]
    #[doc = ""]
    #[doc = "The created source component can get its logging level"]
    #[doc = "(\\bt_p{logging_level}) with bt_component_get_logging_level()."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to which to add the created source component."]
    #[doc = "@param[in] component_class"]
    #[doc = "Class to instantiate within \\bt_p{graph}."]
    #[doc = "@param[in] name"]
    #[doc = "Unique name, within \\bt_p{graph}, of the component to create."]
    #[doc = "@param[in] params"]
    #[doc = "@parblock"]
    #[doc = "Initialization parameters to use when creating the source component."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case the created source component's"]
    #[doc = "initialization method receives an empty \\bt_map_val as its"]
    #[doc = "\\bt_p{params} parameter."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] initialize_method_data"]
    #[doc = "User data passed as is to the created source component's"]
    #[doc = "initialization method."]
    #[doc = "@param[in] logging_level"]
    #[doc = "Initial logging level of the source component to create."]
    #[doc = "@param[out] component"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*component} is"]
    #[doc = "a \\em borrowed reference of the created source component."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_ERROR"]
    #[doc = "Other error, for example, the created source component's"]
    #[doc = "initialization method failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_configured{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other component within \\bt_p{graph} has the name \\bt_p{name}."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{params} is a \\bt_map_val (bt_value_is_map() returns #BT_TRUE)"]
    #[doc = "or is \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{component_class}"]
    #[doc = "@bt_post_success_frozen{params}"]
    pub fn bt_graph_add_source_component_with_initialize_method_data(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_source,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_source,
    ) -> bt_graph_add_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Alias of bt_graph_add_filter_component_with_initialize_method_data()"]
    #[doc = "with the \\bt_p{initialize_method_data} parameter set to \\c NULL."]
    pub fn bt_graph_add_filter_component(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_filter,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_filter,
    ) -> bt_graph_add_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_flt_comp from the"]
    #[doc = "\\ref api-tir-comp-cls \"class\" \\bt_p{component_class}"]
    #[doc = "with the initialization parameters \\bt_p{params}, the initialization"]
    #[doc = "user data \\bt_p{initialize_method_data}, and the initial"]
    #[doc = "logging level \\bt_p{logging_level}, adds it to the trace processing"]
    #[doc = "graph \\bt_p{graph} with the name \\bt_p{name}, and sets"]
    #[doc = "\\bt_p{*component} to the resulting component."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-add \"Add components\" to learn more about adding"]
    #[doc = "components to a trace processing graph."]
    #[doc = ""]
    #[doc = "This function calls the filter component's"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization method\" after"]
    #[doc = "creating it."]
    #[doc = ""]
    #[doc = "The created filter component's initialization method receives:"]
    #[doc = ""]
    #[doc = "- \\bt_p{params} as its own \\bt_p{params} parameter (or an empty"]
    #[doc = "\\bt_map_val if \\bt_p{params} is \\c NULL)."]
    #[doc = ""]
    #[doc = "- \\bt_p{initialize_method_data} as its own \\bt_p{initialize_method_data}"]
    #[doc = "parameter."]
    #[doc = ""]
    #[doc = "The created filter component can get its logging level"]
    #[doc = "(\\bt_p{logging_level}) with bt_component_get_logging_level()."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to which to add the created filter component."]
    #[doc = "@param[in] component_class"]
    #[doc = "Class to instantiate within \\bt_p{graph}."]
    #[doc = "@param[in] name"]
    #[doc = "Unique name, within \\bt_p{graph}, of the component to create."]
    #[doc = "@param[in] params"]
    #[doc = "@parblock"]
    #[doc = "Initialization parameters to use when creating the filter component."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case the created filter component's"]
    #[doc = "initialization method receives an empty \\bt_map_val as its"]
    #[doc = "\\bt_p{params} parameter."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] initialize_method_data"]
    #[doc = "User data passed as is to the created filter component's"]
    #[doc = "initialization method."]
    #[doc = "@param[in] logging_level"]
    #[doc = "Initial logging level of the filter component to create."]
    #[doc = "@param[out] component"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*component} is"]
    #[doc = "a \\em borrowed reference of the created filter component."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_ERROR"]
    #[doc = "Other error, for example, the created filter component's"]
    #[doc = "initialization method failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_configured{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other component within \\bt_p{graph} has the name \\bt_p{name}."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{params} is a \\bt_map_val (bt_value_is_map() returns #BT_TRUE)"]
    #[doc = "or is \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{component_class}"]
    #[doc = "@bt_post_success_frozen{params}"]
    pub fn bt_graph_add_filter_component_with_initialize_method_data(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_filter,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_filter,
    ) -> bt_graph_add_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Alias of bt_graph_add_sink_component_with_initialize_method_data()"]
    #[doc = "with the \\bt_p{initialize_method_data} parameter set to \\c NULL."]
    pub fn bt_graph_add_sink_component(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_sink,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_sink,
    ) -> bt_graph_add_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_sink_comp from the"]
    #[doc = "\\ref api-tir-comp-cls \"class\" \\bt_p{component_class}"]
    #[doc = "with the initialization parameters \\bt_p{params}, the initialization"]
    #[doc = "user data \\bt_p{initialize_method_data}, and the initial"]
    #[doc = "logging level \\bt_p{logging_level}, adds it to the trace processing"]
    #[doc = "graph \\bt_p{graph} with the name \\bt_p{name}, and sets"]
    #[doc = "\\bt_p{*component} to the resulting component."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-add \"Add components\" to learn more about adding"]
    #[doc = "components to a trace processing graph."]
    #[doc = ""]
    #[doc = "This function calls the sink component's"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization method\" after"]
    #[doc = "creating it."]
    #[doc = ""]
    #[doc = "The created sink component's initialization method receives:"]
    #[doc = ""]
    #[doc = "- \\bt_p{params} as its own \\bt_p{params} parameter (or an empty"]
    #[doc = "\\bt_map_val if \\bt_p{params} is \\c NULL)."]
    #[doc = ""]
    #[doc = "- \\bt_p{initialize_method_data} as its own \\bt_p{initialize_method_data}"]
    #[doc = "parameter."]
    #[doc = ""]
    #[doc = "The created sink component can get its logging level"]
    #[doc = "(\\bt_p{logging_level}) with bt_component_get_logging_level()."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to which to add the created sink component."]
    #[doc = "@param[in] component_class"]
    #[doc = "Class to instantiate within \\bt_p{graph}."]
    #[doc = "@param[in] name"]
    #[doc = "Unique name, within \\bt_p{graph}, of the component to create."]
    #[doc = "@param[in] params"]
    #[doc = "@parblock"]
    #[doc = "Initialization parameters to use when creating the sink component."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case the created sink component's"]
    #[doc = "initialization method receives an empty \\bt_map_val as its"]
    #[doc = "\\bt_p{params} parameter."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] initialize_method_data"]
    #[doc = "User data passed as is to the created sink component's"]
    #[doc = "initialization method."]
    #[doc = "@param[in] logging_level"]
    #[doc = "Initial logging level of the sink component to create."]
    #[doc = "@param[out] component"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*component} is"]
    #[doc = "a \\em borrowed reference of the created sink component."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_ERROR"]
    #[doc = "Other error, for example, the created sink component's"]
    #[doc = "initialization method failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_configured{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other component within \\bt_p{graph} has the name \\bt_p{name}."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{params} is a \\bt_map_val (bt_value_is_map() returns #BT_TRUE)"]
    #[doc = "or is \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{component_class}"]
    #[doc = "@bt_post_success_frozen{params}"]
    pub fn bt_graph_add_sink_component_with_initialize_method_data(
        graph: *mut bt_graph,
        component_class: *const bt_component_class_sink,
        name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        initialize_method_data: *mut ::std::os::raw::c_void,
        logging_level: bt_logging_level::Type,
        component: *mut *const bt_component_sink,
    ) -> bt_graph_add_component_status::Type;
}
pub mod bt_graph_simple_sink_component_initialize_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the #bt_graph_simple_sink_component_initialize_func"]
    #[doc = "type."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User initialization function for"]
#[doc = "bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "Such an initialization function is called when the trace processing"]
#[doc = "graph becomes configured and when the simple sink component has created"]
#[doc = "its single \\bt_msg_iter. This occurs the first time you call"]
#[doc = "bt_graph_run() or bt_graph_run_once() on the trace processing graph."]
#[doc = ""]
#[doc = "See \\ref api-graph-lc-add-ss \"Add a simple sink component\" to learn more"]
#[doc = "about adding a simple component to a trace processing graph."]
#[doc = ""]
#[doc = "@param[in] message_iterator"]
#[doc = "@parblock"]
#[doc = "Simple sink component's upstream message iterator."]
#[doc = ""]
#[doc = "This user function is free to get the message iterator's next"]
#[doc = "message or to make it seek."]
#[doc = "@endparblock"]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{message_iterator}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "The reference count of \\bt_p{message_iterator} is not changed."]
#[doc = ""]
#[doc = "@sa bt_graph_add_simple_sink_component() &mdash;"]
#[doc = "Creates and adds a simple sink component to a trace processing"]
#[doc = "graph."]
pub type bt_graph_simple_sink_component_initialize_func = ::std::option::Option<
    unsafe extern "C" fn(
        message_iterator: *mut bt_message_iterator,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_simple_sink_component_initialize_func_status::Type,
>;
pub mod bt_graph_simple_sink_component_consume_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the #bt_graph_simple_sink_component_consume_func"]
    #[doc = "type."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "End of processing."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_END: Type = 1;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User consuming function for bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "Such a consuming function is called when the simple sink component's own"]
#[doc = "\\ref api-comp-cls-dev-meth-consume \"consuming method\" is called. This"]
#[doc = "occurs in a loop within bt_graph_run() or when it's this sink"]
#[doc = "component's turn to consume in"]
#[doc = "bt_graph_run_once()."]
#[doc = ""]
#[doc = "See \\ref api-graph-lc-add-ss \"Add a simple sink component\" to learn more"]
#[doc = "about adding a simple component to a trace processing graph."]
#[doc = ""]
#[doc = "If you are not done consuming messages, return"]
#[doc = "#BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_OK."]
#[doc = ""]
#[doc = "If you are done consuming messages, return"]
#[doc = "#BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_END."]
#[doc = ""]
#[doc = "If you wish to avoid a blocking operation and make"]
#[doc = "bt_graph_run() or bt_graph_run_once() aware, return"]
#[doc = "#BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_AGAIN."]
#[doc = ""]
#[doc = "@param[in] message_iterator"]
#[doc = "@parblock"]
#[doc = "Simple sink component's upstream message iterator."]
#[doc = ""]
#[doc = "This user function is free to get the message iterator's next"]
#[doc = "message or to make it seek."]
#[doc = "@endparblock"]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_END"]
#[doc = "End of processing."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{message_iterator}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "The reference count of \\bt_p{message_iterator} is not changed."]
#[doc = ""]
#[doc = "@sa bt_graph_add_simple_sink_component() &mdash;"]
#[doc = "Creates and adds a simple sink component to a trace processing"]
#[doc = "graph."]
pub type bt_graph_simple_sink_component_consume_func = ::std::option::Option<
    unsafe extern "C" fn(
        message_iterator: *mut bt_message_iterator,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_simple_sink_component_consume_func_status::Type,
>;
#[doc = "@brief"]
#[doc = "User finalization function for bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "Such a finalization function is called when the simple sink component"]
#[doc = "is finalized. This occurs when the trace processing graph is destroyed"]
#[doc = "(you put its last strong \\ref api-fund-shared-object \"reference\""]
#[doc = "with bt_graph_put_ref())."]
#[doc = ""]
#[doc = "See \\ref api-graph-lc-add-ss \"Add a simple sink component\" to learn more"]
#[doc = "about adding a simple component to a trace processing graph."]
#[doc = ""]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_simple_sink_component()."]
#[doc = ""]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_graph_add_simple_sink_component() &mdash;"]
#[doc = "Creates and adds a simple sink component to a trace processing"]
#[doc = "graph."]
pub type bt_graph_simple_sink_component_finalize_func =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a simple \\bt_sink_comp, adds it to the trace processing"]
    #[doc = "graph \\bt_p{graph} with the name \\bt_p{name}, and sets"]
    #[doc = "\\bt_p{*component} to the resulting component."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-add-ss \"Add a simple sink component\" to learn more"]
    #[doc = "about adding a simple component to a trace processing graph."]
    #[doc = ""]
    #[doc = "\\bt_p{initialize_func} (if not \\c NULL), \\bt_p{consume_func},"]
    #[doc = "and \\bt_p{finalize_func} (if not \\c NULL) receive \\bt_p{user_data}"]
    #[doc = "as their own \\bt_p{user_data} parameter."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to which to add the created simple sink"]
    #[doc = "component."]
    #[doc = "@param[in] name"]
    #[doc = "Unique name, within \\bt_p{graph}, of the component to create."]
    #[doc = "@param[in] initialize_func"]
    #[doc = "@parblock"]
    #[doc = "User initialization function."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] consume_func"]
    #[doc = "User consuming function."]
    #[doc = "@param[in] finalize_func"]
    #[doc = "@parblock"]
    #[doc = "User finalization function."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{initialize_func}, \\bt_p{consume_func}, and"]
    #[doc = "\\bt_p{finalize_func}."]
    #[doc = "@param[out] component"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*component} is"]
    #[doc = "a \\em borrowed reference of the created simple sink component."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_ADD_COMPONENT_STATUS_ERROR"]
    #[doc = "Other error, for example, the created sink component's"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization method\" failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_configured{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other component within \\bt_p{graph} has the name \\bt_p{name}."]
    #[doc = "@bt_pre_not_null{consume_func}"]
    pub fn bt_graph_add_simple_sink_component(
        graph: *mut bt_graph,
        name: *const ::std::os::raw::c_char,
        initialize_func: bt_graph_simple_sink_component_initialize_func,
        consume_func: bt_graph_simple_sink_component_consume_func,
        finalize_func: bt_graph_simple_sink_component_finalize_func,
        user_data: *mut ::std::os::raw::c_void,
        component: *mut *const bt_component_sink,
    ) -> bt_graph_add_component_status::Type;
}
pub mod bt_graph_connect_ports_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_graph_connect_ports()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_CONNECT_PORTS_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_CONNECT_PORTS_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_CONNECT_PORTS_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Connects the \\bt_oport \\bt_p{upstream_port} to the \\bt_iport"]
    #[doc = "\\bt_p{downstream_port} within the trace processing graph"]
    #[doc = "\\bt_p{graph}, and sets \\bt_p{*connection} to the resulting"]
    #[doc = "\\bt_conn."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-connect \"Connect component ports\" to learn more"]
    #[doc = "about connecting ports within a trace processing graph."]
    #[doc = ""]
    #[doc = "Both \\bt_p{upstream_port} and \\bt_p{downstream_port} must be"]
    #[doc = "unconnected (bt_port_is_connected() returns #BT_FALSE) when you call"]
    #[doc = "this function."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph containing the \\bt_p_comp to which belong"]
    #[doc = "\\bt_p{upstream_port} and \\bt_p{downstream_port}."]
    #[doc = "@param[in] upstream_port"]
    #[doc = "\\bt_c_oport to connect to \\bt_p{downstream_port}."]
    #[doc = "@param[in] downstream_port"]
    #[doc = "\\bt_c_iport to connect to \\bt_p{upstream_port}."]
    #[doc = "@param[in] connection"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*connection} is"]
    #[doc = "a \\em borrowed reference of the resulting \\bt_conn."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_CONNECT_PORTS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_CONNECT_PORTS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_CONNECT_PORTS_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_configured{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{upstream_port}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{graph} contains the component of \\bt_p{upstream_port},"]
    #[doc = "as returned by bt_port_borrow_component_const()."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{upstream_port} is unconnected"]
    #[doc = "(bt_port_is_connected() returns #BT_FALSE)."]
    #[doc = "@bt_pre_not_null{downstream_port}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{graph} contains the component of \\bt_p{downstream_port},"]
    #[doc = "as returned by bt_port_borrow_component_const()."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{downstream_port} is unconnected"]
    #[doc = "(bt_port_is_connected() returns #BT_FALSE)."]
    #[doc = "@pre"]
    #[doc = "Connecting \\bt_p{upstream_port} to \\bt_p{downstream_port} does not"]
    #[doc = "form a connection cycle within \\bt_p{graph}."]
    pub fn bt_graph_connect_ports(
        graph: *mut bt_graph,
        upstream_port: *const bt_port_output,
        downstream_port: *const bt_port_input,
        connection: *mut *const bt_connection,
    ) -> bt_graph_connect_ports_status::Type;
}
pub mod bt_graph_run_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_graph_run()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_RUN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_GRAPH_RUN_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_RUN_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_RUN_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Runs the trace processing graph \\bt_p{graph}, calling each"]
    #[doc = "\\bt_sink_comp's"]
    #[doc = "\\ref api-comp-cls-dev-meth-consume \"consuming method\" in a round"]
    #[doc = "robin fashion until they are all done consuming or an exception"]
    #[doc = "occurs."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-run \"Run\" to learn more about running a trace"]
    #[doc = "processing graph."]
    #[doc = ""]
    #[doc = "This function does \\em not return until one of:"]
    #[doc = ""]
    #[doc = "- All the sink components are ended, in which case this function"]
    #[doc = "returns #BT_GRAPH_RUN_STATUS_OK."]
    #[doc = ""]
    #[doc = "- One of the sink component returns an error, in which case this"]
    #[doc = "function returns #BT_GRAPH_RUN_STATUS_ERROR or"]
    #[doc = "#BT_GRAPH_RUN_STATUS_MEMORY_ERROR."]
    #[doc = ""]
    #[doc = "- One of the sink component returns \"try again\", in which case"]
    #[doc = "this function returns #BT_GRAPH_RUN_STATUS_AGAIN."]
    #[doc = ""]
    #[doc = "In that case, you can call this function again later, usually after"]
    #[doc = "waiting for some time."]
    #[doc = ""]
    #[doc = "This feature exists to allow blocking operations within components"]
    #[doc = "to be postponed until they don't block. The graph user can perform"]
    #[doc = "other tasks instead of the graph's thread blocking."]
    #[doc = ""]
    #[doc = "- \\bt_p{graph} is interrupted (see bt_graph_borrow_default_interrupter()"]
    #[doc = "and bt_graph_add_interrupter()), in which case this function returns"]
    #[doc = "#BT_GRAPH_RUN_STATUS_AGAIN."]
    #[doc = ""]
    #[doc = "Check the \\bt_intr's state with bt_interrupter_is_set() to"]
    #[doc = "distinguish between a sink component returning \"try again\" and"]
    #[doc = "\\bt_p{graph} getting interrupted."]
    #[doc = ""]
    #[doc = "To make a single sink component consume, then get the thread's control"]
    #[doc = "back, use bt_graph_run_once()."]
    #[doc = ""]
    #[doc = "When you call this function or bt_graph_run_once() for the first time,"]
    #[doc = "\\bt_p{graph} becomes <em>configured</em>. See"]
    #[doc = "\\ref api-graph-lc \"Trace processing graph life cycle\""]
    #[doc = "to learn what happens when a trace processing graph becomes configured,"]
    #[doc = "and what you can and cannot do with a configured graph."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to run."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_RUN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_RUN_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_GRAPH_RUN_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_RUN_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@pre"]
    #[doc = "For each \\bt_src_comp within \\bt_p{graph}, at least one \\bt_oport"]
    #[doc = "is connected."]
    #[doc = "@pre"]
    #[doc = "For each \\bt_flt_comp within \\bt_p{graph}, at least one \\bt_iport"]
    #[doc = "and one \\bt_iport are connected."]
    #[doc = "@pre"]
    #[doc = "For each \\bt_sink_comp within \\bt_p{graph}, at least one \\bt_iport"]
    #[doc = "is connected."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{graph} contains at least one sink component."]
    #[doc = ""]
    #[doc = "@sa bt_graph_run_once() &mdash;"]
    #[doc = "Calls a single trace processing graph's sink component's consuming"]
    #[doc = "method once."]
    pub fn bt_graph_run(graph: *mut bt_graph) -> bt_graph_run_status::Type;
}
pub mod bt_graph_run_once_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_graph_run()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_RUN_ONCE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "All sink components are finished processing."]
    pub const BT_GRAPH_RUN_ONCE_STATUS_END: Type = 1;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_GRAPH_RUN_ONCE_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_RUN_ONCE_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_RUN_ONCE_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Calls the \\ref api-comp-cls-dev-meth-consume \"consuming method\" of"]
    #[doc = "the next non-ended \\bt_sink_comp to make consume within the trace"]
    #[doc = "processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-lc-run \"Run\" to learn more about running a trace"]
    #[doc = "processing graph."]
    #[doc = ""]
    #[doc = "This function makes the \\em next non-ended sink component consume. For"]
    #[doc = "example, if \\bt_p{graph} has two non-ended sink components A and B:"]
    #[doc = ""]
    #[doc = "- Calling bt_graph_run_once() makes sink component A consume."]
    #[doc = "- Calling bt_graph_run_once() again makes sink component B consume."]
    #[doc = "- Calling bt_graph_run_once() again makes sink component A consume."]
    #[doc = "- ..."]
    #[doc = ""]
    #[doc = "Considering this, if \\bt_p{graph} contains a single non-ended sink"]
    #[doc = "component, this function \\em always makes this sink component consume."]
    #[doc = ""]
    #[doc = "If the sink component's consuming method:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>Succeeds</dt>"]
    #[doc = "<dd>This function returns #BT_GRAPH_RUN_ONCE_STATUS_OK.</dd>"]
    #[doc = ""]
    #[doc = "<dt>Returns \"try again\"</dt>"]
    #[doc = "<dd>This function returns #BT_GRAPH_RUN_ONCE_STATUS_AGAIN.</dd>"]
    #[doc = ""]
    #[doc = "<dt>Fails</dt>"]
    #[doc = "<dd>"]
    #[doc = "This function returns #BT_GRAPH_RUN_ONCE_STATUS_MEMORY_ERROR"]
    #[doc = "or #BT_GRAPH_RUN_ONCE_STATUS_ERROR."]
    #[doc = "</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "When all the sink components of \\bt_p{graph} are finished processing"]
    #[doc = "(ended), this function returns #BT_GRAPH_RUN_ONCE_STATUS_END."]
    #[doc = ""]
    #[doc = "bt_graph_run() calls this function in a loop until are the sink"]
    #[doc = "components are ended or an exception occurs."]
    #[doc = ""]
    #[doc = "When you call this function or bt_graph_run() for the first time,"]
    #[doc = "\\bt_p{graph} becomes <em>configured</em>. See"]
    #[doc = "\\ref api-graph-lc \"Trace processing graph life cycle\""]
    #[doc = "to learn what happens when a trace processing graph becomes configured,"]
    #[doc = "and what you can and cannot do with a configured graph."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph of which to make the next sink component"]
    #[doc = "consume."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_RUN_ONCE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_RUN_ONCE_STATUS_END"]
    #[doc = "All sink components are finished processing."]
    #[doc = "@retval #BT_GRAPH_RUN_ONCE_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_GRAPH_RUN_ONCE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GRAPH_RUN_ONCE_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = ""]
    #[doc = "@sa bt_graph_run() &mdash;"]
    #[doc = "Runs a trace processing graph, making all its sink components"]
    #[doc = "consume in a round robin fashion."]
    pub fn bt_graph_run_once(graph: *mut bt_graph) -> bt_graph_run_once_status::Type;
}
pub mod bt_graph_add_interrupter_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_graph_add_interrupter()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_ADD_INTERRUPTER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_ADD_INTERRUPTER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds the \\bt_intr \\bt_p{interrupter} to all the current and future"]
    #[doc = "\\bt_p_sink_comp and \\bt_p_msg_iter of the trace processing graph"]
    #[doc = "\\bt_p{graph}, as well as to the graph itself."]
    #[doc = ""]
    #[doc = "Sink components can check whether or not they are interrupted"]
    #[doc = "with bt_self_component_sink_is_interrupted()."]
    #[doc = ""]
    #[doc = "Message iterators can check whether or not they are interrupted"]
    #[doc = "with bt_self_message_iterator_is_interrupted()."]
    #[doc = ""]
    #[doc = "The bt_graph_run() loop intermittently checks whether or not any of the"]
    #[doc = "graph's interrupters is set. If so, bt_graph_run() returns"]
    #[doc = "#BT_GRAPH_RUN_STATUS_AGAIN."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "@parblock"]
    #[doc = "bt_graph_create() returns a trace processing graph which comes"]
    #[doc = "with its own <em>default interrupter</em>."]
    #[doc = ""]
    #[doc = "Instead of adding your own interrupter to \\bt_p{graph}, you can"]
    #[doc = "set its default interrupter with"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_interrupter_set(bt_graph_borrow_default_interrupter());"]
    #[doc = "@endcode"]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to which to add \\bt_p{interrupter}."]
    #[doc = "@param[in] interrupter"]
    #[doc = "Interrupter to add to \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_INTERRUPTER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_INTERRUPTER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{interrupter}"]
    #[doc = ""]
    #[doc = "@sa bt_graph_borrow_default_interrupter() &mdash;"]
    #[doc = "Borrows the default interrupter from a trace processing graph."]
    pub fn bt_graph_add_interrupter(
        graph: *mut bt_graph,
        interrupter: *const bt_interrupter,
    ) -> bt_graph_add_interrupter_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_intr from the trace processing graph"]
    #[doc = "\\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph from which to borrow the default interrupter."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the default interrupter of \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{graph} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = ""]
    #[doc = "@sa bt_graph_add_interrupter() &mdash;"]
    #[doc = "Adds an interrupter to a trace processing graph."]
    pub fn bt_graph_borrow_default_interrupter(graph: *mut bt_graph) -> *mut bt_interrupter;
}
pub mod bt_graph_add_listener_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the"]
    #[doc = "<code>bt_graph_add_*_component_*_port_added_listener()</code>"]
    #[doc = "functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_ADD_LISTENER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR: Type = -12;
}
pub mod bt_graph_listener_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the"]
    #[doc = "<code>bt_graph_*_component_*_port_added_listener_func()</code>"]
    #[doc = "types."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GRAPH_LISTENER_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GRAPH_LISTENER_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User function for"]
#[doc = "bt_graph_add_filter_component_input_port_added_listener()."]
#[doc = ""]
#[doc = "Such a function is called whenever a \\bt_flt_comp within a trace"]
#[doc = "processing graph adds an \\bt_iport during the graph"]
#[doc = "\\ref api-graph-lc \"configuration\" phase."]
#[doc = ""]
#[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
#[doc = ""]
#[doc = "@param[in] component"]
#[doc = "Filter component which added \\bt_p{port}."]
#[doc = "@param[in] port"]
#[doc = "Input port added by \\bt_p{component}."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_filter_component_input_port_added_listener()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{component}"]
#[doc = "@bt_pre_not_null{port}"]
#[doc = ""]
#[doc = "@sa bt_graph_add_filter_component_input_port_added_listener() &mdash;"]
#[doc = "Adds a \"filter component input port added\" listener to a trace"]
#[doc = "processing graph."]
pub type bt_graph_filter_component_input_port_added_listener_func = ::std::option::Option<
    unsafe extern "C" fn(
        component: *const bt_component_filter,
        port: *const bt_port_input,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_listener_func_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a \\\"\\bt_flt_comp \\bt_iport added\\\" listener to the trace"]
    #[doc = "processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "Once this function returns, \\bt_p{user_func} is called whenever a"]
    #[doc = "filter component adds an input port within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to add the \"filter component input port"]
    #[doc = "added\" listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the \"filter component input port added\" listener to"]
    #[doc = "add to \\bt_p{graph}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added listener within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    pub fn bt_graph_add_filter_component_input_port_added_listener(
        graph: *mut bt_graph,
        user_func: bt_graph_filter_component_input_port_added_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_graph_add_listener_status::Type;
}
#[doc = "@brief"]
#[doc = "User function for"]
#[doc = "bt_graph_add_sink_component_input_port_added_listener()."]
#[doc = ""]
#[doc = "Such a function is called whenever a \\bt_sink_comp within a trace"]
#[doc = "processing graph adds an \\bt_iport during the graph"]
#[doc = "\\ref api-graph-lc \"configuration\" phase."]
#[doc = ""]
#[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
#[doc = ""]
#[doc = "@param[in] component"]
#[doc = "Filter component which added \\bt_p{port}."]
#[doc = "@param[in] port"]
#[doc = "Input port added by \\bt_p{component}."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_sink_component_input_port_added_listener()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{component}"]
#[doc = "@bt_pre_not_null{port}"]
#[doc = ""]
#[doc = "@sa bt_graph_add_sink_component_input_port_added_listener() &mdash;"]
#[doc = "Adds a \"sink component input port added\" listener to a trace"]
#[doc = "processing graph."]
pub type bt_graph_sink_component_input_port_added_listener_func = ::std::option::Option<
    unsafe extern "C" fn(
        component: *const bt_component_sink,
        port: *const bt_port_input,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_listener_func_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a \\\"\\bt_sink_comp \\bt_iport added\\\" listener to the trace"]
    #[doc = "processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "Once this function returns, \\bt_p{user_func} is called whenever a"]
    #[doc = "sink component adds an input port within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to add the \"sink component input port"]
    #[doc = "added\" listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the \"sink component input port added\" listener to"]
    #[doc = "add to \\bt_p{graph}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added listener within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    pub fn bt_graph_add_sink_component_input_port_added_listener(
        graph: *mut bt_graph,
        user_func: bt_graph_sink_component_input_port_added_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_graph_add_listener_status::Type;
}
#[doc = "@brief"]
#[doc = "User function for"]
#[doc = "bt_graph_add_source_component_output_port_added_listener()."]
#[doc = ""]
#[doc = "Such a function is called whenever a \\bt_src_comp within a trace"]
#[doc = "processing graph adds an \\bt_oport during the graph"]
#[doc = "\\ref api-graph-lc \"configuration\" phase."]
#[doc = ""]
#[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
#[doc = ""]
#[doc = "@param[in] component"]
#[doc = "Filter component which added \\bt_p{port}."]
#[doc = "@param[in] port"]
#[doc = "Input port added by \\bt_p{component}."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_source_component_output_port_added_listener()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{component}"]
#[doc = "@bt_pre_not_null{port}"]
#[doc = ""]
#[doc = "@sa bt_graph_add_source_component_output_port_added_listener() &mdash;"]
#[doc = "Adds a \"source component output port added\" listener to a trace"]
#[doc = "processing graph."]
pub type bt_graph_source_component_output_port_added_listener_func = ::std::option::Option<
    unsafe extern "C" fn(
        component: *const bt_component_source,
        port: *const bt_port_output,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_listener_func_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a \\\"\\bt_src_comp \\bt_oport added\\\" listener to the trace"]
    #[doc = "processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "Once this function returns, \\bt_p{user_func} is called whenever a"]
    #[doc = "source component adds an output port within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to add the \"source component output port"]
    #[doc = "added\" listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the \"source component output port added\" listener"]
    #[doc = "to add to \\bt_p{graph}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added listener within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    pub fn bt_graph_add_source_component_output_port_added_listener(
        graph: *mut bt_graph,
        user_func: bt_graph_source_component_output_port_added_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_graph_add_listener_status::Type;
}
#[doc = "@brief"]
#[doc = "User function for"]
#[doc = "bt_graph_add_filter_component_output_port_added_listener()."]
#[doc = ""]
#[doc = "Such a function is called whenever a \\bt_flt_comp within a trace"]
#[doc = "processing graph adds an \\bt_oport during the graph"]
#[doc = "\\ref api-graph-lc \"configuration\" phase."]
#[doc = ""]
#[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
#[doc = ""]
#[doc = "@param[in] component"]
#[doc = "Filter component which added \\bt_p{port}."]
#[doc = "@param[in] port"]
#[doc = "Input port added by \\bt_p{component}."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_graph_add_filter_component_output_port_added_listener()."]
#[doc = ""]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_GRAPH_LISTENER_FUNC_STATUS_ERROR"]
#[doc = "Other error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{component}"]
#[doc = "@bt_pre_not_null{port}"]
#[doc = ""]
#[doc = "@sa bt_graph_add_filter_component_output_port_added_listener() &mdash;"]
#[doc = "Adds a \"filter component output port added\" listener to a trace"]
#[doc = "processing graph."]
pub type bt_graph_filter_component_output_port_added_listener_func = ::std::option::Option<
    unsafe extern "C" fn(
        component: *const bt_component_filter,
        port: *const bt_port_output,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_graph_listener_func_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a \\\"\\bt_flt_comp \\bt_oport added\\\" listener to the trace"]
    #[doc = "processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "Once this function returns, \\bt_p{user_func} is called whenever a"]
    #[doc = "filter component adds an output port within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "See \\ref api-graph-listeners \"Listeners\" to learn more."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "Trace processing graph to add the \"filter component output port"]
    #[doc = "added\" listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the \"filter component output port added\" listener"]
    #[doc = "to add to \\bt_p{graph}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added listener within \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{graph}"]
    #[doc = "@bt_pre_graph_not_faulty{graph}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    pub fn bt_graph_add_filter_component_output_port_added_listener(
        graph: *mut bt_graph,
        user_func: bt_graph_filter_component_output_port_added_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_graph_add_listener_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "@parblock"]
    #[doc = "Trace processing graph of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_graph_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a trace processing graph."]
    pub fn bt_graph_get_ref(graph: *const bt_graph);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace processing graph \\bt_p{graph}."]
    #[doc = ""]
    #[doc = "@param[in] graph"]
    #[doc = "@parblock"]
    #[doc = "Trace processing graph of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_graph_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a trace processing graph."]
    pub fn bt_graph_put_ref(graph: *const bt_graph);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default interrupter."]
    #[doc = ""]
    #[doc = "On success, the returned interrupter is \\em not set"]
    #[doc = "(bt_interrupter_is_set() returns #BT_FALSE)."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New interrupter reference, or \\c NULL on memory error."]
    pub fn bt_interrupter_create() -> *mut bt_interrupter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the interrupter \\bt_p{interrupter}."]
    #[doc = ""]
    #[doc = "After you call this function, bt_interrupter_is_set() returns"]
    #[doc = "#BT_TRUE."]
    #[doc = ""]
    #[doc = "@param[in] interrupter"]
    #[doc = "Interrupter to set."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{interrupter}"]
    #[doc = ""]
    #[doc = "@sa bt_interrupter_reset() &mdash;"]
    #[doc = "Resets an interrupter."]
    #[doc = "@sa bt_interrupter_is_set() &mdash;"]
    #[doc = "Returns whether or not an interrupter is set."]
    pub fn bt_interrupter_set(interrupter: *mut bt_interrupter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Resets the interrupter \\bt_p{interrupter}."]
    #[doc = ""]
    #[doc = "After you call this function, bt_interrupter_is_set() returns"]
    #[doc = "#BT_FALSE."]
    #[doc = ""]
    #[doc = "@param[in] interrupter"]
    #[doc = "Interrupter to reset."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{interrupter}"]
    #[doc = ""]
    #[doc = "@sa bt_interrupter_set() &mdash;"]
    #[doc = "Sets an interrupter."]
    #[doc = "@sa bt_interrupter_is_set() &mdash;"]
    #[doc = "Returns whether or not an interrupter is set."]
    pub fn bt_interrupter_reset(interrupter: *mut bt_interrupter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the interrupter \\bt_p{interrupter} is set."]
    #[doc = ""]
    #[doc = "@param[in] interrupter"]
    #[doc = "Interrupter to reset."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{interrupter} is set."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{interrupter}"]
    #[doc = ""]
    #[doc = "@sa bt_interrupter_set() &mdash;"]
    #[doc = "Sets an interrupter."]
    #[doc = "@sa bt_interrupter_reset() &mdash;"]
    #[doc = "Resets an interrupter."]
    pub fn bt_interrupter_is_set(interrupter: *const bt_interrupter) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the interrupter \\bt_p{interrupter}."]
    #[doc = ""]
    #[doc = "@param[in] interrupter"]
    #[doc = "@parblock"]
    #[doc = "Interrupter of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_interrupter_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of an interrupter."]
    pub fn bt_interrupter_get_ref(interrupter: *const bt_interrupter);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the interrupter \\bt_p{interrupter}."]
    #[doc = ""]
    #[doc = "@param[in] interrupter"]
    #[doc = "@parblock"]
    #[doc = "Interrupter of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_interrupter_get_ref() &mdash;"]
    #[doc = "Increments the reference count of an interrupter."]
    pub fn bt_interrupter_put_ref(interrupter: *const bt_interrupter);
}
pub mod bt_message_iterator_create_from_message_iterator_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_create_from_message_iterator()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a message iterator on the \\bt_iport \\bt_p{port} from"]
    #[doc = "another message iterator \\bt_p{self_message_iterator}, and sets"]
    #[doc = "\\bt_p{*message_iterator} to the resulting message iterator."]
    #[doc = ""]
    #[doc = "On success, the message iterator's position is at the beginning"]
    #[doc = "of its \\ref api-msg-seq \"message sequence\"."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Other message iterator from which to create the message iterator."]
    #[doc = "@param[in] port"]
    #[doc = "Input port on which to create the message iterator."]
    #[doc = "@param[out] message_iterator"]
    #[doc = "<strong>On success</strong>, \\bt_p{*message_iterator} is a new"]
    #[doc = "message iterator reference."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_ERROR"]
    #[doc = "Other error, for example, the created message iterator's"]
    #[doc = "\\ref api-msg-iter-cls-meth-init \"initialization method\" failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{port}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_port_is_connected(port)</code> returns #BT_TRUE."]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_create_from_sink_component() &mdash;"]
    #[doc = "Creates a message iterator from a \\bt_sink_comp."]
    pub fn bt_message_iterator_create_from_message_iterator(
        self_message_iterator: *mut bt_self_message_iterator,
        port: *mut bt_self_component_port_input,
        message_iterator: *mut *mut bt_message_iterator,
    ) -> bt_message_iterator_create_from_message_iterator_status::Type;
}
pub mod bt_message_iterator_create_from_sink_component_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_create_from_sink_component()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a message iterator on the \\bt_iport \\bt_p{port} from the"]
    #[doc = "\\bt_sink_comp \\bt_p{self_component_sink}, and sets"]
    #[doc = "\\bt_p{*message_iterator} to the resulting message iterator."]
    #[doc = ""]
    #[doc = "On success, the message iterator's position is at the beginning"]
    #[doc = "of its \\ref api-msg-seq \"message sequence\"."]
    #[doc = ""]
    #[doc = "@param[in] self_component_sink"]
    #[doc = "Sink component from which to create the message iterator."]
    #[doc = "@param[in] port"]
    #[doc = "Input port on which to create the message iterator."]
    #[doc = "@param[out] message_iterator"]
    #[doc = "<strong>On success</strong>, \\bt_p{*message_iterator} is a new"]
    #[doc = "message iterator reference."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_ERROR"]
    #[doc = "Other error, for example, the created message iterator's"]
    #[doc = "\\ref api-msg-iter-cls-meth-init \"initialization method\" failed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component_sink}"]
    #[doc = "@bt_pre_not_null{port}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_port_is_connected(port)</code> returns #BT_TRUE."]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_create_from_message_iterator() &mdash;"]
    #[doc = "Creates a message iterator from another message iterator."]
    pub fn bt_message_iterator_create_from_sink_component(
        self_component_sink: *mut bt_self_component_sink,
        port: *mut bt_self_component_port_input,
        message_iterator: *mut *mut bt_message_iterator,
    ) -> bt_message_iterator_create_from_sink_component_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_comp which provides the \\bt_msg_iter"]
    #[doc = "\\bt_p{message_iterator}."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator from which to borrow the component which provides"]
    #[doc = "it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component which provides \\bt_p{message_iterator}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    pub fn bt_message_iterator_borrow_component(
        message_iterator: *mut bt_message_iterator,
    ) -> *mut bt_component;
}
pub mod bt_message_iterator_next_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_next()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_NEXT_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "End of iteration."]
    pub const BT_MESSAGE_ITERATOR_NEXT_STATUS_END: Type = 1;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_NEXT_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_NEXT_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_NEXT_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the next \\bt_p_msg of the message iterator"]
    #[doc = "\\bt_p{message_iterator} into the \\bt_p{*messages} array of size"]
    #[doc = "\\bt_p{*count}, effectively advancing \\bt_p{message_iterator}."]
    #[doc = ""]
    #[doc = "See \\ref api-msg-iter-op-next \"this operation's documentation\"."]
    #[doc = ""]
    #[doc = "On success, the message iterator's position is advanced by \\bt_p{*count}"]
    #[doc = "messages."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator from which to get the next messages."]
    #[doc = "@param[out] messages"]
    #[doc = "@parblock"]
    #[doc = "<strong>On success</strong>, \\bt_p{*messages} is an array containing"]
    #[doc = "the next messages of \\bt_p{message_iterator} as its first elements."]
    #[doc = ""]
    #[doc = "\\bt_p{*count} is the number of messages in \\bt_p{*messages}."]
    #[doc = ""]
    #[doc = "The library allocates and manages this array, but until you"]
    #[doc = "perform another \\ref api-msg-iter-ops \"operation\" on"]
    #[doc = "\\bt_p{message_iterator}, you are free to modify it. For example,"]
    #[doc = "you can set its elements to \\c NULL if your use case needs it."]
    #[doc = ""]
    #[doc = "You own the references of the messages this array contains. In"]
    #[doc = "other words, you must put them with bt_message_put_ref() or move"]
    #[doc = "them to another message array (from a"]
    #[doc = "\\link api-msg-iter-cls-meth-next \"next\" method\\endlink)"]
    #[doc = "before you perform another operation on \\bt_p{message_iterator} or"]
    #[doc = "before \\bt_p{message_iterator} is destroyed."]
    #[doc = "@endparblock"]
    #[doc = "@param[out] count"]
    #[doc = "<strong>On success</strong>, \\bt_p{*count} is the number of messages"]
    #[doc = "in \\bt_p{*messages}."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_NEXT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_NEXT_STATUS_END"]
    #[doc = "End of iteration."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_NEXT_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_NEXT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_NEXT_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = "@bt_pre_not_null{messages}"]
    #[doc = "@bt_pre_not_null{count}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, \\bt_p{*count}&nbsp;&nbsp;1."]
    pub fn bt_message_iterator_next(
        message_iterator: *mut bt_message_iterator,
        messages: *mut bt_message_array_const,
        count: *mut u64,
    ) -> bt_message_iterator_next_status::Type;
}
pub mod bt_message_iterator_can_seek_beginning_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_can_seek_beginning()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the message iterator \\bt_p{message_iterator}"]
    #[doc = "can currently seek its beginning (first \\bt_msg)."]
    #[doc = ""]
    #[doc = "See the \\link api-msg-iter-op-seek-beg \"seek beginning\""]
    #[doc = "operation\\endlink."]
    #[doc = ""]
    #[doc = "Make sure to call this function, without performing any other"]
    #[doc = "\\ref api-msg-iter-ops \"operation\" on \\bt_p{message_iterator}, before you"]
    #[doc = "call bt_message_iterator_seek_beginning()."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator from which to to get whether or not it can seek"]
    #[doc = "its beginning."]
    #[doc = "@param[out] can_seek_beginning"]
    #[doc = "<strong>On success</strong>, \\bt_p{*can_seek_beginning} is #BT_TRUE"]
    #[doc = "if \\bt_p{message_iterator} can seek its beginning."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = "@bt_pre_not_null{can_seek_beginning}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_seek_beginning() &mdash;"]
    #[doc = "Makes a message iterator seek its beginning."]
    pub fn bt_message_iterator_can_seek_beginning(
        message_iterator: *mut bt_message_iterator,
        can_seek_beginning: *mut bt_bool,
    ) -> bt_message_iterator_can_seek_beginning_status::Type;
}
pub mod bt_message_iterator_seek_beginning_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_seek_beginning()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Makes the message iterator \\bt_p{message_iterator} seek its"]
    #[doc = "beginning (first \\bt_msg)."]
    #[doc = ""]
    #[doc = "See \\ref api-msg-iter-op-seek-beg \"this operation's documentation\"."]
    #[doc = ""]
    #[doc = "Make sure to call bt_message_iterator_can_seek_beginning(),"]
    #[doc = "without performing any other \\ref api-msg-iter-ops \"operation\" on"]
    #[doc = "\\bt_p{message_iterator}, before you call this function."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator to seek to its beginning."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_message_iterator_can_seek_beginning(message_iterator)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_can_seek_beginning() &mdash;"]
    #[doc = "Returns whether or not a message iterator can currently seek its"]
    #[doc = "beginning."]
    pub fn bt_message_iterator_seek_beginning(
        message_iterator: *mut bt_message_iterator,
    ) -> bt_message_iterator_seek_beginning_status::Type;
}
pub mod bt_message_iterator_can_seek_ns_from_origin_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_can_seek_ns_from_origin()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the message iterator \\bt_p{message_iterator}"]
    #[doc = "can currently seek a \\bt_msg occurring at or after"]
    #[doc = "\\bt_p{ns_from_origin} nanoseconds from its"]
    #[doc = "\\ref api-tir-clock-cls-origin \"clock class origin\"."]
    #[doc = ""]
    #[doc = "See the \\link api-msg-iter-op-seek-ns \"seek ns from origin\""]
    #[doc = "operation\\endlink."]
    #[doc = ""]
    #[doc = "Make sure to call this function, without performing any other"]
    #[doc = "\\ref api-msg-iter-ops \"operation\" on \\bt_p{message_iterator}, before you"]
    #[doc = "call bt_message_iterator_seek_ns_from_origin()."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator from which to to get whether or not it can seek"]
    #[doc = "its beginning."]
    #[doc = "@param[in] ns_from_origin"]
    #[doc = "Requested time point to seek."]
    #[doc = "@param[out] can_seek_ns_from_origin"]
    #[doc = "<strong>On success</strong>, \\bt_p{*can_seek_ns_from_origin} is"]
    #[doc = "#BT_TRUE if \\bt_p{message_iterator} can seek a message occurring at"]
    #[doc = "or after \\bt_p{ns_from_origin} nanoseconds from its clock class"]
    #[doc = "origin."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = "@bt_pre_not_null{can_seek_ns_from_origin}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_seek_ns_from_origin() &mdash;"]
    #[doc = "Makes a message iterator seek a message occurring at or after"]
    #[doc = "a given time from its clock class origin."]
    pub fn bt_message_iterator_can_seek_ns_from_origin(
        message_iterator: *mut bt_message_iterator,
        ns_from_origin: i64,
        can_seek_ns_from_origin: *mut bt_bool,
    ) -> bt_message_iterator_can_seek_ns_from_origin_status::Type;
}
pub mod bt_message_iterator_seek_ns_from_origin_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_message_iterator_seek_ns_from_origin()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Makes the message iterator \\bt_p{message_iterator} seek a \\bt_msg"]
    #[doc = "occurring at or after \\bt_p{ns_from_origin} nanoseconds from its"]
    #[doc = "\\ref api-tir-clock-cls-origin \"clock class origin\"."]
    #[doc = ""]
    #[doc = "See \\ref api-msg-iter-op-seek-ns \"this operation's documentation\"."]
    #[doc = ""]
    #[doc = "Make sure to call bt_message_iterator_can_seek_ns_from_origin(),"]
    #[doc = "without performing any other \\ref api-msg-iter-ops \"operation\" on"]
    #[doc = "\\bt_p{message_iterator}, before you call this function."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator to seek to a message occurring at or after"]
    #[doc = "\\bt_p{ns_from_origin} nanoseconds from its clock class origin."]
    #[doc = "@param[in] ns_from_origin"]
    #[doc = "Time point to seek."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_message_iterator_can_seek_ns_from_origin(message_iterator,&nbsp;ns_from_origin)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_can_seek_ns_from_origin() &mdash;"]
    #[doc = "Returns whether or not a message iterator can currently seek a"]
    #[doc = "message occurring at or after a given time from its clock class"]
    #[doc = "origin."]
    pub fn bt_message_iterator_seek_ns_from_origin(
        message_iterator: *mut bt_message_iterator,
        ns_from_origin: i64,
    ) -> bt_message_iterator_seek_ns_from_origin_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the message iterator \\bt_p{message_iterator}"]
    #[doc = "can seek forward."]
    #[doc = ""]
    #[doc = "A message iterator can seek forward if all the \\bt_p_msg of its"]
    #[doc = "message sequence have some \\bt_cs."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "Message iterator of which to get whether or not it can seek forward."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{message_iterator} can seek forward."]
    #[doc = ""]
    #[doc = "@sa bt_self_message_iterator_configuration_set_can_seek_forward() &mdash;"]
    #[doc = "Sets whether or not a message iterator can seek forward."]
    pub fn bt_message_iterator_can_seek_forward(
        message_iterator: *mut bt_message_iterator,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message iterator \\bt_p{message_iterator}."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "@parblock"]
    #[doc = "Message iterator of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a message iterator."]
    pub fn bt_message_iterator_get_ref(message_iterator: *const bt_message_iterator);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message iterator \\bt_p{message_iterator}."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator"]
    #[doc = "@parblock"]
    #[doc = "Message iterator of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a message iterator."]
    pub fn bt_message_iterator_put_ref(message_iterator: *const bt_message_iterator);
}
pub mod bt_message_type {
    #[doc = "@brief"]
    #[doc = "Message type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "\\bt_c_sb_msg."]
    pub const BT_MESSAGE_TYPE_STREAM_BEGINNING: Type = 1;
    #[doc = "@brief"]
    #[doc = "\\bt_c_se_msg."]
    pub const BT_MESSAGE_TYPE_STREAM_END: Type = 2;
    #[doc = "@brief"]
    #[doc = "\\bt_c_ev_msg."]
    pub const BT_MESSAGE_TYPE_EVENT: Type = 4;
    #[doc = "@brief"]
    #[doc = "\\bt_c_pb_msg."]
    pub const BT_MESSAGE_TYPE_PACKET_BEGINNING: Type = 8;
    #[doc = "@brief"]
    #[doc = "\\bt_c_pe_msg."]
    pub const BT_MESSAGE_TYPE_PACKET_END: Type = 16;
    #[doc = "@brief"]
    #[doc = "\\bt_c_disc_ev_msg."]
    pub const BT_MESSAGE_TYPE_DISCARDED_EVENTS: Type = 32;
    #[doc = "@brief"]
    #[doc = "\\bt_c_disc_pkt_msg."]
    pub const BT_MESSAGE_TYPE_DISCARDED_PACKETS: Type = 64;
    #[doc = "@brief"]
    #[doc = "\\bt_c_inac_msg."]
    pub const BT_MESSAGE_TYPE_MESSAGE_ITERATOR_INACTIVITY: Type = 128;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the message \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Message of which to get the type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    pub fn bt_message_get_type(message: *const bt_message) -> bt_message_type::Type;
}
pub mod bt_message_stream_clock_snapshot_state {
    #[doc = "@brief"]
    #[doc = "Return type of"]
    #[doc = "bt_message_stream_beginning_borrow_default_clock_snapshot_const()"]
    #[doc = "and"]
    #[doc = "bt_message_stream_end_borrow_default_clock_snapshot_const()."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Known \\bt_cs."]
    pub const BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN: Type = 1;
    #[doc = "@brief"]
    #[doc = "Unknown (no) \\bt_cs."]
    pub const BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_UNKNOWN: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_sb_msg for the \\bt_stream \\bt_p{stream} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "On success, the returned stream beginning message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-sb-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-sb-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the stream beginning"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which the message to create indicates the beginning."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream beginning message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_stream_beginning_create(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_sb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-sb-prop-stream \"stream\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream beginning message from which to borrow the stream."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_sb_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_beginning_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_stream_beginning_borrow_stream(message: *mut bt_message) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_sb_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_stream_beginning_borrow_stream()."]
    pub fn bt_message_stream_beginning_borrow_stream_const(
        message: *const bt_message,
    ) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value, in clock cycles, of the default \\bt_cs of the"]
    #[doc = "\\bt_sb_msg \\bt_p{message} to \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-sb-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream beginning message of which to set the default clock snapshot"]
    #[doc = "value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_hot{message}"]
    #[doc = "@bt_pre_is_sb_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{message} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_beginning_borrow_default_clock_snapshot_const() &mdash;"]
    #[doc = "Borrows the default clock snapshot of a stream beginning message."]
    pub fn bt_message_stream_beginning_set_default_clock_snapshot(
        message: *mut bt_message,
        value: u64,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_cs of the \\bt_sb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-sb-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream beginning message from which to borrow the default clock"]
    #[doc = "snapshot."]
    #[doc = "@param[out] clock_snapshot"]
    #[doc = "<strong>If this function returns"]
    #[doc = "#BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN</strong>,"]
    #[doc = "\\bt_p{*clock_snapshot} is a \\em borrowed reference of the default"]
    #[doc = "clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN"]
    #[doc = "The default clock snapshot of \\bt_p{message} is known and returned"]
    #[doc = "as \\bt_p{*clock_snapshot}."]
    #[doc = "@retval #BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_UNKNOWN"]
    #[doc = "\\bt_p{message} has no default clock snapshot: its time is unknown."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_sb_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{message} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = "@bt_pre_not_null{clock_snapshot}"]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_beginning_set_default_clock_snapshot() &mdash;"]
    #[doc = "Sets the default clock snapshot of a stream beginning message."]
    pub fn bt_message_stream_beginning_borrow_default_clock_snapshot_const(
        message: *const bt_message,
        clock_snapshot: *mut *const bt_clock_snapshot,
    ) -> bt_message_stream_clock_snapshot_state::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_sb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_message_stream_beginning_borrow_stream_const(message)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream beginning message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_sb_msg{message}"]
    pub fn bt_message_stream_beginning_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_se_msg for the \\bt_stream \\bt_p{stream} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "On success, the returned stream end message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the stream end"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which the message to create indicates the end."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream end message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_stream_end_create(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_se_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-se-prop-stream \"stream\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream end message from which to borrow the stream."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_se_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_end_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_stream_end_borrow_stream(message: *mut bt_message) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_se_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_stream_end_borrow_stream()."]
    pub fn bt_message_stream_end_borrow_stream_const(
        message: *const bt_message,
    ) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value, in clock cycles, of the default \\bt_cs of the"]
    #[doc = "\\bt_se_msg \\bt_p{message} to \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-se-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream end message of which to set the default clock snapshot"]
    #[doc = "value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_hot{message}"]
    #[doc = "@bt_pre_is_se_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{message} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_end_borrow_default_clock_snapshot_const() &mdash;"]
    #[doc = "Borrows the default clock snapshot of a stream end message."]
    pub fn bt_message_stream_end_set_default_clock_snapshot(message: *mut bt_message, value: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_cs of the \\bt_se_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-se-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream end message from which to borrow the default clock"]
    #[doc = "snapshot."]
    #[doc = "@param[out] clock_snapshot"]
    #[doc = "<strong>If this function returns"]
    #[doc = "#BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN</strong>,"]
    #[doc = "\\bt_p{*clock_snapshot} is a \\em borrowed reference of the default"]
    #[doc = "clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN"]
    #[doc = "The default clock snapshot of \\bt_p{message} is known and returned"]
    #[doc = "as \\bt_p{*clock_snapshot}."]
    #[doc = "@retval #BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_UNKNOWN"]
    #[doc = "\\bt_p{message} has no default clock snapshot: its time is unknown."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_se_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{message} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = "@bt_pre_not_null{clock_snapshot}"]
    #[doc = ""]
    #[doc = "@sa bt_message_stream_end_set_default_clock_snapshot() &mdash;"]
    #[doc = "Sets the default clock snapshot of a stream end message."]
    pub fn bt_message_stream_end_borrow_default_clock_snapshot_const(
        message: *const bt_message,
        clock_snapshot: *mut *const bt_clock_snapshot,
    ) -> bt_message_stream_clock_snapshot_state::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_se_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_message_stream_end_borrow_stream_const(message)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Stream end message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_se_msg{message}"]
    pub fn bt_message_stream_end_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_ev_msg, having an instance of the \\bt_ev_cls"]
    #[doc = "\\bt_p{event_class}, for the \\bt_stream \\bt_p{stream} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE and"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_event_create_with_default_clock_snapshot(),"]
    #[doc = "bt_message_event_create_with_packet(), or"]
    #[doc = "bt_message_event_create_with_packet_and_default_clock_snapshot()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event message has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-ev-prop-ev \"Event\""]
    #[doc = "<td>"]
    #[doc = "An instance (with \\bt_p_field that are not set) of"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the event message."]
    #[doc = "@param[in] event_class"]
    #[doc = "Class of the \\bt_ev of the message to create."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream conceptually containing the event of the message to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{event_class} is also the class of"]
    #[doc = "\\bt_p{stream}, that is,"]
    #[doc = "<code>bt_event_class_borrow_stream_class_const(event_class)</code>"]
    #[doc = "and"]
    #[doc = "<code>bt_stream_borrow_class_const(stream)</code> have the"]
    #[doc = "same value."]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{event_class}"]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_event_create(
        self_message_iterator: *mut bt_self_message_iterator,
        event_class: *const bt_event_class,
        stream: *const bt_stream,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_ev_msg, having an instance of the \\bt_ev_cls"]
    #[doc = "\\bt_p{event_class} and a default \\bt_cs with the value"]
    #[doc = "\\bt_p{clock_snapshot_value}, for the \\bt_stream \\bt_p{stream} from"]
    #[doc = "the \\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE and"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "does \\em not return \\c NULL."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_event_create(),"]
    #[doc = "bt_message_event_create_with_packet(), or"]
    #[doc = "bt_message_event_create_with_packet_and_default_clock_snapshot()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event message has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-ev-prop-ev \"Event\""]
    #[doc = "<td>"]
    #[doc = "An instance (with \\bt_p_field that are not set) of"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{clock_snapshot_value}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the event message."]
    #[doc = "@param[in] event_class"]
    #[doc = "Class of the \\bt_ev of the message to create."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream conceptually containing the event of the message to create."]
    #[doc = "@param[in] clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{event_class} is also the class of"]
    #[doc = "\\bt_p{stream}, that is,"]
    #[doc = "<code>bt_event_class_borrow_stream_class_const(event_class)</code>"]
    #[doc = "and"]
    #[doc = "<code>bt_stream_borrow_class_const(stream)</code> have the"]
    #[doc = "same value."]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "does \\em not return \\c NULL."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{event_class}"]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_event_create_with_default_clock_snapshot(
        self_message_iterator: *mut bt_self_message_iterator,
        event_class: *const bt_event_class,
        stream: *const bt_stream,
        clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_ev_msg, having an instance of the \\bt_ev_cls"]
    #[doc = "\\bt_p{event_class}, for the \\bt_pkt \\bt_p{packet} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_supports_packets("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE and"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_event_create(),"]
    #[doc = "bt_message_event_create_with_default_clock_snapshot(), or"]
    #[doc = "bt_message_event_create_with_packet_and_default_clock_snapshot()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event message has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-ev-prop-ev \"Event\""]
    #[doc = "<td>"]
    #[doc = "An instance (with \\bt_p_field that are not set) of"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the event message."]
    #[doc = "@param[in] event_class"]
    #[doc = "Class of the \\bt_ev of the message to create."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet conceptually containing the event of the message to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{event_class} is also the stream class of"]
    #[doc = "\\bt_p{packet}, that is,"]
    #[doc = "<code>bt_event_class_borrow_stream_class_const(event_class)</code>"]
    #[doc = "and"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>"]
    #[doc = "have the same value."]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))</code>"]
    #[doc = "returns \\c NULL."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{event_class}"]
    #[doc = "@bt_post_success_frozen{packet}"]
    pub fn bt_message_event_create_with_packet(
        self_message_iterator: *mut bt_self_message_iterator,
        event_class: *const bt_event_class,
        packet: *const bt_packet,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_ev_msg, having an instance of the \\bt_ev_cls"]
    #[doc = "\\bt_p{event_class} and a default \\bt_cs with the value"]
    #[doc = "\\bt_p{clock_snapshot_value}, for the \\bt_pkt \\bt_p{packet} from"]
    #[doc = "the \\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_supports_packets("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE and"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "does \\em not return \\c NULL."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_event_create(),"]
    #[doc = "bt_message_event_create_with_default_clock_snapshot(), or"]
    #[doc = "bt_message_event_create_with_packet()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event message has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-ev-prop-ev \"Event\""]
    #[doc = "<td>"]
    #[doc = "An instance (with \\bt_p_field that are not set) of"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-se-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{clock_snapshot_value}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the event message."]
    #[doc = "@param[in] event_class"]
    #[doc = "Class of the \\bt_ev of the message to create."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet conceptually containing the event of the message to create."]
    #[doc = "@param[in] clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{event_class} is also the stream class of"]
    #[doc = "\\bt_p{packet}, that is,"]
    #[doc = "<code>bt_event_class_borrow_stream_class_const(event_class)</code>"]
    #[doc = "and"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>"]
    #[doc = "have the same value."]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_borrow_default_clock_class_const(bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))</code>"]
    #[doc = "does \\em not return \\c NULL."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{event_class}"]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_event_create_with_packet_and_default_clock_snapshot(
        self_message_iterator: *mut bt_self_message_iterator,
        event_class: *const bt_event_class,
        packet: *const bt_packet,
        clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev of the \\bt_ev_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-ev-prop-ev \"event\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Event message from which to borrow the event."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the event of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_ev_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_event_borrow_event_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_event_borrow_event(message: *mut bt_message) -> *mut bt_event;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev of the \\bt_ev_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_event_borrow_event()."]
    pub fn bt_message_event_borrow_event_const(message: *const bt_message) -> *const bt_event;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_cs of the \\bt_ev_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-ev-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Event message from which to borrow the default clock snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_ev_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The \\bt_stream_cls of \\bt_p{message} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    pub fn bt_message_event_borrow_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_ev_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_event_borrow_stream_const("]
    #[doc = "bt_message_event_borrow_event_const(message))))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Event message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_ev_msg{message}"]
    pub fn bt_message_event_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_pb_msg for the \\bt_pkt \\bt_p{packet} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_packets_have_beginning_default_clock_snapshot("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_packet_beginning_create_with_default_clock_snapshot()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned packet beginning message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pb-prop-pkt \"Packet\""]
    #[doc = "<td>\\bt_p{packet}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pb-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the packet beginning"]
    #[doc = "message."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which the message to create indicates the beginning."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New packet beginning message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "bt_stream_class_packets_have_beginning_default_clock_snapshot()"]
    #[doc = "returns #BT_FALSE for"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{packet}"]
    pub fn bt_message_packet_beginning_create(
        self_message_iterator: *mut bt_self_message_iterator,
        packet: *const bt_packet,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_pb_msg having a default \\bt_cs with the value"]
    #[doc = "\\bt_p{clock_snapshot_value} for the \\bt_pkt \\bt_p{packet} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_packets_have_beginning_default_clock_snapshot("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_packet_beginning_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned packet beginning message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pb-prop-pkt \"Packet\""]
    #[doc = "<td>\\bt_p{packet}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pb-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{clock_snapshot_value}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the packet beginning"]
    #[doc = "message."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which the message to create indicates the beginning."]
    #[doc = "@param[in] clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New packet beginning message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "bt_stream_class_packets_have_beginning_default_clock_snapshot()"]
    #[doc = "returns #BT_TRUE for"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{packet}"]
    pub fn bt_message_packet_beginning_create_with_default_clock_snapshot(
        self_message_iterator: *mut bt_self_message_iterator,
        packet: *const bt_packet,
        clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt of the \\bt_pb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-pb-prop-pkt \"packet\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet beginning message from which to borrow the packet."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the packet of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pb_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_packet_beginning_borrow_packet_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_packet_beginning_borrow_packet(message: *mut bt_message) -> *mut bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt of the \\bt_pb_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_packet_beginning_borrow_packet()."]
    pub fn bt_message_packet_beginning_borrow_packet_const(
        message: *const bt_message,
    ) -> *const bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_cs of the \\bt_pb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-pb-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet beginning message from which to borrow the default clock"]
    #[doc = "snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pb_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The packets of the \\bt_stream_cls of \\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-beg-cs \"have a beginning default clock snapshot\"."]
    pub fn bt_message_packet_beginning_borrow_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_pb_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_packet_borrow_stream_const("]
    #[doc = "bt_message_packet_beginning_borrow_packet_const(message))))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet beginning message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pb_msg{message}"]
    pub fn bt_message_packet_beginning_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_pe_msg for the \\bt_pkt \\bt_p{packet} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_packets_have_end_default_clock_snapshot("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_packet_end_create_with_default_clock_snapshot()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned packet end message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pe-prop-pkt \"Packet\""]
    #[doc = "<td>\\bt_p{packet}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pe-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the packet end message."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which the message to create indicates the end."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New packet end message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "bt_stream_class_packets_have_end_default_clock_snapshot()"]
    #[doc = "returns #BT_FALSE for"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{packet}"]
    pub fn bt_message_packet_end_create(
        self_message_iterator: *mut bt_self_message_iterator,
        packet: *const bt_packet,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_pe_msg having a default \\bt_cs with the value"]
    #[doc = "\\bt_p{clock_snapshot_value} for the \\bt_pkt \\bt_p{packet} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_packets_have_end_default_clock_snapshot("]
    #[doc = "bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_packet_end_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned packet end message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pe-prop-pkt \"Packet\""]
    #[doc = "<td>\\bt_p{packet}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-pe-prop-cs \"Default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{clock_snapshot_value}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the packet end"]
    #[doc = "message."]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which the message to create indicates the end."]
    #[doc = "@param[in] clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New packet end message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = "@pre"]
    #[doc = "bt_stream_class_packets_have_end_default_clock_snapshot()"]
    #[doc = "returns #BT_TRUE for"]
    #[doc = "<code>bt_stream_borrow_class_const(bt_packet_borrow_stream_const(packet))</code>."]
    #[doc = "@pre"]
    #[doc = "The \\ref api-tir-pkt-prop-ctx \"context field\" of \\bt_p{packet}, if"]
    #[doc = "any, and all its contained \\bt_p_field, recursively, are set."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{packet}"]
    pub fn bt_message_packet_end_create_with_default_clock_snapshot(
        self_message_iterator: *mut bt_self_message_iterator,
        packet: *const bt_packet,
        clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt of the \\bt_pe_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-pe-prop-pkt \"packet\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet end message from which to borrow the packet."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the packet of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pe_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_packet_end_borrow_packet_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_packet_end_borrow_packet(message: *mut bt_message) -> *mut bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt of the \\bt_pe_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_packet_end_borrow_packet()."]
    pub fn bt_message_packet_end_borrow_packet_const(
        message: *const bt_message,
    ) -> *const bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_cs of the \\bt_pe_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-pe-prop-cs \"default clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet end message from which to borrow the default clock"]
    #[doc = "snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pe_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The packets of the \\bt_stream_cls of \\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-end-cs \"have an end default clock snapshot\"."]
    pub fn bt_message_packet_end_borrow_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_pe_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_packet_borrow_stream_const("]
    #[doc = "bt_message_packet_end_borrow_packet_const(message))))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Packet end message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_pe_msg{message}"]
    pub fn bt_message_packet_end_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_disc_ev_msg for the \\bt_stream \\bt_p{stream} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_discarded_events_have_default_clock_snapshots("]
    #[doc = "bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_discarded_events_create_with_default_clock_snapshots()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned discarded events message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-cs-beg \"Beginning default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-cs-end \"End default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-count \"Discarded event count\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the discarded events"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream from which the events were discarded."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New discarded events message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_discarded_events_have_default_clock_snapshots(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_discarded_events_create(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_disc_ev_msg having the beginning and end default"]
    #[doc = "\\bt_p_cs with the values \\bt_p{beginning_clock_snapshot_value} and"]
    #[doc = "\\bt_p{end_clock_snapshot_value} for the \\bt_stream \\bt_p{stream}"]
    #[doc = "from the \\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_discarded_events_have_default_clock_snapshots("]
    #[doc = "bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_discarded_events_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned discarded events message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-cs-beg \"Beginning default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{beginning_clock_snapshot_value}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-cs-end \"End default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{end_clock_snapshot_value}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-ev-prop-count \"Discarded event count\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the discarded events"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream from which the events were discarded."]
    #[doc = "@param[in] beginning_clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the beginning default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = "@param[in] end_clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the end default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New discarded events message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_discarded_events_have_default_clock_snapshots(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_discarded_events_create_with_default_clock_snapshots(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
        beginning_clock_snapshot_value: u64,
        end_clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_disc_ev_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-stream \"stream\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message from which to borrow the stream."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_events_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_discarded_events_borrow_stream(message: *mut bt_message) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_disc_ev_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_discarded_events_borrow_stream()."]
    pub fn bt_message_discarded_events_borrow_stream_const(
        message: *const bt_message,
    ) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the beginning default \\bt_cs of the \\bt_disc_ev_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-msg-disc-ev-prop-cs-beg \"beginning default clock snapshot\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message from which to borrow the beginning default"]
    #[doc = "clock snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Beginning default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The discarded packets messages of the \\bt_stream_cls of"]
    #[doc = "\\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-pkt-cs \"have default clock snapshots\"."]
    pub fn bt_message_discarded_events_borrow_beginning_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the end default \\bt_cs of the \\bt_disc_ev_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-msg-disc-ev-prop-cs-end \"end default clock snapshot\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message from which to borrow the end default clock"]
    #[doc = "snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "End default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The discarded packets messages of the \\bt_stream_cls of"]
    #[doc = "\\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-pkt-cs \"have default clock snapshots\"."]
    pub fn bt_message_discarded_events_borrow_end_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_disc_ev_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_message_discarded_events_borrow_stream_const(message)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    pub fn bt_message_discarded_events_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the number of discarded events of the \\bt_disc_ev_msg"]
    #[doc = "\\bt_p{message} to \\bt_p{count}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-count \"discarded event count\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message of which to set the number of discarded"]
    #[doc = "events to \\bt_p{count}."]
    #[doc = "@param[in] count"]
    #[doc = "New number of discarded events of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_hot{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_events_get_count() &mdash;"]
    #[doc = "Returns the number of discarded events of a discarded events"]
    #[doc = "message."]
    pub fn bt_message_discarded_events_set_count(message: *mut bt_message, count: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of discarded events of the \\bt_disc_ev_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-count \"discarded event count\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded events message of which to get the number of discarded"]
    #[doc = "events."]
    #[doc = "@param[out] count"]
    #[doc = "<strong>If this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*count} is"]
    #[doc = "the number of discarded events of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_AVAILABLE"]
    #[doc = "The number of discarded events of \\bt_p{message} is available."]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE"]
    #[doc = "The number of discarded events of \\bt_p{message} is not available."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_ev_msg{message}"]
    #[doc = "@bt_pre_not_null{count}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_events_set_count() &mdash;"]
    #[doc = "Sets the number of discarded events of a discarded events message."]
    pub fn bt_message_discarded_events_get_count(
        message: *const bt_message,
        count: *mut u64,
    ) -> bt_property_availability::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_disc_pkt_msg for the \\bt_stream \\bt_p{stream} from the"]
    #[doc = "\\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_discarded_packets_have_default_clock_snapshots("]
    #[doc = "bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_discarded_packets_create_with_default_clock_snapshots()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned discarded packets message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-cs-beg \"Beginning default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-cs-end \"End default clock snapshot\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-count \"Discarded packet count\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the discarded packets"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream from which the packets were discarded."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New discarded packets message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_discarded_packets_have_default_clock_snapshots(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_discarded_packets_create(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_disc_pkt_msg having the beginning and end default"]
    #[doc = "\\bt_p_cs with the values \\bt_p{beginning_clock_snapshot_value} and"]
    #[doc = "\\bt_p{end_clock_snapshot_value} for the \\bt_stream \\bt_p{stream}"]
    #[doc = "from the \\bt_msg_iter \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_discarded_packets_have_default_clock_snapshots("]
    #[doc = "bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use"]
    #[doc = "bt_message_discarded_packets_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned discarded packets message has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-stream \"Stream\""]
    #[doc = "<td>\\bt_p{stream}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-cs-beg \"Beginning default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{beginning_clock_snapshot_value}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-cs-end \"End default clock snapshot\""]
    #[doc = "<td>\\bt_c_cs with the value \\bt_p{end_clock_snapshot_value}."]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-disc-pkt-prop-count \"Discarded packet count\""]
    #[doc = "<td>\\em None"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the discarded packets"]
    #[doc = "message."]
    #[doc = "@param[in] stream"]
    #[doc = "Stream from which the packets were discarded."]
    #[doc = "@param[in] beginning_clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the beginning default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = "@param[in] end_clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the end default clock snapshot of"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New discarded packets message reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_discarded_packets_have_default_clock_snapshots(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream}"]
    pub fn bt_message_discarded_packets_create_with_default_clock_snapshots(
        self_message_iterator: *mut bt_self_message_iterator,
        stream: *const bt_stream,
        beginning_clock_snapshot_value: u64,
        end_clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_disc_pkt_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-stream \"stream\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message from which to borrow the stream."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{message} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_packets_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_message_discarded_packets_borrow_stream(message: *mut bt_message) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream of the \\bt_disc_pkt_msg \\bt_p{message}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_message_discarded_packets_borrow_stream()."]
    pub fn bt_message_discarded_packets_borrow_stream_const(
        message: *const bt_message,
    ) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the beginning default \\bt_cs of the \\bt_disc_pkt_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-msg-disc-pkt-prop-cs-beg \"beginning default clock snapshot\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message from which to borrow the beginning default"]
    #[doc = "clock snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Beginning default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The discarded packets messages of the \\bt_stream_cls of"]
    #[doc = "\\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-pkt-cs \"have default clock snapshots\"."]
    pub fn bt_message_discarded_packets_borrow_beginning_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the end default \\bt_cs of the \\bt_disc_pkt_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-msg-disc-pkt-prop-cs-end \"end default clock snapshot\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message from which to borrow the end default clock"]
    #[doc = "snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "End default clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    #[doc = "@pre"]
    #[doc = "The discarded packets messages of the \\bt_stream_cls of"]
    #[doc = "\\bt_p{message}"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-pkt-cs \"have default clock snapshots\"."]
    pub fn bt_message_discarded_packets_borrow_end_default_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls of the \\bt_stream_cls"]
    #[doc = "of the \\bt_disc_pkt_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the stream class's"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "This is a helper which is equivalent to"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_borrow_default_clock_class_const("]
    #[doc = "bt_stream_borrow_class_const("]
    #[doc = "bt_message_discarded_packets_borrow_stream_const(message)))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message from which to borrow its stream's class's"]
    #[doc = "default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "the stream class of \\bt_p{message}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    pub fn bt_message_discarded_packets_borrow_stream_class_default_clock_class_const(
        message: *const bt_message,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the number of discarded packets of the \\bt_disc_pkt_msg"]
    #[doc = "\\bt_p{message} to \\bt_p{count}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-count \"discarded packet count\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message of which to set the number of discarded"]
    #[doc = "packets to \\bt_p{count}."]
    #[doc = "@param[in] count"]
    #[doc = "New number of discarded packets of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_hot{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_packets_get_count() &mdash;"]
    #[doc = "Returns the number of discarded packets of a discarded packets"]
    #[doc = "message."]
    pub fn bt_message_discarded_packets_set_count(message: *mut bt_message, count: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of discarded packets of the \\bt_disc_pkt_msg"]
    #[doc = "\\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-disc-ev-prop-count \"discarded packet count\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Discarded packets message of which to get the number of discarded"]
    #[doc = "packets."]
    #[doc = "@param[out] count"]
    #[doc = "<strong>If this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*count} is"]
    #[doc = "the number of discarded packets of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_AVAILABLE"]
    #[doc = "The number of discarded packets of \\bt_p{message} is available."]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE"]
    #[doc = "The number of discarded packets of \\bt_p{message} is not available."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_disc_pkt_msg{message}"]
    #[doc = "@bt_pre_not_null{count}"]
    #[doc = ""]
    #[doc = "@sa bt_message_discarded_packets_set_count() &mdash;"]
    #[doc = "Sets the number of discarded packets of a discarded packets message."]
    pub fn bt_message_discarded_packets_get_count(
        message: *const bt_message,
        count: *mut u64,
    ) -> bt_property_availability::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_inac_msg having a \\bt_cs of a fictitious instance of"]
    #[doc = "the \\bt_clock_cls \\bt_p{clock_class} with the value"]
    #[doc = "\\bt_p{clock_snapshot_value} from the \\bt_msg_iter"]
    #[doc = "\\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "On success, the returned message iterator inactivity message has the"]
    #[doc = "following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-msg-inac-prop-cs \"Clock snapshot\""]
    #[doc = "<td>"]
    #[doc = "\\bt_c_cs (snapshot of a fictitious instance of \\bt_p{clock_class})"]
    #[doc = "with the value \\bt_p{clock_snapshot_value}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Self message iterator from which to create the message iterator"]
    #[doc = "inactivity message."]
    #[doc = "@param[in] clock_class"]
    #[doc = "Class of the fictitious instance of which"]
    #[doc = "\\bt_p{clock_snapshot_value} is the value of its snapshot."]
    #[doc = "@param[in] clock_snapshot_value"]
    #[doc = "Value (clock cycles) of the clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New message iterator inactivity message reference, or \\c NULL on"]
    #[doc = "memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{clock_class}"]
    pub fn bt_message_message_iterator_inactivity_create(
        self_message_iterator: *mut bt_self_message_iterator,
        clock_class: *const bt_clock_class,
        clock_snapshot_value: u64,
    ) -> *mut bt_message;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_cs of the \\bt_inac_msg \\bt_p{message}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-inac-prop-cs \"clock snapshot\" property."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "Message iterator inactivity message from which to borrow the clock"]
    #[doc = "snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Clock snapshot of \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message}"]
    #[doc = "@bt_pre_is_inac_msg{message}"]
    pub fn bt_message_message_iterator_inactivity_borrow_clock_snapshot_const(
        message: *const bt_message,
    ) -> *const bt_clock_snapshot;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "@parblock"]
    #[doc = "Message of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_message_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a message."]
    pub fn bt_message_get_ref(message: *const bt_message);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message \\bt_p{message}."]
    #[doc = ""]
    #[doc = "@param[in] message"]
    #[doc = "@parblock"]
    #[doc = "Message of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_message_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a message."]
    pub fn bt_message_put_ref(message: *const bt_message);
}
pub mod bt_get_greatest_operative_mip_version_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_get_greatest_operative_mip_version()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "No match found."]
    pub const BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_NO_MATCH: Type = 6;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Computes the greatest \\bt_mip version which"]
    #[doc = "you can use to create a trace processing \\bt_graph to which you"]
    #[doc = "intend to \\ref api-graph-lc-add \"add components\" described by the"]
    #[doc = "component descriptors \\bt_p{component_descriptors}, and sets"]
    #[doc = "\\bt_p{*mip_version} to the result."]
    #[doc = ""]
    #[doc = "This function calls the"]
    #[doc = "\\link api-comp-cls-dev-meth-mip \"get supported MIP versions\"\\endlink"]
    #[doc = "method for each component descriptor in \\bt_p{component_descriptors},"]
    #[doc = "and then returns the greatest common (operative) MIP version, if any."]
    #[doc = "The \"get supported MIP versions\" method receives \\bt_p{logging_level} as"]
    #[doc = "its \\bt_p{logging_level} parameter."]
    #[doc = ""]
    #[doc = "If this function does not find an operative MIP version for the"]
    #[doc = "component descriptors of \\bt_p{component_descriptors}, it returns"]
    #[doc = "#BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_NO_MATCH."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "As of \\bt_name_version_min_maj, because bt_get_maximal_mip_version()"]
    #[doc = "returns 0, this function always sets \\bt_p{*mip_version} to"]
    #[doc = "0 on success."]
    #[doc = ""]
    #[doc = "@param[in] component_descriptors"]
    #[doc = "Component descriptors for which to get the supported MIP versions"]
    #[doc = "to compute the greatest operative MIP version."]
    #[doc = "@param[in] logging_level"]
    #[doc = "Logging level to use when calling the \"get supported MIP versions\""]
    #[doc = "method for each component descriptor in"]
    #[doc = "\\bt_p{component_descriptors}."]
    #[doc = "@param[out] mip_version"]
    #[doc = "<strong>On success</strong>, \\bt_p{*mip_version} is the greatest"]
    #[doc = "operative MIP version of all the component descriptors in"]
    #[doc = "\\bt_p{component_descriptors}."]
    #[doc = ""]
    #[doc = "@retval #BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_NO_MATCH"]
    #[doc = "No operative MIP version exists for the component descriptors of"]
    #[doc = "\\bt_p{component_descriptors}."]
    #[doc = "@retval #BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_descriptors}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{component_descriptors} contains one or more component"]
    #[doc = "descriptors."]
    #[doc = "@bt_pre_not_null{mip_version}"]
    pub fn bt_get_greatest_operative_mip_version(
        component_descriptors: *const bt_component_descriptor_set,
        logging_level: bt_logging_level::Type,
        mip_version: *mut u64,
    ) -> bt_get_greatest_operative_mip_version_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the maximal available \\bt_mip version as of"]
    #[doc = "\\bt_name_version_min_maj."]
    #[doc = ""]
    #[doc = "As of \\bt_name_version_min_maj, this function returns"]
    #[doc = "\\bt_max_mip_version."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Maximal available MIP version (\\bt_max_mip_version)."]
    pub fn bt_get_maximal_mip_version() -> u64;
}
pub mod bt_port_type {
    #[doc = "@brief"]
    #[doc = "Port type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "\\bt_c_iport."]
    pub const BT_PORT_TYPE_INPUT: Type = 1;
    #[doc = "@brief"]
    #[doc = "\\bt_c_oport."]
    pub const BT_PORT_TYPE_OUTPUT: Type = 2;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the port \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "Port of which to get the type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{port}"]
    #[doc = ""]
    #[doc = "@sa bt_port_is_input() &mdash;"]
    #[doc = "Returns whether or not a port is an \\bt_iport."]
    #[doc = "@sa bt_port_is_output() &mdash;"]
    #[doc = "Returns whether or not a port is an \\bt_oport."]
    pub fn bt_port_get_type(port: *const bt_port) -> bt_port_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_conn of the port \\bt_p{port}."]
    #[doc = ""]
    #[doc = "This function returns \\c NULL if \\bt_p{port} is unconnected"]
    #[doc = "(bt_port_is_connected() returns #BT_FALSE)."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "Port of which to borrow the connection."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the connection of \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{port}"]
    pub fn bt_port_borrow_connection_const(port: *const bt_port) -> *const bt_connection;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_comp to which the port \\bt_p{port} belongs."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "Port of which to borrow the component which owns it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the component which owns \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{port}"]
    pub fn bt_port_borrow_component_const(port: *const bt_port) -> *const bt_component;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the port \\bt_p{port}."]
    #[doc = ""]
    #[doc = "See the \\ref api-port-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "Port of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{port}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{port} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{port}"]
    pub fn bt_port_get_name(port: *const bt_port) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the port \\bt_p{port} is connected."]
    #[doc = ""]
    #[doc = "See the \\ref api-port-prop-is-connected \"is connected?\" property."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "Port of which to get whether or not it's connected."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{port} is connected."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{port}"]
    pub fn bt_port_is_connected(port: *const bt_port) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the port \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Port of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a port."]
    pub fn bt_port_get_ref(port: *const bt_port);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the port \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Port of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a port."]
    pub fn bt_port_put_ref(port: *const bt_port);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_iport \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Input port of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_input_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of an input port."]
    pub fn bt_port_input_get_ref(port: *const bt_port_input);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_iport \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Input port of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_input_get_ref() &mdash;"]
    #[doc = "Increments the reference count of an input port."]
    pub fn bt_port_input_put_ref(port: *const bt_port_input);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_oport \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Output port of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_output_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a \\bt_oport."]
    pub fn bt_port_output_get_ref(port: *const bt_port_output);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the \\bt_oport \\bt_p{port}."]
    #[doc = ""]
    #[doc = "@param[in] port"]
    #[doc = "@parblock"]
    #[doc = "Output port of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_port_output_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a \\bt_oport."]
    pub fn bt_port_output_put_ref(port: *const bt_port_output);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Alias of bt_query_executor_create_with_method_data()"]
    #[doc = "with the \\bt_p{method_data} parameter set to \\c NULL."]
    pub fn bt_query_executor_create(
        component_class: *const bt_component_class,
        object_name: *const ::std::os::raw::c_char,
        params: *const bt_value,
    ) -> *mut bt_query_executor;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a query executor to query the object named"]
    #[doc = "\\bt_p{object_name} from the \\bt_comp_cls \\bt_p{component_class} with"]
    #[doc = "the parameters \\bt_p{params} and the query user data"]
    #[doc = "\\bt_p{method_data}."]
    #[doc = ""]
    #[doc = "When you call bt_query_executor_query() with the returned query"]
    #[doc = "executor, the query method of \\bt_p{component_class} receives:"]
    #[doc = ""]
    #[doc = "- \\bt_p{object_name} as its own \\bt_p{object_name} parameter."]
    #[doc = ""]
    #[doc = "- \\bt_p{params} as its own \\bt_p{params} parameter"]
    #[doc = "(or #bt_value_null if \\bt_p{params} is \\c NULL)."]
    #[doc = ""]
    #[doc = "- \\bt_p{method_data} as its own \\bt_p{method_data} parameter."]
    #[doc = ""]
    #[doc = "@param[in] component_class"]
    #[doc = "Component class from which to query the object named"]
    #[doc = "\\bt_p{object_name}."]
    #[doc = "@param[in] object_name"]
    #[doc = "Name of the object to query from \\bt_p{component_class}."]
    #[doc = "@param[in] params"]
    #[doc = "@parblock"]
    #[doc = "Parameters for the query operation performed by the query executor"]
    #[doc = "to create."]
    #[doc = ""]
    #[doc = "Unlike the \\bt_p{params} parameter of"]
    #[doc = "the <code>bt_graph_add_*_component_*_port_added_listener()</code>"]
    #[doc = "functions (see \\ref api-graph), this parameter does not need to"]
    #[doc = "be a \\bt_map_val."]
    #[doc = ""]
    #[doc = "Can be \\c NULL (equivalent to passing #bt_value_null)."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] method_data"]
    #[doc = "User data passed as is to the query method of \\bt_p{component_class}"]
    #[doc = "when you call bt_query_executor_query()."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New query executor reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{component_class}"]
    #[doc = "@bt_pre_not_null{object}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{component_class}"]
    #[doc = "@bt_post_success_frozen{params}"]
    pub fn bt_query_executor_create_with_method_data(
        component_class: *const bt_component_class,
        object_name: *const ::std::os::raw::c_char,
        params: *const bt_value,
        method_data: *mut ::std::os::raw::c_void,
    ) -> *mut bt_query_executor;
}
pub mod bt_query_executor_query_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_query_executor_query()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_QUERY_EXECUTOR_QUERY_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Unknown object to query."]
    pub const BT_QUERY_EXECUTOR_QUERY_STATUS_UNKNOWN_OBJECT: Type = 42;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_QUERY_EXECUTOR_QUERY_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_QUERY_EXECUTOR_QUERY_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_QUERY_EXECUTOR_QUERY_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Performs a query operation using the query executor"]
    #[doc = "\\bt_p{query_executor}, setting \\bt_p{*result} to the operation's"]
    #[doc = "result on success."]
    #[doc = ""]
    #[doc = "This function calls the query executor's target \\bt_comp_cls's"]
    #[doc = "query method, passing:"]
    #[doc = ""]
    #[doc = "- The object name of \\bt_p{query_executor} as the"]
    #[doc = "\\bt_p{object_name} parameter."]
    #[doc = ""]
    #[doc = "- The query parameters of \\bt_p{query_executor} as the"]
    #[doc = "\\bt_p{params} parameter."]
    #[doc = ""]
    #[doc = "- The query user data of \\bt_p{query_executor} as the \\bt_p{method_data}"]
    #[doc = "parameter."]
    #[doc = ""]
    #[doc = "The three items above were set when you created \\bt_p{query_executor}"]
    #[doc = "with bt_query_executor_create() or"]
    #[doc = "bt_query_executor_create_with_method_data()."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor to use to execute the query operation."]
    #[doc = "@param[out] result"]
    #[doc = "<strong>On success</strong>, \\bt_p{*result} is a \\em strong"]
    #[doc = "reference of the query operation's result."]
    #[doc = ""]
    #[doc = "@retval #BT_QUERY_EXECUTOR_QUERY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_QUERY_EXECUTOR_QUERY_STATUS_UNKNOWN_OBJECT"]
    #[doc = "Unknown object to query."]
    #[doc = "@retval #BT_QUERY_EXECUTOR_QUERY_STATUS_AGAIN"]
    #[doc = "Try again."]
    #[doc = "@retval #BT_QUERY_EXECUTOR_QUERY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_QUERY_EXECUTOR_QUERY_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    #[doc = "@bt_pre_not_null{result}"]
    pub fn bt_query_executor_query(
        query_executor: *mut bt_query_executor,
        result: *mut *const bt_value,
    ) -> bt_query_executor_query_status::Type;
}
pub mod bt_query_executor_set_logging_level_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_query_executor_set_logging_level()."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_QUERY_EXECUTOR_SET_LOGGING_LEVEL_STATUS_OK: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the logging level of the query executor \\bt_p{query_executor}"]
    #[doc = "to \\bt_p{logging_level}."]
    #[doc = ""]
    #[doc = "See the \\ref api-qexec-prop-log-lvl \"logging level\" property."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor of which to set the logging level to"]
    #[doc = "\\bt_p{logging_level}."]
    #[doc = "@param[in] logging_level"]
    #[doc = "New logging level of \\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@retval #BT_QUERY_EXECUTOR_SET_LOGGING_LEVEL_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_get_logging_level() &mdash;"]
    #[doc = "Returns the logging level of a query executor."]
    pub fn bt_query_executor_set_logging_level(
        query_executor: *mut bt_query_executor,
        logging_level: bt_logging_level::Type,
    ) -> bt_query_executor_set_logging_level_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the logging level of the query executor"]
    #[doc = "\\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "See the \\ref api-qexec-prop-log-lvl \"logging level\" property."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor of which to get the logging level."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Logging level of \\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    #[doc = ""]
    #[doc = "@sa bt_query_executor_set_logging_level() &mdash;"]
    #[doc = "Sets the logging level of a query executor."]
    pub fn bt_query_executor_get_logging_level(
        query_executor: *const bt_query_executor,
    ) -> bt_logging_level::Type;
}
pub mod bt_query_executor_add_interrupter_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_query_executor_add_interrupter()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds the \\bt_intr \\bt_p{interrupter} to the query executor"]
    #[doc = "\\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "A \\bt_comp_cls query method can check whether or not its executor is"]
    #[doc = "interrupted (any of its interrupters, including its default interrupter,"]
    #[doc = "is set) with bt_query_executor_is_interrupted()."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "@parblock"]
    #[doc = "bt_query_executor_create() and"]
    #[doc = "bt_query_executor_create_with_method_data() return a query executor"]
    #[doc = "which comes with its own <em>default interrupter</em>."]
    #[doc = ""]
    #[doc = "Instead of adding your own interrupter to \\bt_p{query_executor}, you"]
    #[doc = "can set its default interrupter with"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_interrupter_set(bt_query_executor_borrow_default_interrupter());"]
    #[doc = "@endcode"]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor to which to add \\bt_p{interrupter}."]
    #[doc = "@param[in] interrupter"]
    #[doc = "Interrupter to add to \\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@retval #BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    #[doc = "@bt_pre_not_null{interrupter}"]
    #[doc = ""]
    #[doc = "@sa bt_query_executor_borrow_default_interrupter() &mdash;"]
    #[doc = "Borrows the default interrupter from a query executor."]
    pub fn bt_query_executor_add_interrupter(
        query_executor: *mut bt_query_executor,
        interrupter: *const bt_interrupter,
    ) -> bt_query_executor_add_interrupter_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_intr from the query executor"]
    #[doc = "\\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor from which to borrow the default interrupter."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the default interrupter of"]
    #[doc = "\\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{query_executor}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    #[doc = ""]
    #[doc = "@sa bt_query_executor_add_interrupter() &mdash;"]
    #[doc = "Adds an interrupter to a query executor."]
    pub fn bt_query_executor_borrow_default_interrupter(
        query_executor: *mut bt_query_executor,
    ) -> *mut bt_interrupter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the query executor \\bt_p{query_executor}"]
    #[doc = "is interrupted, that is, whether or not any of its \\bt_p_intr,"]
    #[doc = "including its default interrupter, is set."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "Query executor to check."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{query_executor} is interrupted (any of its"]
    #[doc = "interrupters is set)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{query_executor}"]
    pub fn bt_query_executor_is_interrupted(query_executor: *const bt_query_executor) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the query executor \\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "@parblock"]
    #[doc = "Query executor of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_query_executor_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a query executor."]
    pub fn bt_query_executor_get_ref(query_executor: *const bt_query_executor);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the query executor \\bt_p{query_executor}."]
    #[doc = ""]
    #[doc = "@param[in] query_executor"]
    #[doc = "@parblock"]
    #[doc = "Query executor of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_query_executor_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a query executor."]
    pub fn bt_query_executor_put_ref(query_executor: *const bt_query_executor);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_comp of the \\bt_port \\bt_p{self_component_port}."]
    #[doc = ""]
    #[doc = "@param[in] self_component_port"]
    #[doc = "Port from which to borrow the component which owns it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component which owns \\bt_p{self_component_port}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component_port}"]
    pub fn bt_self_component_port_borrow_component(
        self_component_port: *mut bt_self_component_port,
    ) -> *mut bt_self_component;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the user data of the \\bt_port \\bt_p{self_component_port}."]
    #[doc = ""]
    #[doc = "You can attach user data to a port when you add it to a component with"]
    #[doc = "bt_self_component_source_add_output_port(),"]
    #[doc = "bt_self_component_filter_add_input_port(),"]
    #[doc = "bt_self_component_filter_add_output_port(), and"]
    #[doc = "bt_self_component_sink_add_input_port()."]
    #[doc = ""]
    #[doc = "@param[in] self_component_port"]
    #[doc = "Port of which to get the user data."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User data of \\bt_p{self_component_port}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component_port}"]
    pub fn bt_self_component_port_get_data(
        self_component_port: *const bt_self_component_port,
    ) -> *mut ::std::os::raw::c_void;
}
pub mod bt_self_component_add_port_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_self_component_source_add_output_port(),"]
    #[doc = "bt_self_component_filter_add_input_port(),"]
    #[doc = "bt_self_component_filter_add_output_port(), and"]
    #[doc = "bt_self_component_sink_add_input_port()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_SELF_COMPONENT_ADD_PORT_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds an \\bt_oport named \\bt_p{name} and having the user data"]
    #[doc = "\\bt_p{user_data} to the \\bt_src_comp \\bt_p{self_component},"]
    #[doc = "and sets \\bt_p{*self_component_port} to the resulting port."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You can only call this function from within the"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization\","]
    #[doc = "\\link api-comp-cls-dev-meth-iport-connected \"input port connected\"\\endlink,"]
    #[doc = "and"]
    #[doc = "\\link api-comp-cls-dev-meth-oport-connected \"output port connected\"\\endlink"]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Source component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to add to \\bt_p{self_component} (copied)."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data of the output port to add to \\bt_p{self_component}."]
    #[doc = "@param[out] self_component_port"]
    #[doc = "<strong>On success, if not \\c NULL</strong>,"]
    #[doc = "\\bt_p{*self_component_port} is a \\em borrowed reference of the"]
    #[doc = "created port."]
    #[doc = ""]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other output port within \\bt_p{self_component} has the name"]
    #[doc = "\\bt_p{name}."]
    pub fn bt_self_component_source_add_output_port(
        self_component: *mut bt_self_component_source,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        self_component_port: *mut *mut bt_self_component_port_output,
    ) -> bt_self_component_add_port_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds an \\bt_iport named \\bt_p{name} and having the user data"]
    #[doc = "\\bt_p{user_data} to the \\bt_flt_comp \\bt_p{self_component},"]
    #[doc = "and sets \\bt_p{*self_component_port} to the resulting port."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You can only call this function from within the"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization\","]
    #[doc = "\\link api-comp-cls-dev-meth-iport-connected \"input port connected\"\\endlink,"]
    #[doc = "and"]
    #[doc = "\\link api-comp-cls-dev-meth-oport-connected \"output port connected\"\\endlink"]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the input port to add to \\bt_p{self_component} (copied)."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data of the input port to add to \\bt_p{self_component}."]
    #[doc = "@param[out] self_component_port"]
    #[doc = "<strong>On success, if not \\c NULL</strong>,"]
    #[doc = "\\bt_p{*self_component_port} is a \\em borrowed reference of the"]
    #[doc = "created port."]
    #[doc = ""]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other input port within \\bt_p{self_component} has the name"]
    #[doc = "\\bt_p{name}."]
    pub fn bt_self_component_filter_add_input_port(
        self_component: *mut bt_self_component_filter,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        self_component_port: *mut *mut bt_self_component_port_input,
    ) -> bt_self_component_add_port_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds an \\bt_oport named \\bt_p{name} and having the user data"]
    #[doc = "\\bt_p{user_data} to the \\bt_flt_comp \\bt_p{self_component},"]
    #[doc = "and sets \\bt_p{*self_component_port} to the resulting port."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You can only call this function from within the"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization\","]
    #[doc = "\\link api-comp-cls-dev-meth-iport-connected \"input port connected\"\\endlink,"]
    #[doc = "and"]
    #[doc = "\\link api-comp-cls-dev-meth-oport-connected \"output port connected\"\\endlink"]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to add to \\bt_p{self_component} (copied)."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data of the output port to add to \\bt_p{self_component}."]
    #[doc = "@param[out] self_component_port"]
    #[doc = "<strong>On success, if not \\c NULL</strong>,"]
    #[doc = "\\bt_p{*self_component_port} is a \\em borrowed reference of the"]
    #[doc = "created port."]
    #[doc = ""]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other output port within \\bt_p{self_component} has the name"]
    #[doc = "\\bt_p{name}."]
    pub fn bt_self_component_filter_add_output_port(
        self_component: *mut bt_self_component_filter,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        self_component_port: *mut *mut bt_self_component_port_output,
    ) -> bt_self_component_add_port_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds an \\bt_iport named \\bt_p{name} and having the user data"]
    #[doc = "\\bt_p{user_data} to the \\bt_sink_comp \\bt_p{self_component},"]
    #[doc = "and sets \\bt_p{*self_component_port} to the resulting port."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You can only call this function from within the"]
    #[doc = "\\ref api-comp-cls-dev-meth-init \"initialization\","]
    #[doc = "\\link api-comp-cls-dev-meth-iport-connected \"input port connected\"\\endlink,"]
    #[doc = "and"]
    #[doc = "\\link api-comp-cls-dev-meth-oport-connected \"output port connected\"\\endlink"]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Sink component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the input port to add to \\bt_p{self_component} (copied)."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data of the input port to add to \\bt_p{self_component}."]
    #[doc = "@param[out] self_component_port"]
    #[doc = "<strong>On success, if not \\c NULL</strong>,"]
    #[doc = "\\bt_p{*self_component_port} is a \\em borrowed reference of the"]
    #[doc = "created port."]
    #[doc = ""]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR"]
    #[doc = "Other error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@pre"]
    #[doc = "No other input port within \\bt_p{self_component} has the name"]
    #[doc = "\\bt_p{name}."]
    pub fn bt_self_component_sink_add_input_port(
        self_component: *mut bt_self_component_sink,
        name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        self_component_port: *mut *mut bt_self_component_port_input,
    ) -> bt_self_component_add_port_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_oport at index \\bt_p{index} from the"]
    #[doc = "\\bt_src_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Source component instance."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the output port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{self_component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of output ports"]
    #[doc = "\\bt_p{self_component} has (as returned by"]
    #[doc = "bt_component_source_get_output_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_source_get_output_port_count() &mdash;"]
    #[doc = "Returns the number of output ports that a source component has."]
    pub fn bt_self_component_source_borrow_output_port_by_index(
        self_component: *mut bt_self_component_source,
        index: u64,
    ) -> *mut bt_self_component_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_iport at index \\bt_p{index} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the input port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{self_component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of input ports"]
    #[doc = "\\bt_p{self_component} has (as returned by"]
    #[doc = "bt_component_filter_get_input_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_get_input_port_count() &mdash;"]
    #[doc = "Returns the number of input ports that a filter component has."]
    pub fn bt_self_component_filter_borrow_input_port_by_index(
        self_component: *mut bt_self_component_filter,
        index: u64,
    ) -> *mut bt_self_component_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_oport at index \\bt_p{index} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the output port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{self_component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of output ports"]
    #[doc = "\\bt_p{self_component} has (as returned by"]
    #[doc = "bt_component_filter_get_output_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_filter_get_output_port_count() &mdash;"]
    #[doc = "Returns the number of output ports that a filter component has."]
    pub fn bt_self_component_filter_borrow_output_port_by_index(
        self_component: *mut bt_self_component_filter,
        index: u64,
    ) -> *mut bt_self_component_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_iport at index \\bt_p{index} from the"]
    #[doc = "\\bt_sink_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Sink component instance."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the input port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{self_component} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of input ports"]
    #[doc = "\\bt_p{self_component} has (as returned by"]
    #[doc = "bt_component_sink_get_input_port_count())."]
    #[doc = ""]
    #[doc = "@sa bt_component_sink_get_input_port_count() &mdash;"]
    #[doc = "Returns the number of input ports that a sink component has."]
    pub fn bt_self_component_sink_borrow_input_port_by_index(
        self_component: *mut bt_self_component_sink,
        index: u64,
    ) -> *mut bt_self_component_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_oport named \\bt_p{name} from the"]
    #[doc = "\\bt_src_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{self_component} has no output port named \\bt_p{name}, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Source component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{self_component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_self_component_source_borrow_output_port_by_name(
        self_component: *mut bt_self_component_source,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_self_component_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_iport named \\bt_p{name} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{self_component} has no input port named \\bt_p{name}, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the input port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{self_component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_self_component_filter_borrow_input_port_by_name(
        self_component: *mut bt_self_component_filter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_self_component_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_oport named \\bt_p{name} from the"]
    #[doc = "\\bt_flt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{self_component} has no output port named \\bt_p{name}, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Filter component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the output port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the output port of"]
    #[doc = "\\bt_p{self_component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_self_component_filter_borrow_output_port_by_name(
        self_component: *mut bt_self_component_filter,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_self_component_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_self_comp_iport named \\bt_p{name} from the"]
    #[doc = "\\bt_sink_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "If \\bt_p{self_component} has no input port named \\bt_p{name}, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Sink component instance."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the input port to borrow from \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the input port of"]
    #[doc = "\\bt_p{self_component} named \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{self_component}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_self_component_sink_borrow_input_port_by_name(
        self_component: *mut bt_self_component_sink,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_self_component_port_input;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user data of the \\bt_comp \\bt_p{self_component} to"]
    #[doc = "\\bt_p{data}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Component instance."]
    #[doc = "@param[in] user_data"]
    #[doc = "New user data of \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = ""]
    #[doc = "@sa bt_self_component_get_data() &mdash;"]
    #[doc = "Returns the user data of a component."]
    pub fn bt_self_component_set_data(
        self_component: *mut bt_self_component,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the user data of the \\bt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Component instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User data of \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = ""]
    #[doc = "@sa bt_self_component_set_data() &mdash;"]
    #[doc = "Sets the user data of a component."]
    pub fn bt_self_component_get_data(
        self_component: *const bt_self_component,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the effective \\bt_mip (MIP) version of the trace processing"]
    #[doc = "\\bt_graph which contains the \\bt_comp \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "As of \\bt_name_version_min_maj, because bt_get_maximal_mip_version()"]
    #[doc = "returns 0, this function always returns 0."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Component instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Effective MIP version of the trace processing graph which"]
    #[doc = "contains \\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    pub fn bt_self_component_get_graph_mip_version(self_component: *mut bt_self_component) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_sink_comp \\bt_p{self_component}"]
    #[doc = "is interrupted, that is, whether or not any of its \\bt_p_intr"]
    #[doc = "is set."]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Component instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{self_component} is interrupted (any of its"]
    #[doc = "interrupters is set)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    #[doc = ""]
    #[doc = "@sa bt_graph_borrow_default_interrupter() &mdash;"]
    #[doc = "Borrows a trace processing graph's default interrupter."]
    #[doc = "@sa bt_graph_add_interrupter() &mdash;"]
    #[doc = "Adds an interrupter to a graph."]
    pub fn bt_self_component_sink_is_interrupted(
        self_component: *const bt_self_component_sink,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_comp which provides the \\bt_msg_iter"]
    #[doc = "\\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Message iterator instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Component which provides \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    pub fn bt_self_message_iterator_borrow_component(
        self_message_iterator: *mut bt_self_message_iterator,
    ) -> *mut bt_self_component;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_oport on which the \\bt_msg_iter"]
    #[doc = "\\bt_p{self_message_iterator} operates."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Message iterator instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Output port on which \\bt_p{self_message_iterator} operates."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    pub fn bt_self_message_iterator_borrow_port(
        self_message_iterator: *mut bt_self_message_iterator,
    ) -> *mut bt_self_component_port_output;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user data of the \\bt_msg_iter \\bt_p{self_message_iterator}"]
    #[doc = "to \\bt_p{data}."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Message iterator instance."]
    #[doc = "@param[in] user_data"]
    #[doc = "New user data of \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = ""]
    #[doc = "@sa bt_self_message_iterator_get_data() &mdash;"]
    #[doc = "Returns the user data of a message iterator."]
    pub fn bt_self_message_iterator_set_data(
        self_message_iterator: *mut bt_self_message_iterator,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the user data of the \\bt_msg_iter"]
    #[doc = "\\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Message iterator instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User data of \\bt_p{self_message_iterator}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = ""]
    #[doc = "@sa bt_self_message_iterator_set_data() &mdash;"]
    #[doc = "Sets the user data of a message iterator."]
    pub fn bt_self_message_iterator_get_data(
        self_message_iterator: *const bt_self_message_iterator,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_msg_iter \\bt_p{self_message_iterator}"]
    #[doc = "is interrupted, that is, whether or not any of its \\bt_p_intr"]
    #[doc = "is set."]
    #[doc = ""]
    #[doc = "@param[in] self_message_iterator"]
    #[doc = "Message iterator instance."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{self_message_iterator} is interrupted (any of its"]
    #[doc = "interrupters is set)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_message_iterator}"]
    #[doc = ""]
    #[doc = "@sa bt_graph_borrow_default_interrupter() &mdash;"]
    #[doc = "Borrows a trace processing graph's default interrupter."]
    #[doc = "@sa bt_graph_add_interrupter() &mdash;"]
    #[doc = "Adds an interrupter to a graph."]
    pub fn bt_self_message_iterator_is_interrupted(
        self_message_iterator: *const bt_self_message_iterator,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the \\bt_msg_iter of which the configuration"]
    #[doc = "is \\bt_p{configuration} can seek forward."]
    #[doc = ""]
    #[doc = "A message iterator can seek forward if all the \\bt_p_msg of its"]
    #[doc = "message sequence have some \\bt_cs."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You can only call this function during the execution of a"]
    #[doc = "message iterator's"]
    #[doc = "\\ref api-msg-iter-cls-meth-init \"initialization method\"."]
    #[doc = ""]
    #[doc = "@param[in] configuration"]
    #[doc = "Configuration of the message iterator of which to set whether or"]
    #[doc = "not it can seek forward."]
    #[doc = "@param[in] can_seek_forward"]
    #[doc = "#BT_TRUE to make the message iterator of which the configuration is"]
    #[doc = "\\bt_p{configuration} forward-seekable."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{configuration}"]
    #[doc = ""]
    #[doc = "@sa bt_message_iterator_can_seek_forward() &mdash;"]
    #[doc = "Returns whether or not a message iterator can seek forward."]
    pub fn bt_self_message_iterator_configuration_set_can_seek_forward(
        configuration: *mut bt_self_message_iterator_configuration,
        can_seek_forward: bt_bool,
    );
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the lower value of the unsigned integer range"]
    #[doc = "\\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "The returned lower value is included in \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@param[in] int_range"]
    #[doc = "Unsigned integer range of which to get the lower value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Lower value of \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range}"]
    #[doc = "@bt_pre_is_bool_val{int_range}"]
    pub fn bt_integer_range_unsigned_get_lower(int_range: *const bt_integer_range_unsigned) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the upper value of the unsigned integer range"]
    #[doc = "\\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "The returned upper value is included in \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@param[in] int_range"]
    #[doc = "Unsigned integer range of which to get the upper value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Upper value of \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range}"]
    #[doc = "@bt_pre_is_bool_val{int_range}"]
    pub fn bt_integer_range_unsigned_get_upper(int_range: *const bt_integer_range_unsigned) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the unsigned integer range"]
    #[doc = "\\bt_p{a_int_range} is equal to \\bt_p{b_int_range}."]
    #[doc = ""]
    #[doc = "Two unsigned integer ranges are considered equal if they have the same"]
    #[doc = "lower and upper values."]
    #[doc = ""]
    #[doc = "@param[in] a_int_range"]
    #[doc = "Unsigned integer range A."]
    #[doc = "@param[in] b_int_range"]
    #[doc = "Unsigned integer range B."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{a_int_range} is equal to"]
    #[doc = "\\bt_p{b_int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{a_int_range}"]
    #[doc = "@bt_pre_not_null{b_int_range}"]
    pub fn bt_integer_range_unsigned_is_equal(
        a_int_range: *const bt_integer_range_unsigned,
        b_int_range: *const bt_integer_range_unsigned,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the lower value of the signed integer range"]
    #[doc = "\\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "The returned lower value is included in \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@param[in] int_range"]
    #[doc = "Signed integer range of which to get the lower value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Lower value of \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range}"]
    #[doc = "@bt_pre_is_bool_val{int_range}"]
    pub fn bt_integer_range_signed_get_lower(int_range: *const bt_integer_range_signed) -> i64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the upper value of the signed integer range"]
    #[doc = "\\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "The returned upper value is included in \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@param[in] int_range"]
    #[doc = "Signed integer range of which to get the upper value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Upper value of \\bt_p{int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range}"]
    #[doc = "@bt_pre_is_bool_val{int_range}"]
    pub fn bt_integer_range_signed_get_upper(int_range: *const bt_integer_range_signed) -> i64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the signed integer range"]
    #[doc = "\\bt_p{a_int_range} is equal to \\bt_p{b_int_range}."]
    #[doc = ""]
    #[doc = "Two signed integer ranges are considered equal if they have the same"]
    #[doc = "lower and upper values."]
    #[doc = ""]
    #[doc = "@param[in] a_int_range"]
    #[doc = "Signed integer range A."]
    #[doc = "@param[in] b_int_range"]
    #[doc = "Signed integer range B."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{a_int_range} is equal to"]
    #[doc = "\\bt_p{b_int_range}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{a_int_range}"]
    #[doc = "@bt_pre_not_null{b_int_range}"]
    pub fn bt_integer_range_signed_is_equal(
        a_int_range: *const bt_integer_range_signed,
        b_int_range: *const bt_integer_range_signed,
    ) -> bt_bool;
}
pub mod bt_integer_range_set_add_range_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_integer_range_set_unsigned_add_range() and"]
    #[doc = "bt_integer_range_set_signed_add_range()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of integer ranges contained in the integer"]
    #[doc = "range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "The parameter \\bt_p{int_range_set} has the abstract type"]
    #[doc = "#bt_integer_range_set: use"]
    #[doc = "bt_integer_range_set_unsigned_as_range_set_const() or"]
    #[doc = "bt_integer_range_set_signed_as_range_set_const() to upcast a"]
    #[doc = "specific integer range set to this type."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "Integer range set of which to get the number of contained integer"]
    #[doc = "ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained integer ranges in \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set}"]
    pub fn bt_integer_range_set_get_range_count(int_range_set: *const bt_integer_range_set) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an empty set of unsigned 64-bit integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New unsigned integer range set, or \\c NULL on memory error."]
    pub fn bt_integer_range_set_unsigned_create() -> *mut bt_integer_range_set_unsigned;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds an unsigned 64-bit integer range having the lower value"]
    #[doc = "\\bt_p{lower} and the upper value \\bt_p{upper} to the unsigned"]
    #[doc = "integer range set"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "The values \\bt_p{lower} and \\bt_p{upper} are included in the unsigned"]
    #[doc = "integer range to add to \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "Unsigned integer range set to which to add an unsigned integer"]
    #[doc = "range."]
    #[doc = "@param[in] lower"]
    #[doc = "Lower value (included) of the unsigned integer range to add to"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = "@param[in] upper"]
    #[doc = "Upper value (included) of the unsigned integer range to add to"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@retval #BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set}"]
    #[doc = "@bt_pre_hot{int_range_set}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{lower}  \\bt_p{upper}."]
    pub fn bt_integer_range_set_unsigned_add_range(
        int_range_set: *mut bt_integer_range_set_unsigned,
        lower: u64,
        upper: u64,
    ) -> bt_integer_range_set_add_range_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the unsigned integer range at index \\bt_p{index} from the"]
    #[doc = "unsigned integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "Unsigned integer range set from which to borrow the unsigned integer"]
    #[doc = "range at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the unsigned integer range to borrow from"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the unsigned integer range of"]
    #[doc = "\\bt_p{int_range_set} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{int_range_set} is"]
    #[doc = "modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of unsigned integer ranges in"]
    #[doc = "\\bt_p{int_range_set} (as returned by"]
    #[doc = "bt_integer_range_set_get_range_count())."]
    pub fn bt_integer_range_set_unsigned_borrow_range_by_index_const(
        int_range_set: *const bt_integer_range_set_unsigned,
        index: u64,
    ) -> *const bt_integer_range_unsigned;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the unsigned integer range set"]
    #[doc = "\\bt_p{int_range_set_a} is equal to \\bt_p{int_range_set_b}."]
    #[doc = ""]
    #[doc = "Two unsigned integer range sets are considered equal if they contain the"]
    #[doc = "exact same unsigned integer ranges, whatever the order. In other words,"]
    #[doc = "an unsigned integer range set containing [2,&nbsp;9] and [10,&nbsp;15]"]
    #[doc = "is \\em not equal to an unsigned integer range containing [2,&nbsp;15]."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set_a"]
    #[doc = "Unsigned integer range set A."]
    #[doc = "@param[in] int_range_set_b"]
    #[doc = "Unsigned integer range set B."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{int_range_set_a} is equal to"]
    #[doc = "\\bt_p{int_range_set_b}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set_a}"]
    #[doc = "@bt_pre_not_null{int_range_set_b}"]
    pub fn bt_integer_range_set_unsigned_is_equal(
        int_range_set_a: *const bt_integer_range_set_unsigned,
        int_range_set_b: *const bt_integer_range_set_unsigned,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the unsigned integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "@parblock"]
    #[doc = "Unsigned integer range set of which to increment the reference"]
    #[doc = "count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_integer_range_set_unsigned_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of an unsigned integer range set."]
    pub fn bt_integer_range_set_unsigned_get_ref(
        int_range_set: *const bt_integer_range_set_unsigned,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the unsigned integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "@parblock"]
    #[doc = "Unsigned integer range set of which to decrement the reference"]
    #[doc = "count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_integer_range_set_unsigned_get_ref() &mdash;"]
    #[doc = "Increments the reference count of an unsigned integer range set."]
    pub fn bt_integer_range_set_unsigned_put_ref(
        int_range_set: *const bt_integer_range_set_unsigned,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an empty set of signed 64-bit integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New signed integer range set, or \\c NULL on memory error."]
    pub fn bt_integer_range_set_signed_create() -> *mut bt_integer_range_set_signed;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a signed 64-bit integer range having the lower value"]
    #[doc = "\\bt_p{lower} and the upper value \\bt_p{upper} to the signed"]
    #[doc = "integer range set"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "The values \\bt_p{lower} and \\bt_p{upper} are included in the signed"]
    #[doc = "integer range to add to \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "Signed integer range set to which to add a signed integer"]
    #[doc = "range."]
    #[doc = "@param[in] lower"]
    #[doc = "Lower value (included) of the signed integer range to add to"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = "@param[in] upper"]
    #[doc = "Upper value (included) of the signed integer range to add to"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@retval #BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set}"]
    #[doc = "@bt_pre_hot{int_range_set}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{lower}  \\bt_p{upper}."]
    pub fn bt_integer_range_set_signed_add_range(
        int_range_set: *mut bt_integer_range_set_signed,
        lower: i64,
        upper: i64,
    ) -> bt_integer_range_set_add_range_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the signed integer range at index \\bt_p{index} from the"]
    #[doc = "signed integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "Signed integer range set from which to borrow the signed integer"]
    #[doc = "range at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the signed integer range to borrow from"]
    #[doc = "\\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the signed integer range of"]
    #[doc = "\\bt_p{int_range_set} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{int_range_set} is"]
    #[doc = "modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of signed integer ranges in"]
    #[doc = "\\bt_p{int_range_set} (as returned by"]
    #[doc = "bt_integer_range_set_get_range_count())."]
    pub fn bt_integer_range_set_signed_borrow_range_by_index_const(
        int_range_set: *const bt_integer_range_set_signed,
        index: u64,
    ) -> *const bt_integer_range_signed;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the signed integer range set"]
    #[doc = "\\bt_p{int_range_set_a} is equal to \\bt_p{int_range_set_b}."]
    #[doc = ""]
    #[doc = "Two signed integer range sets are considered equal if they contain the"]
    #[doc = "exact same signed integer ranges, whatever the order. In other words,"]
    #[doc = "a signed integer range set containing [-57,&nbsp;23] and [24,&nbsp;42]"]
    #[doc = "is \\em not equal to a signed integer range containing [-57,&nbsp;42]."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set_a"]
    #[doc = "Signed integer range set A."]
    #[doc = "@param[in] int_range_set_b"]
    #[doc = "Signed integer range set B."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{int_range_set_a} is equal to"]
    #[doc = "\\bt_p{int_range_set_b}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{int_range_set_a}"]
    #[doc = "@bt_pre_not_null{int_range_set_b}"]
    pub fn bt_integer_range_set_signed_is_equal(
        int_range_set_a: *const bt_integer_range_set_signed,
        int_range_set_b: *const bt_integer_range_set_signed,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the signed integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "@parblock"]
    #[doc = "Signed integer range set of which to increment the reference"]
    #[doc = "count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_integer_range_set_signed_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a signed integer range set."]
    pub fn bt_integer_range_set_signed_get_ref(int_range_set: *const bt_integer_range_set_signed);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the signed integer range set \\bt_p{int_range_set}."]
    #[doc = ""]
    #[doc = "@param[in] int_range_set"]
    #[doc = "@parblock"]
    #[doc = "Signed integer range set of which to decrement the reference"]
    #[doc = "count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_integer_range_set_signed_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a signed integer range set."]
    pub fn bt_integer_range_set_signed_put_ref(int_range_set: *const bt_integer_range_set_signed);
}
pub mod bt_message_iterator_class_can_seek_beginning_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_can_seek_beginning_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter \"can seek beginning?\" method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-can-seek-beg \"can seek beginning?\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = "@param[out] can_seek_beginning"]
#[doc = "<strong>On success</strong>, \\bt_p{*can_seek_beginning} is"]
#[doc = "#BT_TRUE if \\bt_p{self_message_iterator} can currently seek its"]
#[doc = "beginning."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@bt_pre_not_null{can_seek_beginning}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*can_seek_beginning} is set."]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_seek_beginning_methods() &mdash;"]
#[doc = "Sets the \"seek beginning\" and \"can seek beginning?\" methods of a"]
#[doc = "message iterator class."]
pub type bt_message_iterator_class_can_seek_beginning_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
        can_seek_beginning: *mut bt_bool,
    ) -> bt_message_iterator_class_can_seek_beginning_method_status::Type,
>;
pub mod bt_message_iterator_class_can_seek_ns_from_origin_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_can_seek_ns_from_origin_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR: Type =
        -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter \"can seek ns from origin?\" method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-can-seek-ns \"can seek ns from origin?\""]
#[doc = "method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = "@param[in] ns_from_origin"]
#[doc = "Requested time point to seek."]
#[doc = "@param[out] can_seek_ns_from_origin"]
#[doc = "<strong>On success</strong>, set \\bt_p{*can_seek_ns_from_origin} to"]
#[doc = "#BT_TRUE if \\bt_p{self_message_iterator} can currently seek a"]
#[doc = "message occurring at or after \\bt_p{ns_from_origin} nanoseconds from"]
#[doc = "its \\ref api-tir-clock-cls-origin \"clock class origin\"."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@bt_pre_not_null{can_seek_ns_from_origin}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*can_seek_ns_from_origin} is set."]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_seek_ns_from_origin_methods() &mdash;"]
#[doc = "Sets the \"seek ns from origin\" and \"can seek ns from origin?\""]
#[doc = "methods of a message iterator class."]
pub type bt_message_iterator_class_can_seek_ns_from_origin_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
        ns_from_origin: i64,
        can_seek_ns_from_origin: *mut bt_bool,
    )
        -> bt_message_iterator_class_can_seek_ns_from_origin_method_status::Type,
>;
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter finalization method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-fini \"finalize\" method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = ""]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_finalize_method() &mdash;"]
#[doc = "Sets the finalization method of a message iterator class."]
pub type bt_message_iterator_class_finalize_method = ::std::option::Option<
    unsafe extern "C" fn(self_message_iterator: *mut bt_self_message_iterator),
>;
pub mod bt_message_iterator_class_initialize_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_initialize_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter initialization method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-init \"initialize\" method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = "@param[in] configuration"]
#[doc = "Message iterator's configuration."]
#[doc = "@param[in] port"]
#[doc = "\\bt_c_oport for which \\bt_p{self_message_iterator} was created."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@bt_pre_not_null{configuration}"]
#[doc = "@bt_pre_not_null{port}"]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_initialize_method() &mdash;"]
#[doc = "Sets the initialization method of a message iterator class."]
pub type bt_message_iterator_class_initialize_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
        configuration: *mut bt_self_message_iterator_configuration,
        port: *mut bt_self_component_port_output,
    ) -> bt_message_iterator_class_initialize_method_status::Type,
>;
pub mod bt_message_iterator_class_next_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_next_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "End of iteration."]
    pub const BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_END: Type = 1;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter \"next\" (get next messages) method."]
#[doc = ""]
#[doc = "See the \\link api-msg-iter-cls-meth-next \"next\"\\endlink method."]
#[doc = ""]
#[doc = "If this method returns #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_OK,"]
#[doc = "then all the messages of the message array become"]
#[doc = "\\ref api-fund-freezing \"frozen\"."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = "@param[out] messages"]
#[doc = "@parblock"]
#[doc = "Message array to fill, on success, with the \\bt_p_msg to emit."]
#[doc = ""]
#[doc = "This array needs its own message"]
#[doc = "\\ref api-fund-shared-object \"references\". In other"]
#[doc = "words, if you have a message reference and you put this message"]
#[doc = "into the array without calling bt_message_get_ref(), then you just"]
#[doc = "\\em moved the message reference to the array (the array owns the"]
#[doc = "message now)."]
#[doc = ""]
#[doc = "The capacity of this array (maximum number of messages you can put"]
#[doc = "in it) is \\bt_p{capacity}."]
#[doc = "@endparblock"]
#[doc = "@param[in] capacity"]
#[doc = "Capacity of the \\bt_p{messages} array (maximum number of messages"]
#[doc = "you can put in it)."]
#[doc = "@param[out] count"]
#[doc = "<strong>On success</strong>, \\bt_p{*count} is the number of messages"]
#[doc = "you put in \\bt_p{messages}."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_END"]
#[doc = "End of iteration."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@bt_pre_not_null{messages}"]
#[doc = "@pre"]
#[doc = "\\bt_p{capacity}  1."]
#[doc = "@bt_pre_not_null{count}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{messages} contains \\bt_p{*count}"]
#[doc = "message references as its first \\bt_p{*count} elements."]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, the \\bt_p_msg in \\bt_p{messages} honour"]
#[doc = "the \\ref api-msg-seq \"message sequence rules\"."]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, for any \\bt_ev_msg in"]
#[doc = "\\bt_p{messages}, its"]
#[doc = "\\ref api-tir-ev-prop-payload \"payload field\","]
#[doc = "\\ref api-tir-ev-prop-spec-ctx \"specific context field\","]
#[doc = "\\ref api-tir-ev-prop-common-ctx \"common context field\", and all"]
#[doc = "their inner \\bt_p_field, recursively, are set."]
#[doc = "@post"]
#[doc = "<strong>On success</strong>, \\bt_p{*count}&nbsp;&nbsp;1."]
#[doc = "@post"]
#[doc = "<strong>On success</strong>,"]
#[doc = "\\bt_p{*count}&nbsp;&nbsp;\\bt_p{capacity}."]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_create() &mdash;"]
#[doc = "Creates a message iterator class."]
pub type bt_message_iterator_class_next_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
        messages: bt_message_array_const,
        capacity: u64,
        count: *mut u64,
    ) -> bt_message_iterator_class_next_method_status::Type,
>;
pub mod bt_message_iterator_class_seek_beginning_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_seek_beginning_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter \"seek beginning\" method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-seek-beg \"seek beginning\" method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@pre"]
#[doc = "<strong>If \\bt_p{self_message_iterator} has a"]
#[doc = "\\ref api-msg-iter-cls-meth-can-seek-beg \"can seek beginning?\""]
#[doc = "method</strong>, then it was called and returned #BT_TRUE before"]
#[doc = "this \"seek beginning\" method is called, without any other method of"]
#[doc = "\\bt_p{self_message_iterator} called in between."]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_seek_beginning_methods() &mdash;"]
#[doc = "Sets the \"seek beginning\" and \"can seek beginning?\" methods of a"]
#[doc = "message iterator class."]
pub type bt_message_iterator_class_seek_beginning_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
    ) -> bt_message_iterator_class_seek_beginning_method_status::Type,
>;
pub mod bt_message_iterator_class_seek_ns_from_origin_method_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_message_iterator_class_seek_ns_from_origin_method."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Try again."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN: Type = 11;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "\\bt_c_msg_iter \"seek ns from origin\" method."]
#[doc = ""]
#[doc = "See the \\ref api-msg-iter-cls-meth-seek-ns \"seek ns from origin\" method."]
#[doc = ""]
#[doc = "@param[in] self_message_iterator"]
#[doc = "Message iterator instance."]
#[doc = "@param[in] ns_from_origin"]
#[doc = "Time point to seek."]
#[doc = ""]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN"]
#[doc = "Try again."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_message_iterator}"]
#[doc = "@pre"]
#[doc = "<strong>If \\bt_p{self_message_iterator} has a"]
#[doc = "\\ref api-msg-iter-cls-meth-can-seek-ns \"can seek ns from origin?\""]
#[doc = "method</strong>, then it was called and returned #BT_TRUE before"]
#[doc = "this \"seek ns from origin\" method is called, without any other"]
#[doc = "method of \\bt_p{self_message_iterator} called in between."]
#[doc = ""]
#[doc = "@sa bt_message_iterator_class_set_seek_ns_from_origin_methods() &mdash;"]
#[doc = "Sets the \"seek ns from origin\" and \"can seek ns from origin?\""]
#[doc = "methods of a message iterator class."]
pub type bt_message_iterator_class_seek_ns_from_origin_method = ::std::option::Option<
    unsafe extern "C" fn(
        self_message_iterator: *mut bt_self_message_iterator,
        ns_from_origin: i64,
    ) -> bt_message_iterator_class_seek_ns_from_origin_method_status::Type,
>;
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a message iterator class having the"]
    #[doc = "\\link api-msg-iter-cls-meth-next \"next\" method\\endlink method"]
    #[doc = "\\bt_p{next_method}."]
    #[doc = ""]
    #[doc = "@param[in] next_method"]
    #[doc = "\"Next\" method of the message iterator class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New message iterator class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{next_method}"]
    pub fn bt_message_iterator_class_create(
        next_method: bt_message_iterator_class_next_method,
    ) -> *mut bt_message_iterator_class;
}
pub mod bt_message_iterator_class_set_method_status {
    #[doc = "@brief"]
    #[doc = "Status code for the"]
    #[doc = "<code>bt_message_iterator_class_set_*_method()</code> functions."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional finalization method of the message iterator class"]
    #[doc = "\\bt_p{message_iterator_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-iter-cls-meth-fini \"finalize\" method."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of which to set the finalization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New finalization method of \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = "@bt_pre_hot{message_iterator_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_message_iterator_class_set_finalize_method(
        message_iterator_class: *mut bt_message_iterator_class,
        method: bt_message_iterator_class_finalize_method,
    ) -> bt_message_iterator_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional initialization method of the message iterator"]
    #[doc = "class \\bt_p{message_iterator_class} to \\bt_p{method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-iter-cls-meth-init \"initialize\" method."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of which to set the initialization method to"]
    #[doc = "\\bt_p{method}."]
    #[doc = "@param[in] method"]
    #[doc = "New initialization method of \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = "@bt_pre_hot{message_iterator_class}"]
    #[doc = "@bt_pre_not_null{method}"]
    pub fn bt_message_iterator_class_set_initialize_method(
        message_iterator_class: *mut bt_message_iterator_class,
        method: bt_message_iterator_class_initialize_method,
    ) -> bt_message_iterator_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"seek beginning\" and"]
    #[doc = "\"can seek beginning?\" methods of the message iterator class"]
    #[doc = "\\bt_p{message_iterator_class} to \\bt_p{seek_method} and"]
    #[doc = "\\bt_p{can_seek_method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-iter-cls-meth-seek-beg \"seek beginning\""]
    #[doc = "and \\ref api-msg-iter-cls-meth-can-seek-beg \"can seek beginning?\""]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of which to set the \"seek beginning\""]
    #[doc = "and \"can seek beginning?\" methods."]
    #[doc = "@param[in] seek_method"]
    #[doc = "New \"seek beginning\" method of \\bt_p{message_iterator_class}."]
    #[doc = "@param[in] can_seek_method"]
    #[doc = "@parblock"]
    #[doc = "New \"can seek beginning?\" method of \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case it is equivalent to setting a method"]
    #[doc = "which always returns #BT_TRUE."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = "@bt_pre_hot{message_iterator_class}"]
    #[doc = "@bt_pre_not_null{seek_method}"]
    pub fn bt_message_iterator_class_set_seek_beginning_methods(
        message_iterator_class: *mut bt_message_iterator_class,
        seek_method: bt_message_iterator_class_seek_beginning_method,
        can_seek_method: bt_message_iterator_class_can_seek_beginning_method,
    ) -> bt_message_iterator_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the optional \"seek ns from origin\" and"]
    #[doc = "\"can seek ns from origin?\" methods of the message iterator class"]
    #[doc = "\\bt_p{message_iterator_class} to \\bt_p{seek_method} and"]
    #[doc = "\\bt_p{can_seek_method}."]
    #[doc = ""]
    #[doc = "See the \\ref api-msg-iter-cls-meth-seek-ns \"seek ns from origin\""]
    #[doc = "and"]
    #[doc = "\\ref api-msg-iter-cls-meth-can-seek-ns \"can seek ns from origin?\""]
    #[doc = "methods."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "Message iterator class of which to set the \"seek ns from origin\""]
    #[doc = "and \"can seek ns from origin?\" methods."]
    #[doc = "@param[in] seek_method"]
    #[doc = "New \"seek ns from origin\" method of \\bt_p{message_iterator_class}."]
    #[doc = "@param[in] can_seek_method"]
    #[doc = "@parblock"]
    #[doc = "New \"can seek ns from origin?\" method of"]
    #[doc = "\\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "Can be \\c NULL, in which case it is equivalent to setting a method"]
    #[doc = "which always returns #BT_TRUE."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@retval #BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{message_iterator_class}"]
    #[doc = "@bt_pre_hot{message_iterator_class}"]
    #[doc = "@bt_pre_not_null{seek_method}"]
    pub fn bt_message_iterator_class_set_seek_ns_from_origin_methods(
        message_iterator_class: *mut bt_message_iterator_class,
        seek_method: bt_message_iterator_class_seek_ns_from_origin_method,
        can_seek_method: bt_message_iterator_class_can_seek_ns_from_origin_method,
    ) -> bt_message_iterator_class_set_method_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message iterator class \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "@parblock"]
    #[doc = "Message iterator class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a message iterator class."]
    pub fn bt_message_iterator_class_get_ref(
        message_iterator_class: *const bt_message_iterator_class,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the message iterator class \\bt_p{message_iterator_class}."]
    #[doc = ""]
    #[doc = "@param[in] message_iterator_class"]
    #[doc = "@parblock"]
    #[doc = "Message iterator class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_component_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a message iterator class."]
    pub fn bt_message_iterator_class_put_ref(
        message_iterator_class: *const bt_message_iterator_class,
    );
}
pub mod bt_plugin_initialize_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_plugin_initialize_func."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_INITIALIZE_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_INITIALIZE_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_INITIALIZE_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User plugin initialization function."]
#[doc = ""]
#[doc = "@param[in] self_plugin"]
#[doc = "@parblock"]
#[doc = "Plugin instance."]
#[doc = ""]
#[doc = "This parameter is a private view of the \\bt_plugin object for"]
#[doc = "this function."]
#[doc = ""]
#[doc = "As of \\bt_name_version_min_maj, there's no self plugin API."]
#[doc = "@endparblock"]
#[doc = ""]
#[doc = "@retval #BT_PLUGIN_INITIALIZE_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_PLUGIN_INITIALIZE_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_PLUGIN_INITIALIZE_FUNC_STATUS_ERROR"]
#[doc = "Error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{self_plugin}"]
pub type bt_plugin_initialize_func = ::std::option::Option<
    unsafe extern "C" fn(
        self_plugin: *mut bt_self_plugin,
    ) -> bt_plugin_initialize_func_status::Type,
>;
#[doc = "@brief"]
#[doc = "User plugin finalization function."]
pub type bt_plugin_finalize_func = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " @}"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_descriptor {
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout___bt_plugin_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(__bt_plugin_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(__bt_plugin_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__bt_plugin_descriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor),
            "::",
            stringify!(name)
        )
    );
}
pub mod __bt_plugin_descriptor_attribute_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_INIT: Type = 0;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_EXIT: Type = 1;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_AUTHOR: Type = 2;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_LICENSE: Type = 3;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_DESCRIPTION: Type = 4;
    pub const BT_PLUGIN_DESCRIPTOR_ATTRIBUTE_TYPE_VERSION: Type = 5;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_descriptor_version {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
    pub extra: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout___bt_plugin_descriptor_version() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_descriptor_version>(),
        24usize,
        concat!("Size of: ", stringify!(__bt_plugin_descriptor_version))
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_descriptor_version>(),
        8usize,
        concat!("Alignment of ", stringify!(__bt_plugin_descriptor_version))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_version>())).major as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_version>())).minor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_version>())).patch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_version),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_version>())).extra as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_version),
            "::",
            stringify!(extra)
        )
    );
}
#[repr(C, packed)]
pub struct __bt_plugin_descriptor_attribute {
    pub plugin_descriptor: *const __bt_plugin_descriptor,
    pub type_name: *const ::std::os::raw::c_char,
    pub type_: __bt_plugin_descriptor_attribute_type::Type,
    pub value: __bt_plugin_descriptor_attribute__bindgen_ty_1,
}
#[repr(C)]
pub struct __bt_plugin_descriptor_attribute__bindgen_ty_1 {
    pub init: __BindgenUnionField<bt_plugin_initialize_func>,
    pub exit: __BindgenUnionField<bt_plugin_finalize_func>,
    pub author: __BindgenUnionField<*const ::std::os::raw::c_char>,
    pub license: __BindgenUnionField<*const ::std::os::raw::c_char>,
    pub description: __BindgenUnionField<*const ::std::os::raw::c_char>,
    pub version: __BindgenUnionField<__bt_plugin_descriptor_version>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout___bt_plugin_descriptor_attribute__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_descriptor_attribute__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_descriptor_attribute__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).init
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).exit
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).author
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(author)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).license
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(license)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).description
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute__bindgen_ty_1>())).version
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout___bt_plugin_descriptor_attribute() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_descriptor_attribute>(),
        44usize,
        concat!("Size of: ", stringify!(__bt_plugin_descriptor_attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_descriptor_attribute>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_descriptor_attribute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute>())).plugin_descriptor
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute),
            "::",
            stringify!(plugin_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute>())).type_name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_descriptor_attribute>())).value as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_descriptor_attribute),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_component_class_descriptor {
    pub plugin_descriptor: *const __bt_plugin_descriptor,
    pub name: *const ::std::os::raw::c_char,
    pub type_: bt_component_class_type::Type,
    pub methods: __bt_plugin_component_class_descriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __bt_plugin_component_class_descriptor__bindgen_ty_1 {
    pub source: __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1,
    pub filter: __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2,
    pub sink: __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub msg_iter_next: bt_message_iterator_class_next_method,
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1,
            >()))
            .msg_iter_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(msg_iter_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2 {
    pub msg_iter_next: bt_message_iterator_class_next_method,
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2,
            >()))
            .msg_iter_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(msg_iter_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3 {
    pub consume: bt_component_class_sink_consume_method,
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                __bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3,
            >()))
            .consume as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(consume)
        )
    );
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor__bindgen_ty_1>())).source
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor__bindgen_ty_1>())).filter
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor__bindgen_ty_1>())).sink
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor__bindgen_ty_1),
            "::",
            stringify!(sink)
        )
    );
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor>())).plugin_descriptor
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor),
            "::",
            stringify!(plugin_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor>())).name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor>())).type_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor>())).methods as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor),
            "::",
            stringify!(methods)
        )
    );
}
pub mod __bt_plugin_component_class_descriptor_attribute_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_DESCRIPTION: Type = 0;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_HELP: Type = 1;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_GET_SUPPORTED_MIP_VERSIONS_METHOD : Type = 2 ;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_INITIALIZE_METHOD: Type = 3;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_FINALIZE_METHOD: Type = 4;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_QUERY_METHOD: Type = 5;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_INPUT_PORT_CONNECTED_METHOD:
        Type = 6;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_OUTPUT_PORT_CONNECTED_METHOD:
        Type = 7;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_GRAPH_IS_CONFIGURED_METHOD: Type =
        8;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_INITIALIZE_METHOD: Type =
        9;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_FINALIZE_METHOD: Type =
        10;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_SEEK_NS_FROM_ORIGIN_METHOD : Type = 11 ;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_SEEK_BEGINNING_METHOD:
        Type = 12;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_CAN_SEEK_NS_FROM_ORIGIN_METHOD : Type = 13 ;
    pub const BT_PLUGIN_COMPONENT_CLASS_DESCRIPTOR_ATTRIBUTE_TYPE_MSG_ITER_CAN_SEEK_BEGINNING_METHOD : Type = 14 ;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct __bt_plugin_component_class_descriptor_attribute {
    pub comp_class_descriptor: *const __bt_plugin_component_class_descriptor,
    pub type_name: *const ::std::os::raw::c_char,
    pub type_: __bt_plugin_component_class_descriptor_attribute_type::Type,
    pub value: __bt_plugin_component_class_descriptor_attribute__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __bt_plugin_component_class_descriptor_attribute__bindgen_ty_1 {
    pub description: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
    pub source_get_supported_mip_versions_method:
        bt_component_class_source_get_supported_mip_versions_method,
    pub filter_get_supported_mip_versions_method:
        bt_component_class_filter_get_supported_mip_versions_method,
    pub sink_get_supported_mip_versions_method:
        bt_component_class_sink_get_supported_mip_versions_method,
    pub source_initialize_method: bt_component_class_source_initialize_method,
    pub filter_initialize_method: bt_component_class_filter_initialize_method,
    pub sink_initialize_method: bt_component_class_sink_initialize_method,
    pub source_finalize_method: bt_component_class_source_finalize_method,
    pub filter_finalize_method: bt_component_class_filter_finalize_method,
    pub sink_finalize_method: bt_component_class_sink_finalize_method,
    pub source_query_method: bt_component_class_source_query_method,
    pub filter_query_method: bt_component_class_filter_query_method,
    pub sink_query_method: bt_component_class_sink_query_method,
    pub filter_input_port_connected_method: bt_component_class_filter_input_port_connected_method,
    pub sink_input_port_connected_method: bt_component_class_sink_input_port_connected_method,
    pub source_output_port_connected_method: bt_component_class_source_output_port_connected_method,
    pub filter_output_port_connected_method: bt_component_class_filter_output_port_connected_method,
    pub sink_graph_is_configured_method: bt_component_class_sink_graph_is_configured_method,
    pub msg_iter_initialize_method: bt_message_iterator_class_initialize_method,
    pub msg_iter_finalize_method: bt_message_iterator_class_finalize_method,
    pub msg_iter_seek_ns_from_origin_method: bt_message_iterator_class_seek_ns_from_origin_method,
    pub msg_iter_seek_beginning_method: bt_message_iterator_class_seek_beginning_method,
    pub msg_iter_can_seek_ns_from_origin_method:
        bt_message_iterator_class_can_seek_ns_from_origin_method,
    pub msg_iter_can_seek_beginning_method: bt_message_iterator_class_can_seek_beginning_method,
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor_attribute__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .description as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .help as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .source_get_supported_mip_versions_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(source_get_supported_mip_versions_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_get_supported_mip_versions_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_get_supported_mip_versions_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_get_supported_mip_versions_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_get_supported_mip_versions_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .source_initialize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(source_initialize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_initialize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_initialize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_initialize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_initialize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .source_finalize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(source_finalize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_finalize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_finalize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_finalize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_finalize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .source_query_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(source_query_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_query_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_query_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_query_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_query_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_input_port_connected_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_input_port_connected_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_input_port_connected_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_input_port_connected_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .source_output_port_connected_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(source_output_port_connected_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .filter_output_port_connected_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(filter_output_port_connected_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .sink_graph_is_configured_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(sink_graph_is_configured_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_initialize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_initialize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_finalize_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_finalize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_seek_ns_from_origin_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_seek_ns_from_origin_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_seek_beginning_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_seek_beginning_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_can_seek_ns_from_origin_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_can_seek_ns_from_origin_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1>(
            )))
            .msg_iter_can_seek_beginning_method as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute__bindgen_ty_1),
            "::",
            stringify!(msg_iter_can_seek_beginning_method)
        )
    );
}
#[test]
fn bindgen_test_layout___bt_plugin_component_class_descriptor_attribute() {
    assert_eq!(
        ::std::mem::size_of::<__bt_plugin_component_class_descriptor_attribute>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__bt_plugin_component_class_descriptor_attribute>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(__bt_plugin_component_class_descriptor_attribute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute>()))
                .comp_class_descriptor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute),
            "::",
            stringify!(comp_class_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute>())).type_name
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute>())).type_
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__bt_plugin_component_class_descriptor_attribute>())).value
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__bt_plugin_component_class_descriptor_attribute),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn __bt_get_begin_section_plugin_descriptors() -> *const *const __bt_plugin_descriptor;
}
extern "C" {
    pub fn __bt_get_end_section_plugin_descriptors() -> *const *const __bt_plugin_descriptor;
}
extern "C" {
    pub fn __bt_get_begin_section_plugin_descriptor_attributes(
    ) -> *const *const __bt_plugin_descriptor_attribute;
}
extern "C" {
    pub fn __bt_get_end_section_plugin_descriptor_attributes(
    ) -> *const *const __bt_plugin_descriptor_attribute;
}
extern "C" {
    pub fn __bt_get_begin_section_component_class_descriptors(
    ) -> *const *const __bt_plugin_component_class_descriptor;
}
extern "C" {
    pub fn __bt_get_end_section_component_class_descriptors(
    ) -> *const *const __bt_plugin_component_class_descriptor;
}
extern "C" {
    pub fn __bt_get_begin_section_component_class_descriptor_attributes(
    ) -> *const *const __bt_plugin_component_class_descriptor_attribute;
}
extern "C" {
    pub fn __bt_get_end_section_component_class_descriptor_attributes(
    ) -> *const *const __bt_plugin_component_class_descriptor_attribute;
}
pub mod bt_plugin_find_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_plugin_find()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_FIND_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Plugin not found."]
    pub const BT_PLUGIN_FIND_STATUS_NOT_FOUND: Type = 2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_FIND_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_FIND_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Finds and loads a single plugin which has the name"]
    #[doc = "\\bt_p{plugin_name} from the default plugin search directories and"]
    #[doc = "static plugins, setting \\bt_p{*plugin} to the result."]
    #[doc = ""]
    #[doc = "This function returns the first plugin which has the name"]
    #[doc = "\\bt_p{plugin_name} within, in order:"]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_std_env_var} parameter is"]
    #[doc = "#BT_TRUE</strong>,"]
    #[doc = "the colon-separated (or semicolon-separated on Windows) list of"]
    #[doc = "directories in the \\c BABELTRACE_PLUGIN_PATH environment variable,"]
    #[doc = "if it's set."]
    #[doc = ""]
    #[doc = "The function searches each directory in this list, without recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_user_dir} parameter is"]
    #[doc = "#BT_TRUE</strong>, <code>$HOME/.local/lib/babeltrace2/plugins</code>,"]
    #[doc = "without recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_sys_dir} is #BT_TRUE</strong>, the"]
    #[doc = "system \\bt_name plugin directory, typically"]
    #[doc = "<code>/usr/lib/babeltrace2/plugins</code> or"]
    #[doc = "<code>/usr/local/lib/babeltrace2/plugins</code> on Linux, without"]
    #[doc = "recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_static} is #BT_TRUE</strong>,"]
    #[doc = "the static plugins."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "A plugin's name is not related to the name of its file (shared"]
    #[doc = "object or Python file). For example, a plugin found in the file"]
    #[doc = "\\c patente.so can be named <code>Dan</code>."]
    #[doc = ""]
    #[doc = "If this function finds a file which looks like a plugin (shared object"]
    #[doc = "file or Python file with the \\c bt_plugin_ prefix), but it fails to load"]
    #[doc = "it for any reason, the function:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_TRUE</dt>"]
    #[doc = "<dd>Returns #BT_PLUGIN_FIND_STATUS_ERROR.</dd>"]
    #[doc = ""]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_FALSE</dt>"]
    #[doc = "<dd>Ignores the loading error and continues searching.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "If this function doesn't find any plugin, it returns"]
    #[doc = "#BT_PLUGIN_FIND_STATUS_NOT_FOUND and does \\em not set \\bt_p{*plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin_name"]
    #[doc = "Name of the plugin to find and load."]
    #[doc = "@param[in] find_in_std_env_var"]
    #[doc = "#BT_TRUE to try to find the plugin named \\bt_p{plugin_name} in the"]
    #[doc = "colon-separated (or semicolon-separated on Windows) list of"]
    #[doc = "directories in the \\c BABELTRACE_PLUGIN_PATH environment variable."]
    #[doc = "@param[in] find_in_user_dir"]
    #[doc = "#BT_TRUE to try to find the plugin named \\bt_p{plugin_name} in"]
    #[doc = "the <code>$HOME/.local/lib/babeltrace2/plugins</code> directory,"]
    #[doc = "without recursing."]
    #[doc = "@param[in] find_in_sys_dir"]
    #[doc = "#BT_TRUE to try to find the plugin named \\bt_p{plugin_name} in"]
    #[doc = "the system \\bt_name plugin directory."]
    #[doc = "@param[in] find_in_static"]
    #[doc = "#BT_TRUE to try to find the plugin named \\bt_p{plugin_name} in the"]
    #[doc = "static plugins."]
    #[doc = "@param[in] fail_on_load_error"]
    #[doc = "#BT_TRUE to make this function return #BT_PLUGIN_FIND_STATUS_ERROR"]
    #[doc = "on any plugin loading error instead of ignoring it."]
    #[doc = "@param[out] plugin"]
    #[doc = "<strong>On success</strong>, \\bt_p{*plugin} is a new plugin"]
    #[doc = "reference of named \\bt_p{plugin_name}."]
    #[doc = ""]
    #[doc = "@retval #BT_PLUGIN_FIND_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_PLUGIN_FIND_STATUS_NOT_FOUND"]
    #[doc = "Plugin not found."]
    #[doc = "@retval #BT_PLUGIN_FIND_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_PLUGIN_FIND_STATUS_ERROR"]
    #[doc = "Error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin_name}"]
    #[doc = "@pre"]
    #[doc = "At least one of the \\bt_p{find_in_std_env_var},"]
    #[doc = "\\bt_p{find_in_user_dir}, \\bt_p{find_in_sys_dir}, and"]
    #[doc = "\\bt_p{find_in_static} parameters is #BT_TRUE."]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_find_all() &mdash;"]
    #[doc = "Finds and loads all plugins from the default plugin search"]
    #[doc = "directories and static plugins."]
    pub fn bt_plugin_find(
        plugin_name: *const ::std::os::raw::c_char,
        find_in_std_env_var: bt_bool,
        find_in_user_dir: bt_bool,
        find_in_sys_dir: bt_bool,
        find_in_static: bt_bool,
        fail_on_load_error: bt_bool,
        plugin: *mut *const bt_plugin,
    ) -> bt_plugin_find_status::Type;
}
pub mod bt_plugin_find_all_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_plugin_find_all()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_FIND_ALL_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "No plugins found."]
    pub const BT_PLUGIN_FIND_ALL_STATUS_NOT_FOUND: Type = 2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_FIND_ALL_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_FIND_ALL_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Finds and loads all the plugins from the default"]
    #[doc = "plugin search directories and static plugins, setting"]
    #[doc = "\\bt_p{*plugins} to the result."]
    #[doc = ""]
    #[doc = "This function returns all the plugins within, in order:"]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_std_env_var} parameter is"]
    #[doc = "#BT_TRUE</strong>,"]
    #[doc = "the colon-separated (or semicolon-separated on Windows) list of"]
    #[doc = "directories in the \\c BABELTRACE_PLUGIN_PATH environment variable,"]
    #[doc = "if it's set."]
    #[doc = ""]
    #[doc = "The function searches each directory in this list, without recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_user_dir} parameter is"]
    #[doc = "#BT_TRUE</strong>, <code>$HOME/.local/lib/babeltrace2/plugins</code>,"]
    #[doc = "without recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_sys_dir} is #BT_TRUE</strong>, the"]
    #[doc = "system \\bt_name plugin directory, typically"]
    #[doc = "<code>/usr/lib/babeltrace2/plugins</code> or"]
    #[doc = "<code>/usr/local/lib/babeltrace2/plugins</code> on Linux, without"]
    #[doc = "recursing."]
    #[doc = ""]
    #[doc = "-# <strong>If the \\bt_p{find_in_static} is #BT_TRUE</strong>,"]
    #[doc = "the static plugins."]
    #[doc = ""]
    #[doc = "During the search process, if a found plugin shares the name of an"]
    #[doc = "already loaded plugin, this function ignores it and continues."]
    #[doc = ""]
    #[doc = "If this function finds a file which looks like a plugin (shared object"]
    #[doc = "file or Python file with the \\c bt_plugin_ prefix), but it fails to load"]
    #[doc = "it for any reason, the function:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_TRUE</dt>"]
    #[doc = "<dd>Returns #BT_PLUGIN_FIND_ALL_STATUS_ERROR.</dd>"]
    #[doc = ""]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_FALSE</dt>"]
    #[doc = "<dd>Ignores the loading error and continues searching.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "If this function doesn't find any plugin, it returns"]
    #[doc = "#BT_PLUGIN_FIND_ALL_STATUS_NOT_FOUND and does \\em not set"]
    #[doc = "\\bt_p{*plugins}."]
    #[doc = ""]
    #[doc = "@param[in] find_in_std_env_var"]
    #[doc = "#BT_TRUE to try to find all the plugins in the"]
    #[doc = "colon-separated (or semicolon-separated on Windows) list of"]
    #[doc = "directories in the \\c BABELTRACE_PLUGIN_PATH environment variable."]
    #[doc = "@param[in] find_in_user_dir"]
    #[doc = "#BT_TRUE to try to find all the plugins in"]
    #[doc = "the <code>$HOME/.local/lib/babeltrace2/plugins</code> directory,"]
    #[doc = "without recursing."]
    #[doc = "@param[in] find_in_sys_dir"]
    #[doc = "#BT_TRUE to try to find all the plugins in the system \\bt_name"]
    #[doc = "plugin directory."]
    #[doc = "@param[in] find_in_static"]
    #[doc = "#BT_TRUE to try to find all the plugins in the static plugins."]
    #[doc = "@param[in] fail_on_load_error"]
    #[doc = "#BT_TRUE to make this function return"]
    #[doc = "#BT_PLUGIN_FIND_ALL_STATUS_ERROR on any plugin loading error instead"]
    #[doc = "of ignoring it."]
    #[doc = "@param[out] plugins"]
    #[doc = "<strong>On success</strong>, \\bt_p{*plugins} is a new plugin set"]
    #[doc = "reference which contains all the plugins found from the default"]
    #[doc = "plugin search directories and static plugins."]
    #[doc = ""]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_STATUS_NOT_FOUND"]
    #[doc = "No plugins found."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_STATUS_ERROR"]
    #[doc = "Error."]
    #[doc = ""]
    #[doc = "@pre"]
    #[doc = "At least one of the \\bt_p{find_in_std_env_var},"]
    #[doc = "\\bt_p{find_in_user_dir}, \\bt_p{find_in_sys_dir}, and"]
    #[doc = "\\bt_p{find_in_static} parameters is #BT_TRUE."]
    #[doc = "@bt_pre_not_null{plugins}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_find() &mdash;"]
    #[doc = "Finds and loads a single plugin by name from the default plugin search"]
    #[doc = "directories and static plugins."]
    pub fn bt_plugin_find_all(
        find_in_std_env_var: bt_bool,
        find_in_user_dir: bt_bool,
        find_in_sys_dir: bt_bool,
        find_in_static: bt_bool,
        fail_on_load_error: bt_bool,
        plugins: *mut *const bt_plugin_set,
    ) -> bt_plugin_find_all_status::Type;
}
pub mod bt_plugin_find_all_from_file_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_plugin_find_all_from_file()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "No plugins found."]
    pub const BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_NOT_FOUND: Type = 2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Finds and loads all the plugins from the file with path \\bt_p{path},"]
    #[doc = "setting \\bt_p{*plugins} to the result."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "A plugin's name is not related to the name of its file (shared"]
    #[doc = "object or Python file). For example, a plugin found in the file"]
    #[doc = "\\c patente.so can be named <code>Dan</code>."]
    #[doc = ""]
    #[doc = "If any plugin loading error occurs during this function's execution, the"]
    #[doc = "function:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_TRUE</dt>"]
    #[doc = "<dd>Returns #BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_ERROR.</dd>"]
    #[doc = ""]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_FALSE</dt>"]
    #[doc = "<dd>Ignores the loading error and continues.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "If this function doesn't find any plugin, it returns"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_NOT_FOUND and does \\em not set"]
    #[doc = "\\bt_p{*plugins}."]
    #[doc = ""]
    #[doc = "@param[in] path"]
    #[doc = "Path of the file in which to find and load all the plugins."]
    #[doc = "@param[in] fail_on_load_error"]
    #[doc = "#BT_TRUE to make this function return"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_ERROR on any plugin loading"]
    #[doc = "error instead of ignoring it."]
    #[doc = "@param[out] plugins"]
    #[doc = "<strong>On success</strong>, \\bt_p{*plugins} is a new plugin set"]
    #[doc = "reference which contains all the plugins found in the file with path"]
    #[doc = "\\bt_p{path}."]
    #[doc = ""]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_NOT_FOUND"]
    #[doc = "No plugins found."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_ERROR"]
    #[doc = "Error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{path}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{path} is the path of a regular file."]
    #[doc = "@bt_pre_not_null{plugins}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_find_all_from_dir() &mdash;"]
    #[doc = "Finds and loads all plugins from a given directory."]
    pub fn bt_plugin_find_all_from_file(
        path: *const ::std::os::raw::c_char,
        fail_on_load_error: bt_bool,
        plugins: *mut *const bt_plugin_set,
    ) -> bt_plugin_find_all_from_file_status::Type;
}
pub mod bt_plugin_find_all_from_dir_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_plugin_find_all_from_dir()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "No plugins found."]
    pub const BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_NOT_FOUND: Type = 2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Finds and loads all the plugins from the directory with path"]
    #[doc = "\\bt_p{path}, setting \\bt_p{*plugins} to the result."]
    #[doc = ""]
    #[doc = "If \\bt_p{recurse} is #BT_TRUE, this function recurses into the"]
    #[doc = "subdirectories of \\bt_p{path} to find plugins."]
    #[doc = ""]
    #[doc = "During the search process, if a found plugin shares the name of an"]
    #[doc = "already loaded plugin, this function ignores it and continues."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "As of \\bt_name_version_min_maj, the file and directory traversal"]
    #[doc = "order is undefined."]
    #[doc = ""]
    #[doc = "If any plugin loading error occurs during this function's execution, the"]
    #[doc = "function:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_TRUE</dt>"]
    #[doc = "<dd>Returns #BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_ERROR.</dd>"]
    #[doc = ""]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_FALSE</dt>"]
    #[doc = "<dd>Ignores the loading error and continues.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "If this function doesn't find any plugin, it returns"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_NOT_FOUND and does \\em not set"]
    #[doc = "\\bt_p{*plugins}."]
    #[doc = ""]
    #[doc = "@param[in] path"]
    #[doc = "Path of the directory in which to find and load all the plugins."]
    #[doc = "@param[in] recurse"]
    #[doc = "#BT_TRUE to make this function recurse into the subdirectories"]
    #[doc = "of \\bt_p{path}."]
    #[doc = "@param[in] fail_on_load_error"]
    #[doc = "#BT_TRUE to make this function return"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_ERROR on any plugin loading"]
    #[doc = "error instead of ignoring it."]
    #[doc = "@param[out] plugins"]
    #[doc = "<strong>On success</strong>, \\bt_p{*plugins} is a new plugin set"]
    #[doc = "reference which contains all the plugins found in the directory with"]
    #[doc = "path \\bt_p{path}."]
    #[doc = ""]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_NOT_FOUND"]
    #[doc = "No plugins found."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_ERROR"]
    #[doc = "Error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{path}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{path} is the path of a directory."]
    #[doc = "@bt_pre_not_null{plugins}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_find_all_from_file() &mdash;"]
    #[doc = "Finds and loads all plugins from a given file."]
    pub fn bt_plugin_find_all_from_dir(
        path: *const ::std::os::raw::c_char,
        recurse: bt_bool,
        fail_on_load_error: bt_bool,
        plugins: *mut *const bt_plugin_set,
    ) -> bt_plugin_find_all_from_dir_status::Type;
}
pub mod bt_plugin_find_all_from_static_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_plugin_find_all_from_static()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "No static plugins found."]
    pub const BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_NOT_FOUND: Type = 2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Error."]
    pub const BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Finds and loads all the static plugins,"]
    #[doc = "setting \\bt_p{*plugins} to the result."]
    #[doc = ""]
    #[doc = "A static plugin is built directly into the application or library"]
    #[doc = "instead of being a separate shared object file."]
    #[doc = ""]
    #[doc = "If any plugin loading error occurs during this function's execution, the"]
    #[doc = "function:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_TRUE</dt>"]
    #[doc = "<dd>Returns #BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_ERROR.</dd>"]
    #[doc = ""]
    #[doc = "<dt>If \\bt_p{fail_on_load_error} is #BT_FALSE</dt>"]
    #[doc = "<dd>Ignores the loading error and continues.</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "If this function doesn't find any plugin, it returns"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_NOT_FOUND and does \\em not set"]
    #[doc = "\\bt_p{*plugins}."]
    #[doc = ""]
    #[doc = "@param[in] fail_on_load_error"]
    #[doc = "#BT_TRUE to make this function return"]
    #[doc = "#BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_ERROR on any plugin loading"]
    #[doc = "error instead of ignoring it."]
    #[doc = "@param[out] plugins"]
    #[doc = "<strong>On success</strong>, \\bt_p{*plugins} is a new plugin set"]
    #[doc = "reference which contains all the static plugins."]
    #[doc = ""]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_NOT_FOUND"]
    #[doc = "No static plugins found."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_ERROR"]
    #[doc = "Error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{path}"]
    #[doc = "@bt_pre_not_null{plugins}"]
    pub fn bt_plugin_find_all_from_static(
        fail_on_load_error: bt_bool,
        plugins: *mut *const bt_plugin_set,
    ) -> bt_plugin_find_all_from_static_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_name(plugin: *const bt_plugin) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the description of the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-descr \"description\" property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get description."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Description of \\bt_p{plugin}, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_description(plugin: *const bt_plugin) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name(s) of the author(s) of the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-author \"author name(s)\" property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the author name(s)."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Author name(s) of \\bt_p{plugin}, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_author(plugin: *const bt_plugin) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the license text or the license name of the plugin"]
    #[doc = "\\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-license \"license\" property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the license."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "License of \\bt_p{plugin}, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_license(plugin: *const bt_plugin) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the path of the file which contains the plugin"]
    #[doc = "\\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-path \"path\" property."]
    #[doc = ""]
    #[doc = "This function returns \\c NULL if \\bt_p{plugin} is a static plugin"]
    #[doc = "because a static plugin has no path property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the containing file's path."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Path of the file which contains \\bt_p{plugin}, or \\c NULL if"]
    #[doc = "not available."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_path(plugin: *const bt_plugin) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the version of the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "See the \\ref api-plugin-prop-version \"version\" property."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the version."]
    #[doc = "@param[out] major"]
    #[doc = "<strong>If not \\c NULL and this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*major} is the"]
    #[doc = "major version of \\bt_p{plugin}."]
    #[doc = "@param[out] minor"]
    #[doc = "<strong>If not \\c NULL and this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*minor} is the"]
    #[doc = "minor version of \\bt_p{plugin}."]
    #[doc = "@param[out] patch"]
    #[doc = "<strong>If not \\c NULL and this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*patch} is the"]
    #[doc = "patch version of \\bt_p{plugin}."]
    #[doc = "@param[out] extra"]
    #[doc = "@parblock"]
    #[doc = "<strong>If not \\c NULL and this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*extra} is the"]
    #[doc = "version's extra information of \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "\\bt_p{*extra} can be \\c NULL if the plugin's version has no extra"]
    #[doc = "information."]
    #[doc = ""]
    #[doc = "\\bt_p{*extra} remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_AVAILABLE"]
    #[doc = "The version of \\bt_p{plugin} is available."]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE"]
    #[doc = "The version of \\bt_p{plugin} is not available."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_version(
        plugin: *const bt_plugin,
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        patch: *mut ::std::os::raw::c_uint,
        extra: *mut *const ::std::os::raw::c_char,
    ) -> bt_property_availability::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of source component classes contained in the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the number of contained source"]
    #[doc = "component classes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained source component classes in \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_source_component_class_count(plugin: *const bt_plugin) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of filter component classes contained in the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the number of contained filter"]
    #[doc = "component classes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained filter component classes in \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_filter_component_class_count(plugin: *const bt_plugin) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of sink component classes contained in the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin of which to get the number of contained sink"]
    #[doc = "component classes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained sink component classes in \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_get_sink_component_class_count(plugin: *const bt_plugin) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the source component class at index \\bt_p{index} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the source component class at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the source component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the source component class of"]
    #[doc = "\\bt_p{plugin} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of source component classes in"]
    #[doc = "\\bt_p{plugin} (as returned by"]
    #[doc = "bt_plugin_get_source_component_class_count())."]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_source_component_class_by_name_const() &mdash;"]
    #[doc = "Borrows a source component class by name from a plugin."]
    pub fn bt_plugin_borrow_source_component_class_by_index_const(
        plugin: *const bt_plugin,
        index: u64,
    ) -> *const bt_component_class_source;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the filter component class at index \\bt_p{index} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the filter component class at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the filter component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the filter component class of"]
    #[doc = "\\bt_p{plugin} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of filter component classes in"]
    #[doc = "\\bt_p{plugin} (as returned by"]
    #[doc = "bt_plugin_get_source_component_class_count())."]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_source_component_class_by_name_const() &mdash;"]
    #[doc = "Borrows a filter component class by name from a plugin."]
    pub fn bt_plugin_borrow_filter_component_class_by_index_const(
        plugin: *const bt_plugin,
        index: u64,
    ) -> *const bt_component_class_filter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the sink component class at index \\bt_p{index} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the sink component class at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the sink component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the sink component class of"]
    #[doc = "\\bt_p{plugin} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of sink component classes in"]
    #[doc = "\\bt_p{plugin} (as returned by"]
    #[doc = "bt_plugin_get_source_component_class_count())."]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_source_component_class_by_name_const() &mdash;"]
    #[doc = "Borrows a sink component class by name from a plugin."]
    pub fn bt_plugin_borrow_sink_component_class_by_index_const(
        plugin: *const bt_plugin,
        index: u64,
    ) -> *const bt_component_class_sink;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the source component class named \\bt_p{name} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "If no source component class has the name \\bt_p{name} within"]
    #[doc = "\\bt_p{plugin}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the source component class named"]
    #[doc = "\\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the source component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the source component class of"]
    #[doc = "\\bt_p{plugin} named \\bt_p{name}, or \\c NULL if no source component"]
    #[doc = "class is named \\bt_p{name} within \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_source_component_class_by_index_const() &mdash;"]
    #[doc = "Borrows a source component class by index from a plugin."]
    pub fn bt_plugin_borrow_source_component_class_by_name_const(
        plugin: *const bt_plugin,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_component_class_source;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the filter component class named \\bt_p{name} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "If no filter component class has the name \\bt_p{name} within"]
    #[doc = "\\bt_p{plugin}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the filter component class named"]
    #[doc = "\\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the filter component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the filter component class of"]
    #[doc = "\\bt_p{plugin} named \\bt_p{name}, or \\c NULL if no filter component"]
    #[doc = "class is named \\bt_p{name} within \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_filter_component_class_by_index_const() &mdash;"]
    #[doc = "Borrows a filter component class by index from a plugin."]
    pub fn bt_plugin_borrow_filter_component_class_by_name_const(
        plugin: *const bt_plugin,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_component_class_filter;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the sink component class named \\bt_p{name} from the"]
    #[doc = "plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "If no sink component class has the name \\bt_p{name} within"]
    #[doc = "\\bt_p{plugin}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "Plugin from which to borrow the sink component class named"]
    #[doc = "\\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the sink component class to borrow from \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the sink component class of"]
    #[doc = "\\bt_p{plugin} named \\bt_p{name}, or \\c NULL if no sink component"]
    #[doc = "class is named \\bt_p{name} within \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{plugin} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_borrow_sink_component_class_by_index_const() &mdash;"]
    #[doc = "Borrows a sink component class by index from a plugin."]
    pub fn bt_plugin_borrow_sink_component_class_by_name_const(
        plugin: *const bt_plugin,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_component_class_sink;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "@parblock"]
    #[doc = "Plugin of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a plugin."]
    pub fn bt_plugin_get_ref(plugin: *const bt_plugin);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the plugin \\bt_p{plugin}."]
    #[doc = ""]
    #[doc = "@param[in] plugin"]
    #[doc = "@parblock"]
    #[doc = "Plugin of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a plugin."]
    pub fn bt_plugin_put_ref(plugin: *const bt_plugin);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of plugins contained in the"]
    #[doc = "plugin set \\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@param[in] plugin_set"]
    #[doc = "Plugin set of which to get the number of contained plugins."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained plugins in \\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin}"]
    pub fn bt_plugin_set_get_plugin_count(plugin_set: *const bt_plugin_set) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the plugin at index \\bt_p{index} from the plugin set"]
    #[doc = "\\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@param[in] plugin_set"]
    #[doc = "Plugin set from which to borrow the plugin at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the plugin to borrow from \\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the plugin of \\bt_p{plugin_set} at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{plugin_set} is"]
    #[doc = "modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{plugin_set}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of plugins in"]
    #[doc = "\\bt_p{plugin_set} (as returned by bt_plugin_set_get_plugin_count())."]
    pub fn bt_plugin_set_borrow_plugin_by_index_const(
        plugin_set: *const bt_plugin_set,
        index: u64,
    ) -> *const bt_plugin;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the plugin set \\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@param[in] plugin_set"]
    #[doc = "@parblock"]
    #[doc = "Plugin set of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_set_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a plugin set."]
    pub fn bt_plugin_set_get_ref(plugin_set: *const bt_plugin_set);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the plugin set \\bt_p{plugin_set}."]
    #[doc = ""]
    #[doc = "@param[in] plugin_set"]
    #[doc = "@parblock"]
    #[doc = "Plugin set of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_plugin_set_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a plugin set."]
    pub fn bt_plugin_set_put_ref(plugin_set: *const bt_plugin_set);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default clock class from the \\bt_self_comp"]
    #[doc = "\\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "On success, the returned clock class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-freq \"Frequency\""]
    #[doc = "<td>1&nbsp;GHz"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-offset \"Offset\" in seconds"]
    #[doc = "<td>0&nbsp;seconds"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-offset \"Offset\" in cycles"]
    #[doc = "<td>0&nbsp;cycles"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-precision \"Precision\""]
    #[doc = "<td>0&nbsp;cycles"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-origin-unix-epoch \"Origin is Unix epoch?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-descr \"Description\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-uuid \"UUID\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-clock-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Self component from which to create the default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New clock class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{self_component}"]
    pub fn bt_clock_class_create(self_component: *mut bt_self_component) -> *mut bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the frequency (Hz) of the clock class \\bt_p{clock_class} to"]
    #[doc = "\\bt_p{frequency}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-freq \"frequency\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the frequency to \\bt_p{frequency}."]
    #[doc = "@param[in] frequency"]
    #[doc = "New frequency of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is not 0."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is not <code>UINT64_C(-1)</code>."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is greater than the clock class's offset in cycles"]
    #[doc = "(as returned by bt_clock_class_get_offset())."]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_frequency() &mdash;"]
    #[doc = "Returns the frequency of a clock class."]
    pub fn bt_clock_class_set_frequency(clock_class: *mut bt_clock_class, frequency: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the frequency (Hz) of the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-freq \"frequency\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the frequency."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Frequency (Hz) of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_frequency() &mdash;"]
    #[doc = "Sets the frequency of a clock class."]
    pub fn bt_clock_class_get_frequency(clock_class: *const bt_clock_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the offset of the clock class \\bt_p{clock_class} to"]
    #[doc = "\\bt_p{offset_seconds} plus \\bt_p{offset_cycles} from its"]
    #[doc = "\\ref api-tir-clock-cls-origin \"origin\"."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-offset \"offset\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the offset to \\bt_p{offset_seconds}"]
    #[doc = "and \\bt_p{offset_cycles}."]
    #[doc = "@param[in] offset_seconds"]
    #[doc = "New offset in seconds of \\bt_p{clock_class}."]
    #[doc = "@param[in] offset_cycles"]
    #[doc = "New offset in cycles of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{offset_cycles} is less than the clock class's frequency"]
    #[doc = "(as returned by bt_clock_class_get_frequency())."]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_offset() &mdash;"]
    #[doc = "Returns the offset of a clock class."]
    pub fn bt_clock_class_set_offset(
        clock_class: *mut bt_clock_class,
        offset_seconds: i64,
        offset_cycles: u64,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the offsets in seconds and cycles of the clock class"]
    #[doc = "\\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-offset \"offset\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the offset."]
    #[doc = "@param[out] offset_seconds"]
    #[doc = "When this function returns, \\bt_p{*offset_seconds} is the offset in"]
    #[doc = "seconds of"]
    #[doc = "\\bt_p{clock_class}."]
    #[doc = "@param[out] offset_cycles"]
    #[doc = "When this function returns, \\bt_p{*offset_cycles} is the offset in"]
    #[doc = "cycles of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_not_null{offset_seconds}"]
    #[doc = "@bt_pre_not_null{offset_cycles}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_offset() &mdash;"]
    #[doc = "Sets the offset of a clock class."]
    pub fn bt_clock_class_get_offset(
        clock_class: *const bt_clock_class,
        offset_seconds: *mut i64,
        offset_cycles: *mut u64,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the precision (cycles) of the clock class \\bt_p{clock_class} to"]
    #[doc = "\\bt_p{precision}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-precision \"precision\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the precision to \\bt_p{precision}."]
    #[doc = "@param[in] precision"]
    #[doc = "New precision of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_precision() &mdash;"]
    #[doc = "Returns the precision of a clock class."]
    pub fn bt_clock_class_set_precision(clock_class: *mut bt_clock_class, precision: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the precision (cycles) of the clock class"]
    #[doc = "\\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-precision \"precision\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the precision."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Precision (cycles) of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_precision() &mdash;"]
    #[doc = "Sets the precision of a clock class."]
    pub fn bt_clock_class_get_precision(clock_class: *const bt_clock_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the \\ref api-tir-clock-cls-origin \"origin\""]
    #[doc = "of the clock class \\bt_p{clock_class} is the"]
    #[doc = "<a href=\"https://en.wikipedia.org/wiki/Unix_time\">Unix epoch</a>."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-origin-unix-epoch \"origin is Unix epoch?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set whether or not its origin is the"]
    #[doc = "Unix epoch."]
    #[doc = "@param[in] origin_is_unix_epoch"]
    #[doc = "#BT_TRUE to make \\bt_p{clock_class} have a Unix epoch origin."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_origin_is_unix_epoch() &mdash;"]
    #[doc = "Returns whether or not the origin of a clock class is the"]
    #[doc = "Unix epoch."]
    pub fn bt_clock_class_set_origin_is_unix_epoch(
        clock_class: *mut bt_clock_class,
        origin_is_unix_epoch: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\ref api-tir-clock-cls-origin \"origin\""]
    #[doc = "of the clock class \\bt_p{clock_class} is the"]
    #[doc = "<a href=\"https://en.wikipedia.org/wiki/Unix_time\">Unix epoch</a>."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-origin-unix-epoch \"origin is Unix epoch?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get whether or not its origin is the"]
    #[doc = "Unix epoch."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the origin of \\bt_p{clock_class} is the Unix epoch."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_origin_is_unix_epoch() &mdash;"]
    #[doc = "Sets whether or not the origin of a clock class is the Unix epoch."]
    pub fn bt_clock_class_origin_is_unix_epoch(clock_class: *const bt_clock_class) -> bt_bool;
}
pub mod bt_clock_class_set_name_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_clock_class_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_CLOCK_CLASS_SET_NAME_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_CLOCK_CLASS_SET_NAME_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the name of the clock class \\bt_p{clock_class} to"]
    #[doc = "a copy of \\bt_p{name}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the name to \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "New name of \\bt_p{clock_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_CLOCK_CLASS_SET_NAME_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CLOCK_CLASS_SET_NAME_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_name() &mdash;"]
    #[doc = "Returns the name of a clock class."]
    pub fn bt_clock_class_set_name(
        clock_class: *mut bt_clock_class,
        name: *const ::std::os::raw::c_char,
    ) -> bt_clock_class_set_name_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{clock_class} has no name, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{clock_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{clock_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_name() &mdash;"]
    #[doc = "Sets the name of a clock class."]
    pub fn bt_clock_class_get_name(
        clock_class: *const bt_clock_class,
    ) -> *const ::std::os::raw::c_char;
}
pub mod bt_clock_class_set_description_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_clock_class_set_description()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the description of the clock class \\bt_p{clock_class} to a copy"]
    #[doc = "of \\bt_p{description}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-descr \"description\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the description to \\bt_p{description}."]
    #[doc = "@param[in] description"]
    #[doc = "New description of \\bt_p{clock_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@bt_pre_not_null{description}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_description() &mdash;"]
    #[doc = "Returns the description of a clock class."]
    pub fn bt_clock_class_set_description(
        clock_class: *mut bt_clock_class,
        description: *const ::std::os::raw::c_char,
    ) -> bt_clock_class_set_description_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the description of the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-descr \"description\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{clock_class} has no description, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the description."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Description of \\bt_p{clock_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{clock_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_description() &mdash;"]
    #[doc = "Sets the description of a clock class."]
    pub fn bt_clock_class_get_description(
        clock_class: *const bt_clock_class,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the"]
    #[doc = "<a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier\">UUID</a>"]
    #[doc = "of the clock class \\bt_p{clock_class} to a copy of \\bt_p{uuid}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-uuid \"UUID\" property."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the UUID to \\bt_p{uuid}."]
    #[doc = "@param[in] uuid"]
    #[doc = "New UUID of \\bt_p{clock_class} (copied)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@bt_pre_not_null{uuid}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_uuid() &mdash;"]
    #[doc = "Returns the UUID of a clock class."]
    pub fn bt_clock_class_set_uuid(clock_class: *mut bt_clock_class, uuid: bt_uuid);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the UUID of the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-uuid \"UUID\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{clock_class} has no UUID, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to get the UUID."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "UUID of \\bt_p{clock_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{clock_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_uuid() &mdash;"]
    #[doc = "Sets the UUID of a clock class."]
    pub fn bt_clock_class_get_uuid(clock_class: *const bt_clock_class) -> bt_uuid;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the clock class \\bt_p{clock_class} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default clock class with bt_clock_class_create(),"]
    #[doc = "the clock class's initial user attributes is an empty \\bt_map_val."]
    #[doc = "Therefore you can borrow it with"]
    #[doc = "bt_clock_class_borrow_user_attributes() and fill it directly instead"]
    #[doc = "of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_hot{clock_class}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a clock class."]
    pub fn bt_clock_class_set_user_attributes(
        clock_class: *mut bt_clock_class,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-clock-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default clock class with bt_clock_class_create(),"]
    #[doc = "the clock class's initial user attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Clock class from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{clock_class} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a clock class."]
    #[doc = "@sa bt_clock_class_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_clock_class_borrow_user_attributes(clock_class: *mut bt_clock_class)
        -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the clock class \\bt_p{clock_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_clock_class_borrow_user_attributes()."]
    pub fn bt_clock_class_borrow_user_attributes_const(
        clock_class: *const bt_clock_class,
    ) -> *const bt_value;
}
pub mod bt_clock_class_cycles_to_ns_from_origin_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_clock_class_cycles_to_ns_from_origin()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_CLOCK_CLASS_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Integer overflow while computing the result."]
    pub const BT_CLOCK_CLASS_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR: Type = -75;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Converts the stream clock value \\bt_p{value} from cycles to"]
    #[doc = "nanoseconds from the \\ref api-tir-clock-cls-origin \"origin\" of the"]
    #[doc = "clock class \\bt_p{clock_class} and sets \\bt_p{*ns_from_origin}"]
    #[doc = "to the result."]
    #[doc = ""]
    #[doc = "This function:"]
    #[doc = ""]
    #[doc = "-# Converts the"]
    #[doc = "\\link api-tir-clock-cls-prop-offset \"offset in cycles\"\\endlink"]
    #[doc = "property of \\bt_p{clock_class} to seconds using its"]
    #[doc = "\\ref api-tir-clock-cls-prop-freq \"frequency\"."]
    #[doc = "-# Converts the \\bt_p{value} value to seconds using the frequency of"]
    #[doc = "\\bt_p{clock_class}."]
    #[doc = "-# Adds the values of 1., 2., and the"]
    #[doc = "\\link api-tir-clock-cls-prop-offset \"offset in seconds\"\\endlink"]
    #[doc = "property of \\bt_p{clock_class}."]
    #[doc = "-# Converts the value of 3. to nanoseconds and sets"]
    #[doc = "\\bt_p{*ns_from_origin} to this result."]
    #[doc = ""]
    #[doc = "The following illustration shows the possible scenarios:"]
    #[doc = ""]
    #[doc = "@image html clock-terminology.png"]
    #[doc = ""]
    #[doc = "This function can fail and return the"]
    #[doc = "#BT_CLOCK_CLASS_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR status"]
    #[doc = "code if any step of the computation process causes an integer overflow."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "Stream clock's class."]
    #[doc = "@param[in] value"]
    #[doc = "Stream clock's value (cycles) to convert to nanoseconds from"]
    #[doc = "the origin of \\bt_p{clock_class}."]
    #[doc = "@param[out] ns_from_origin"]
    #[doc = "<strong>On success</strong>, \\bt_p{*ns_from_origin} is \\bt_p{value}"]
    #[doc = "converted to nanoseconds from the origin of \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR"]
    #[doc = "Integer overflow while computing the result."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = "@bt_pre_not_null{ns_from_origin}"]
    #[doc = ""]
    #[doc = "@sa bt_util_clock_cycles_to_ns_from_origin() &mdash;"]
    #[doc = "Converts a clock value from cycles to nanoseconds from the clock's"]
    #[doc = "origin."]
    pub fn bt_clock_class_cycles_to_ns_from_origin(
        clock_class: *const bt_clock_class,
        value: u64,
        ns_from_origin: *mut i64,
    ) -> bt_clock_class_cycles_to_ns_from_origin_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "@parblock"]
    #[doc = "Clock class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a clock class."]
    pub fn bt_clock_class_get_ref(clock_class: *const bt_clock_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the clock class \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "@param[in] clock_class"]
    #[doc = "@parblock"]
    #[doc = "Clock class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a clock class."]
    pub fn bt_clock_class_put_ref(clock_class: *const bt_clock_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-clock-cls \"class\" of the clock of which"]
    #[doc = "\\bt_p{clock_snapshot} is a snapshot."]
    #[doc = ""]
    #[doc = "@param[in] clock_snapshot"]
    #[doc = "Clock snapshot of which to borrow the clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the clock class of \\bt_p{clock_snapshot}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_snapshot}"]
    pub fn bt_clock_snapshot_borrow_clock_class_const(
        clock_snapshot: *const bt_clock_snapshot,
    ) -> *const bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value, in clock cycles, of the clock snapshot"]
    #[doc = "\\bt_p{clock_snapshot}."]
    #[doc = ""]
    #[doc = "@param[in] clock_snapshot"]
    #[doc = "Clock snapshot of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{clock_snapshot} (clock cycles)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_snapshot}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_snapshot_get_ns_from_origin() &mdash;"]
    #[doc = "Returns the equivalent nanoseconds from clock class origin of a"]
    #[doc = "clock snapshot's value."]
    pub fn bt_clock_snapshot_get_value(clock_snapshot: *const bt_clock_snapshot) -> u64;
}
pub mod bt_clock_snapshot_get_ns_from_origin_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_clock_snapshot_get_ns_from_origin()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Integer overflow while computing the result."]
    pub const BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR: Type = -75;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Converts the value of the clock snapshot"]
    #[doc = "\\bt_p{clock_snapshot} from cycles to nanoseconds from the"]
    #[doc = "\\ref api-tir-clock-cls-origin \"origin\" of its"]
    #[doc = "\\bt_clock_cls and sets \\bt_p{*ns_from_origin} to the result."]
    #[doc = ""]
    #[doc = "This function:"]
    #[doc = ""]
    #[doc = "-# Converts the"]
    #[doc = "\\link api-tir-clock-cls-prop-offset \"offset in cycles\"\\endlink"]
    #[doc = "property of the clock class of \\bt_p{clock_snapshot} to"]
    #[doc = "seconds using its"]
    #[doc = "\\ref api-tir-clock-cls-prop-freq \"frequency\"."]
    #[doc = "-# Converts the value of \\bt_p{clock_snapshot} to seconds using the"]
    #[doc = "frequency of its clock class."]
    #[doc = "-# Adds the values of 1., 2., and the"]
    #[doc = "\\link api-tir-clock-cls-prop-offset \"offset in seconds\"\\endlink"]
    #[doc = "property of the clock class of \\bt_p{clock_snapshot}."]
    #[doc = "-# Converts the value of 3. to nanoseconds and sets"]
    #[doc = "\\bt_p{*ns_from_origin} to this result."]
    #[doc = ""]
    #[doc = "The following illustration shows the possible scenarios:"]
    #[doc = ""]
    #[doc = "@image html clock-terminology.png"]
    #[doc = ""]
    #[doc = "This function can fail and return the"]
    #[doc = "#BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR status"]
    #[doc = "code if any step of the computation process causes an integer overflow."]
    #[doc = ""]
    #[doc = "@param[in] clock_snapshot"]
    #[doc = "Clock snapshot containing the value to convert to nanoseconds"]
    #[doc = "from the origin of its clock class."]
    #[doc = "@param[out] ns_from_origin"]
    #[doc = "<strong>On success</strong>, \\bt_p{*ns_from_origin} is the value"]
    #[doc = "of \\bt_p{clock_snapshot} converted to nanoseconds from the origin"]
    #[doc = "of its clock class."]
    #[doc = ""]
    #[doc = "@retval #BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR"]
    #[doc = "Integer overflow while computing the result."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{clock_snapshot}"]
    #[doc = "@bt_pre_not_null{ns_from_origin}"]
    #[doc = ""]
    #[doc = "@sa bt_util_clock_cycles_to_ns_from_origin() &mdash;"]
    #[doc = "Converts a clock value from cycles to nanoseconds from the clock's"]
    #[doc = "origin."]
    #[doc = "@sa bt_clock_class_cycles_to_ns_from_origin() &mdash;"]
    #[doc = "Converts a clock value from cycles to nanoseconds from a clock"]
    #[doc = "class's origin."]
    pub fn bt_clock_snapshot_get_ns_from_origin(
        clock_snapshot: *const bt_clock_snapshot,
        ns_from_origin: *mut i64,
    ) -> bt_clock_snapshot_get_ns_from_origin_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default event class and adds it to the \\bt_stream_cls"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_assigns_automatic_event_class_id(stream_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_event_class_create_with_id()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-id \"Numeric ID\""]
    #[doc = "<td>Automatically assigned by \\bt_p{stream_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-log-lvl \"Log level\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-emf-uri \"EMF URI\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-p-fc \"Payload field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-sc-fc \"Specific context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class to add the created event class to."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_assigns_automatic_event_class_id(stream_class)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_create_with_id() &mdash;"]
    #[doc = "Creates an event class with a specific numeric ID and adds it to a"]
    #[doc = "stream class."]
    pub fn bt_event_class_create(stream_class: *mut bt_stream_class) -> *mut bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default event class with the numeric ID \\bt_p{id} and adds"]
    #[doc = "it to the \\bt_stream_cls \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_assigns_automatic_event_class_id(stream_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_event_class_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned event class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-id \"Numeric ID\""]
    #[doc = "<td>\\bt_p{id}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-log-lvl \"Log level\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-emf-uri \"EMF URI\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-p-fc \"Payload field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-sc-fc \"Specific context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-ev-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class to add the created event class to."]
    #[doc = "@param[in] id"]
    #[doc = "Numeric ID of the event class to create and add to"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New event class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_assigns_automatic_event_class_id(stream_class)</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{stream_class} does not contain an event class with the numeric"]
    #[doc = "ID \\bt_p{id}."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_create() &mdash;"]
    #[doc = "Creates an event class with an automatic numeric ID and adds it to a"]
    #[doc = "stream class."]
    pub fn bt_event_class_create_with_id(
        stream_class: *mut bt_stream_class,
        id: u64,
    ) -> *mut bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls which contains the event class"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class from which to borrow the stream class which contains it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Stream class which contains \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_borrow_stream_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_class_borrow_stream_class(
        event_class: *mut bt_event_class,
    ) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls which contains the event class"]
    #[doc = "\\bt_p{event_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_class_borrow_stream_class()."]
    pub fn bt_event_class_borrow_stream_class_const(
        event_class: *const bt_event_class,
    ) -> *const bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the numeric ID of the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-id \"numeric ID\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to get the numeric ID."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Numeric ID of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_create_with_id() &mdash;"]
    #[doc = "Creates an event class with a specific numeric ID and adds it to a"]
    #[doc = "stream class."]
    pub fn bt_event_class_get_id(event_class: *const bt_event_class) -> u64;
}
pub mod bt_event_class_set_name_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_event_class_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_EVENT_CLASS_SET_NAME_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_EVENT_CLASS_SET_NAME_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the name of the event class \\bt_p{event_class} to"]
    #[doc = "a copy of \\bt_p{name}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the name to \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "New name of \\bt_p{event_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_EVENT_CLASS_SET_NAME_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_EVENT_CLASS_SET_NAME_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_get_name() &mdash;"]
    #[doc = "Returns the name of an event class."]
    pub fn bt_event_class_set_name(
        event_class: *mut bt_event_class,
        name: *const ::std::os::raw::c_char,
    ) -> bt_event_class_set_name_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{event_class} has no name, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{event_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{event_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_name() &mdash;"]
    #[doc = "Sets the name of an event class."]
    pub fn bt_event_class_get_name(
        event_class: *const bt_event_class,
    ) -> *const ::std::os::raw::c_char;
}
pub mod bt_event_class_log_level {
    #[doc = "@brief"]
    #[doc = "Event class log level enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "System is unusable."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_EMERGENCY: Type = 0;
    #[doc = "@brief"]
    #[doc = "Action must be taken immediately."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_ALERT: Type = 1;
    #[doc = "@brief"]
    #[doc = "Critical conditions."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_CRITICAL: Type = 2;
    #[doc = "@brief"]
    #[doc = "Error conditions."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_ERROR: Type = 3;
    #[doc = "@brief"]
    #[doc = "Warning conditions."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_WARNING: Type = 4;
    #[doc = "@brief"]
    #[doc = "Normal, but significant, condition."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_NOTICE: Type = 5;
    #[doc = "@brief"]
    #[doc = "Informational message."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_INFO: Type = 6;
    #[doc = "@brief"]
    #[doc = "Debugging information with system-level scope"]
    #[doc = "(set of programs)."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_SYSTEM: Type = 7;
    #[doc = "@brief"]
    #[doc = "Debugging information with program-level scope"]
    #[doc = "(set of processes)."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_PROGRAM: Type = 8;
    #[doc = "@brief"]
    #[doc = "Debugging information with process-level scope"]
    #[doc = "(set of modules)."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_PROCESS: Type = 9;
    #[doc = "@brief"]
    #[doc = "Debugging information with module (executable/library) scope"]
    #[doc = "(set of units)."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_MODULE: Type = 10;
    #[doc = "@brief"]
    #[doc = "Debugging information with compilation unit scope"]
    #[doc = "(set of functions)."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_UNIT: Type = 11;
    #[doc = "@brief"]
    #[doc = "Debugging information with function-level scope."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_FUNCTION: Type = 12;
    #[doc = "@brief"]
    #[doc = "Debugging information with function-level scope."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG_LINE: Type = 13;
    #[doc = "@brief"]
    #[doc = "Debugging-level message."]
    pub const BT_EVENT_CLASS_LOG_LEVEL_DEBUG: Type = 14;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the log level of the event class \\bt_p{event_class} to"]
    #[doc = "\\bt_p{log_level}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-log-lvl \"log level\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the log level to \\bt_p{log_level}."]
    #[doc = "@param[in] log_level"]
    #[doc = "New log level of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_get_log_level() &mdash;"]
    #[doc = "Returns the log level of an event class."]
    pub fn bt_event_class_set_log_level(
        event_class: *mut bt_event_class,
        log_level: bt_event_class_log_level::Type,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the log level of the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-log-lvl \"log level\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to get the log level."]
    #[doc = "@param[out] log_level"]
    #[doc = "<strong>If this function returns"]
    #[doc = "#BT_PROPERTY_AVAILABILITY_AVAILABLE</strong>, \\bt_p{*log_level} is"]
    #[doc = "the log level of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_AVAILABLE"]
    #[doc = "The log level of \\bt_p{event_class} is available."]
    #[doc = "@retval #BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE"]
    #[doc = "The log level of \\bt_p{event_class} is not available."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_not_null{log_level}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_log_level() &mdash;"]
    #[doc = "Sets the log level of an event class."]
    pub fn bt_event_class_get_log_level(
        event_class: *const bt_event_class,
        log_level: *mut bt_event_class_log_level::Type,
    ) -> bt_property_availability::Type;
}
pub mod bt_event_class_set_emf_uri_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_event_class_set_emf_uri()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_EVENT_CLASS_SET_EMF_URI_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_EVENT_CLASS_SET_EMF_URI_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the Eclipse Modeling Framework (EMF) URI of the event class"]
    #[doc = "\\bt_p{event_class} to a copy of \\bt_p{emf_uri}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-emf-uri \"EMF URI\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the EMF URI to \\bt_p{emf_uri}."]
    #[doc = "@param[in] emf_uri"]
    #[doc = "New EMF URI of \\bt_p{event_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_EVENT_CLASS_SET_EMF_URI_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_EVENT_CLASS_SET_EMF_URI_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = "@bt_pre_not_null{emf_uri}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_get_emf_uri() &mdash;"]
    #[doc = "Returns the EMF URI of an event class."]
    pub fn bt_event_class_set_emf_uri(
        event_class: *mut bt_event_class,
        emf_uri: *const ::std::os::raw::c_char,
    ) -> bt_event_class_set_emf_uri_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the Eclipse Modeling Framework (EMF) URI of the event"]
    #[doc = "class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-emf-uri \"EMF URI\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{event_class} has no EMF URI, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to get the EMF URI."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "EMF URI of \\bt_p{event_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{event_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_emf_uri() &mdash;"]
    #[doc = "Sets the EMF URI of an event class."]
    pub fn bt_event_class_get_emf_uri(
        event_class: *const bt_event_class,
    ) -> *const ::std::os::raw::c_char;
}
pub mod bt_event_class_set_field_class_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_event_class_set_payload_field_class() and"]
    #[doc = "bt_event_class_set_specific_context_field_class()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the payload \\bt_fc of the event class"]
    #[doc = "\\bt_p{event_class} to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-p-fc \"payload field class\" property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the payload field class to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = "@param[in] field_class"]
    #[doc = "New payload field class of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class}, or any of its contained field classes,"]
    #[doc = "is not already part of a \\bt_stream_cls or of an event class."]
    #[doc = "@pre"]
    #[doc = "If any of the field classes recursively contained in"]
    #[doc = "\\bt_p{field_class} has a"]
    #[doc = "\\ref api-tir-fc-link \"link to another field class\", it must honor"]
    #[doc = "the field class link rules."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_borrow_payload_field_class() &mdash;"]
    #[doc = "Borrows the payload field class of an event class."]
    #[doc = "@sa bt_event_class_borrow_payload_field_class_const() &mdash;"]
    #[doc = "Borrows the payload field class of an event class"]
    #[doc = "(\\c const version)."]
    pub fn bt_event_class_set_payload_field_class(
        event_class: *mut bt_event_class,
        field_class: *mut bt_field_class,
    ) -> bt_event_class_set_field_class_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the payload \\bt_fc from the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-p-fc \"payload field class\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{event_class} has no payload field class, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class from which to borrow the payload field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the payload field class of"]
    #[doc = "\\bt_p{event_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_payload_field_class() &mdash;"]
    #[doc = "Sets the payload field class of an event class."]
    #[doc = "@sa bt_event_class_borrow_payload_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_class_borrow_payload_field_class(
        event_class: *mut bt_event_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the payload \\bt_fc from the event class \\bt_p{event_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_class_borrow_payload_field_class()."]
    pub fn bt_event_class_borrow_payload_field_class_const(
        event_class: *const bt_event_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the specific context \\bt_fc of the event class"]
    #[doc = "\\bt_p{event_class} to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-sc-fc \"specific context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the specific context field class to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = "@param[in] field_class"]
    #[doc = "New specific context field class of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class}, or any of its contained field classes,"]
    #[doc = "is not already part of a \\bt_stream_cls or of an event class."]
    #[doc = "@pre"]
    #[doc = "If any of the field classes recursively contained in"]
    #[doc = "\\bt_p{field_class} has a"]
    #[doc = "\\ref api-tir-fc-link \"link to another field class\", it must honor"]
    #[doc = "the field class link rules."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_borrow_specific_context_field_class() &mdash;"]
    #[doc = "Borrows the specific context field class of an event class."]
    #[doc = "@sa bt_event_class_borrow_specific_context_field_class_const() &mdash;"]
    #[doc = "Borrows the specific context field class of an event class"]
    #[doc = "(\\c const version)."]
    pub fn bt_event_class_set_specific_context_field_class(
        event_class: *mut bt_event_class,
        field_class: *mut bt_field_class,
    ) -> bt_event_class_set_field_class_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the specific context \\bt_fc from the event class"]
    #[doc = "\\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-sc-fc \"specific context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "If \\bt_p{event_class} has no specific context field class, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class from which to borrow the specific context field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the specific context field class of"]
    #[doc = "\\bt_p{event_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_specific_context_field_class() &mdash;"]
    #[doc = "Sets the specific context field class of an event class."]
    #[doc = "@sa bt_event_class_borrow_specific_context_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_class_borrow_specific_context_field_class(
        event_class: *mut bt_event_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the specific context \\bt_fc from the event class"]
    #[doc = "\\bt_p{event_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_class_borrow_specific_context_field_class()."]
    pub fn bt_event_class_borrow_specific_context_field_class_const(
        event_class: *const bt_event_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the event class \\bt_p{event_class} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-user-attrs \"user attributes\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default event class with bt_event_class_create()"]
    #[doc = "or bt_event_class_create_with_id(), the event class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val. Therefore you can borrow it with"]
    #[doc = "bt_event_class_borrow_user_attributes() and fill it directly instead"]
    #[doc = "of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = "@bt_pre_hot{event_class}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of an event class."]
    pub fn bt_event_class_set_user_attributes(
        event_class: *mut bt_event_class,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-cls-prop-user-attrs \"user attributes\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default event class with bt_event_class_create()"]
    #[doc = "or bt_event_class_create_with_id(), the event class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "Event class from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{event_class} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event_class}"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of an event class."]
    #[doc = "@sa bt_event_class_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_class_borrow_user_attributes(event_class: *mut bt_event_class)
        -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the event class \\bt_p{event_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_class_borrow_user_attributes()."]
    pub fn bt_event_class_borrow_user_attributes_const(
        event_class: *const bt_event_class,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "@parblock"]
    #[doc = "Event class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of an event class."]
    pub fn bt_event_class_get_ref(event_class: *const bt_event_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the event class \\bt_p{event_class}."]
    #[doc = ""]
    #[doc = "@param[in] event_class"]
    #[doc = "@parblock"]
    #[doc = "Event class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_event_class_get_ref() &mdash;"]
    #[doc = "Increments the reference count of an event class."]
    pub fn bt_event_class_put_ref(event_class: *const bt_event_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-ev-cls \"class\" of the event \\bt_p{event}."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{event}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_class(event: *mut bt_event) -> *mut bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-ev-cls \"class\" of the event \\bt_p{event}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_class()."]
    pub fn bt_event_borrow_class_const(event: *const bt_event) -> *const bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream conceptually containing the event"]
    #[doc = "\\bt_p{event}."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the stream conceptually containing it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the stream conceptually containing"]
    #[doc = "\\bt_p{event}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_stream(event: *mut bt_event) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream conceptually containing the event"]
    #[doc = "\\bt_p{event} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_stream()."]
    pub fn bt_event_borrow_stream_const(event: *const bt_event) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt conceptually containing the event"]
    #[doc = "\\bt_p{event}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "Only call this function if bt_stream_class_supports_packets()"]
    #[doc = "returns #BT_TRUE for the \\bt_stream_cls of \\bt_p{event}."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the packet conceptually containing it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the packet conceptually containing"]
    #[doc = "\\bt_p{event}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_packet_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_packet(event: *mut bt_event) -> *mut bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_pkt conceptually containing the event"]
    #[doc = "\\bt_p{event} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_packet()."]
    pub fn bt_event_borrow_packet_const(event: *const bt_event) -> *const bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the payload \\bt_field of the event \\bt_p{event}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-prop-payload \"payload field\" property."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the payload field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the payload field of \\bt_p{event},"]
    #[doc = "or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_payload_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_payload_field(event: *mut bt_event) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the payload \\bt_field of the event \\bt_p{event}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_payload_field()."]
    pub fn bt_event_borrow_payload_field_const(event: *const bt_event) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the specific context \\bt_field of the event \\bt_p{event}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-prop-spec-ctx \"specific context field\" property."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the specific context field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the specific context field of"]
    #[doc = "\\bt_p{event}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_specific_context_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_specific_context_field(event: *mut bt_event) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the specific context \\bt_field of the event \\bt_p{event}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_specific_context_field()."]
    pub fn bt_event_borrow_specific_context_field_const(event: *const bt_event) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the common context \\bt_field of the event \\bt_p{event}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-ev-prop-common-ctx \"common context field\" property."]
    #[doc = ""]
    #[doc = "@param[in] event"]
    #[doc = "Event of which to borrow the common context field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the common context field of"]
    #[doc = "\\bt_p{event}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{event}"]
    #[doc = ""]
    #[doc = "@sa bt_event_borrow_specific_context_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_event_borrow_common_context_field(event: *mut bt_event) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the common context \\bt_field of the event \\bt_p{event}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_event_borrow_common_context_field()."]
    pub fn bt_event_borrow_common_context_field_const(event: *const bt_event) -> *const bt_field;
}
pub mod bt_field_class_type {
    #[doc = "@brief"]
    #[doc = "Field class type enumerators."]
    pub type Type = ::std::os::raw::c_ulong;
    #[doc = "@brief"]
    #[doc = "\\bt_c_bool_fc."]
    pub const BT_FIELD_CLASS_TYPE_BOOL: Type = 1;
    #[doc = "@brief"]
    #[doc = "\\bt_c_ba_fc."]
    pub const BT_FIELD_CLASS_TYPE_BIT_ARRAY: Type = 2;
    #[doc = "@brief"]
    #[doc = "\\bt_c_int_fc."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_INTEGER: Type = 4;
    #[doc = "@brief"]
    #[doc = "\\bt_c_uint_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_INTEGER."]
    pub const BT_FIELD_CLASS_TYPE_UNSIGNED_INTEGER: Type = 12;
    #[doc = "@brief"]
    #[doc = "\\bt_c_sint_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_INTEGER."]
    pub const BT_FIELD_CLASS_TYPE_SIGNED_INTEGER: Type = 20;
    #[doc = "@brief"]
    #[doc = "\\bt_c_enum_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_INTEGER."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_ENUMERATION: Type = 32;
    #[doc = "@brief"]
    #[doc = "\\bt_c_uenum_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_ENUMERATION"]
    #[doc = "and #BT_FIELD_CLASS_TYPE_UNSIGNED_INTEGER."]
    pub const BT_FIELD_CLASS_TYPE_UNSIGNED_ENUMERATION: Type = 44;
    #[doc = "@brief"]
    #[doc = "\\bt_c_senum_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_ENUMERATION"]
    #[doc = "and #BT_FIELD_CLASS_TYPE_SIGNED_INTEGER."]
    pub const BT_FIELD_CLASS_TYPE_SIGNED_ENUMERATION: Type = 52;
    #[doc = "@brief"]
    #[doc = "\\bt_c_real_fc."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_REAL: Type = 64;
    #[doc = "@brief"]
    #[doc = "Single-precision \\bt_real_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_REAL."]
    pub const BT_FIELD_CLASS_TYPE_SINGLE_PRECISION_REAL: Type = 192;
    #[doc = "@brief"]
    #[doc = "Double-precision \\bt_real_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_REAL."]
    pub const BT_FIELD_CLASS_TYPE_DOUBLE_PRECISION_REAL: Type = 320;
    #[doc = "@brief"]
    #[doc = "\\bt_c_string_fc.."]
    pub const BT_FIELD_CLASS_TYPE_STRING: Type = 512;
    #[doc = "@brief"]
    #[doc = "\\bt_c_struct_fc."]
    pub const BT_FIELD_CLASS_TYPE_STRUCTURE: Type = 1024;
    #[doc = "@brief"]
    #[doc = "\\bt_c_array_fc."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_ARRAY: Type = 2048;
    #[doc = "@brief"]
    #[doc = "\\bt_c_sarray_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_ARRAY."]
    pub const BT_FIELD_CLASS_TYPE_STATIC_ARRAY: Type = 6144;
    #[doc = "@brief"]
    #[doc = "\\bt_c_darray_fc."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_ARRAY."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY: Type = 10240;
    #[doc = "@brief"]
    #[doc = "\\bt_c_darray_fc (without a length field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY."]
    pub const BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY_WITHOUT_LENGTH_FIELD: Type = 26624;
    #[doc = "@brief"]
    #[doc = "\\bt_c_darray_fc (with a length field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY."]
    pub const BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY_WITH_LENGTH_FIELD: Type = 43008;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_OPTION: Type = 65536;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (without a selector field)."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITHOUT_SELECTOR_FIELD: Type = 196608;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with a selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_FIELD_CLASS_TYPE_OPTION."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITH_SELECTOR_FIELD: Type = 327680;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with a boolean selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_OPTION_WITH_SELECTOR_FIELD."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITH_BOOL_SELECTOR_FIELD: Type = 851968;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with an integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_OPTION_WITH_SELECTOR_FIELD."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITH_INTEGER_SELECTOR_FIELD: Type = 1376256;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with an unsigned integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_OPTION_WITH_INTEGER_SELECTOR_FIELD."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITH_UNSIGNED_INTEGER_SELECTOR_FIELD: Type = 3473408;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with a signed integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_OPTION_WITH_INTEGER_SELECTOR_FIELD."]
    pub const BT_FIELD_CLASS_TYPE_OPTION_WITH_SIGNED_INTEGER_SELECTOR_FIELD: Type = 5570560;
    #[doc = "@brief"]
    #[doc = "\\bt_c_var_fc."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT: Type = 8388608;
    #[doc = "@brief"]
    #[doc = "\\bt_c_var_fc (without a selector field)."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT_WITHOUT_SELECTOR_FIELD: Type = 25165824;
    #[doc = "@brief"]
    #[doc = "\\bt_c_var_fc (with a selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_VARIANT."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT_WITH_SELECTOR_FIELD: Type = 41943040;
    #[doc = "@brief"]
    #[doc = "\\bt_c_var_fc (with an integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_VARIANT_WITH_SELECTOR_FIELD."]
    #[doc = ""]
    #[doc = "No field class has this type: use it with"]
    #[doc = "bt_field_class_type_is()."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT_WITH_INTEGER_SELECTOR_FIELD: Type = 109051904;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with an unsigned integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_VARIANT_WITH_INTEGER_SELECTOR_FIELD."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT_WITH_UNSIGNED_INTEGER_SELECTOR_FIELD: Type = 243269632;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with a signed integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_VARIANT_WITH_INTEGER_SELECTOR_FIELD."]
    pub const BT_FIELD_CLASS_TYPE_VARIANT_WITH_SIGNED_INTEGER_SELECTOR_FIELD: Type = 377487360;
    #[doc = "@brief"]
    #[doc = "\\bt_c_opt_fc (with a signed integer selector field)."]
    #[doc = ""]
    #[doc = "This type conceptually inherits"]
    #[doc = "#BT_FIELD_CLASS_TYPE_VARIANT_WITH_INTEGER_SELECTOR_FIELD."]
    pub const __BT_FIELD_CLASS_TYPE_BIG_VALUE: Type = 4611686018427387904;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the field class \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Field class of which to get the type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_type_is() &mdash;"]
    #[doc = "Returns whether or not the type of a field class conceptually is a"]
    #[doc = "given type."]
    pub fn bt_field_class_get_type(field_class: *const bt_field_class)
        -> bt_field_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the field class \\bt_p{field_class} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-prop-user-attrs \"user attributes\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a field class with one of the"]
    #[doc = "<code>bt_field_class_*_create()</code> functions, the field class's"]
    #[doc = "initial user attributes is an empty \\bt_map_val. Therefore you can"]
    #[doc = "borrow it with bt_field_class_borrow_user_attributes() and fill it"]
    #[doc = "directly instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Field class of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a field class."]
    pub fn bt_field_class_set_user_attributes(
        field_class: *mut bt_field_class,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the field class \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-prop-user-attrs \"user attributes\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a field class with one of the"]
    #[doc = "<code>bt_field_class_*_create()</code> functions, the field class's"]
    #[doc = "initial user attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Field class from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{field_class} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a field class."]
    #[doc = "@sa bt_field_class_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_borrow_user_attributes(field_class: *mut bt_field_class)
        -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the field class \\bt_p{field_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_borrow_user_attributes()."]
    pub fn bt_field_class_borrow_user_attributes_const(
        field_class: *const bt_field_class,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_bool_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned boolean field class has the following"]
    #[doc = "property value:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a boolean field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New boolean field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_bool_create(trace_class: *mut bt_trace_class) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_ba_fc with the length \\bt_p{length} from the trace"]
    #[doc = "class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned bit array field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-ba-prop-len \"Length\""]
    #[doc = "<td>\\bt_p{length}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a bit array field class."]
    #[doc = "@param[in] length"]
    #[doc = "Length (number of bits) of the instances of the bit array field"]
    #[doc = "class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New bit array field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "0 < \\bt_p{length}  64."]
    pub fn bt_field_class_bit_array_create(
        trace_class: *mut bt_trace_class,
        length: u64,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the length of the \\bt_ba_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-ba-prop-len \"length\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Bit array field class of which to get the length."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_ba_fc{field_class}"]
    pub fn bt_field_class_bit_array_get_length(field_class: *const bt_field_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the field value range of the \\bt_int_fc \\bt_p{field_class}"]
    #[doc = "to \\bt_p{n}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-int-prop-size \"field value range\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Integer field class of which to set the field value range to"]
    #[doc = "\\bt_p{n}."]
    #[doc = "@param[in] n"]
    #[doc = "@parblock"]
    #[doc = "\\em N in:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>Unsigned integer field class</dt>"]
    #[doc = "<dd>[0,&nbsp;2<sup><em>N</em></sup>&nbsp;-&nbsp;1]</dd>"]
    #[doc = ""]
    #[doc = "<dt>Signed integer field class</dt>"]
    #[doc = "<dd>[-2<sup><em>N</em></sup>,&nbsp;2<sup><em>N</em></sup>&nbsp;-&nbsp;1]</dd>"]
    #[doc = "</dl>"]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_int_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{n}  64."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_integer_get_field_value_range() &mdash;"]
    #[doc = "Returns the field value range of an integer field class."]
    pub fn bt_field_class_integer_set_field_value_range(field_class: *mut bt_field_class, n: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the field value range of the \\bt_int_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-int-prop-size \"field value range\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Integer field class of which to get the field value range."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Field value range of \\bt_p{field_class}, that is, \\em N in:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>Unsigned integer field class</dt>"]
    #[doc = "<dd>[0,&nbsp;2<sup><em>N</em></sup>&nbsp;-&nbsp;1]</dd>"]
    #[doc = ""]
    #[doc = "<dt>Signed integer field class</dt>"]
    #[doc = "<dd>[-2<sup><em>N</em></sup>,&nbsp;2<sup><em>N</em></sup>&nbsp;-&nbsp;1]</dd>"]
    #[doc = "</dl>"]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_int_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_integer_set_field_value_range() &mdash;"]
    #[doc = "Sets the field value range of an integer field class."]
    pub fn bt_field_class_integer_get_field_value_range(field_class: *const bt_field_class) -> u64;
}
pub mod bt_field_class_integer_preferred_display_base {
    #[doc = "@brief"]
    #[doc = "Integer field class preferred display bases."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Binary (2)."]
    pub const BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_BINARY: Type = 2;
    #[doc = "@brief"]
    #[doc = "Octal (8)."]
    pub const BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_OCTAL: Type = 8;
    #[doc = "@brief"]
    #[doc = "Decimal (10)."]
    pub const BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL: Type = 10;
    #[doc = "@brief"]
    #[doc = "Hexadecimal (16)."]
    pub const BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_HEXADECIMAL: Type = 16;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the preferred display base of the \\bt_int_fc \\bt_p{field_class}"]
    #[doc = "to \\bt_p{preferred_display_base}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-int-prop-base \"preferred display base\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Integer field class of which to set the preferred display base to"]
    #[doc = "\\bt_p{preferred_display_base}."]
    #[doc = "@param[in] preferred_display_base"]
    #[doc = "New preferred display base of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_int_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_integer_get_preferred_display_base() &mdash;"]
    #[doc = "Returns the preferred display base of an integer field class."]
    pub fn bt_field_class_integer_set_preferred_display_base(
        field_class: *mut bt_field_class,
        preferred_display_base: bt_field_class_integer_preferred_display_base::Type,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the preferred display base of the \\bt_int_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-int-prop-base \"preferred display base\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Integer field class of which to get the preferred display base."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_BINARY"]
    #[doc = "2 (binary)"]
    #[doc = "@retval #BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_OCTAL"]
    #[doc = "8 (octal)"]
    #[doc = "@retval #BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL"]
    #[doc = "10 (decimal)"]
    #[doc = "@retval #BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_HEXADECIMAL"]
    #[doc = "16 (hexadecimal)"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_int_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_integer_set_preferred_display_base() &mdash;"]
    #[doc = "Sets the preferred display base of an integer field class."]
    pub fn bt_field_class_integer_get_preferred_display_base(
        field_class: *const bt_field_class,
    ) -> bt_field_class_integer_preferred_display_base::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_uint_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned unsigned integer field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-size \"Field value range\""]
    #[doc = "<td>[0,&nbsp;2<sup>64</sup>&nbsp;-&nbsp;1]"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-base \"Preferred display base\""]
    #[doc = "<td>#BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an unsigned integer field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New unsigned integer field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_integer_unsigned_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_sint_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned signed integer field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-size \"Field value range\""]
    #[doc = "<td>[-2<sup>63</sup>,&nbsp;2<sup>63</sup>&nbsp;-&nbsp;1]"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-base \"Preferred display base\""]
    #[doc = "<td>#BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a signed integer field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New signed integer field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_integer_signed_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a single-precision \\bt_real_fc from the trace class"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned single-precision real field class has the"]
    #[doc = "following property value:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a single-preicision real"]
    #[doc = "field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New single-precision real field class reference, or \\c NULL on"]
    #[doc = "memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_real_single_precision_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a double-precision \\bt_real_fc from the trace class"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned double-precision real field class has the"]
    #[doc = "following property value:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a double-preicision real"]
    #[doc = "field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New double-precision real field class reference, or \\c NULL on"]
    #[doc = "memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_real_double_precision_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
#[doc = "@brief"]
#[doc = "Array of \\c const \\bt_enum_fc labels."]
#[doc = ""]
#[doc = "Returned by bt_field_class_enumeration_unsigned_get_mapping_labels_for_value()"]
#[doc = "and bt_field_class_enumeration_signed_get_mapping_labels_for_value()."]
pub type bt_field_class_enumeration_mapping_label_array = *const *const ::std::os::raw::c_char;
pub mod bt_field_class_enumeration_get_mapping_labels_for_value_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "bt_field_class_enumeration_unsigned_get_mapping_labels_for_value()"]
    #[doc = "and"]
    #[doc = "bt_field_class_enumeration_signed_get_mapping_labels_for_value()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_MEMORY_ERROR: Type =
        -12;
}
pub mod bt_field_class_enumeration_add_mapping_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_field_class_enumeration_unsigned_add_mapping()"]
    #[doc = "and bt_field_class_enumeration_signed_add_mapping()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of mappings contained in the \\bt_enum_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Enumeration field class of which to get the number of contained"]
    #[doc = "mappings."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained mappings in \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_enum_fc{field_class}"]
    pub fn bt_field_class_enumeration_get_mapping_count(field_class: *const bt_field_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the label of the \\bt_enum_fc mapping \\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] mapping"]
    #[doc = "Enumeration field class mapping of which to get the label."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Label of \\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{mapping} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{mapping}"]
    pub fn bt_field_class_enumeration_mapping_get_label(
        mapping: *const bt_field_class_enumeration_mapping,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_uenum_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned unsigned enumeration field class has the"]
    #[doc = "following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-size \"Field value range\""]
    #[doc = "<td>[0,&nbsp;2<sup>64</sup>&nbsp;-&nbsp;1]"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-base \"Preferred display base\""]
    #[doc = "<td>#BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-enum-prop-mappings \"Mappings\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an unsigned enumeration field"]
    #[doc = "class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New unsigned enumeration field class reference, or \\c NULL on memory"]
    #[doc = "error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_enumeration_unsigned_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a mapping to the \\bt_uenum_fc \\bt_p{field_class} having the"]
    #[doc = "label \\bt_p{label} and the unsigned integer ranges \\bt_p{ranges}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Unsigned enumeration field class to which to add a mapping having"]
    #[doc = "the label \\bt_p{label} and the integer ranges \\bt_p{ranges}."]
    #[doc = "@param[in] label"]
    #[doc = "Label of the mapping to add to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] ranges"]
    #[doc = "Unsigned integer ranges of the mapping to add to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_uenum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{label}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no mapping with the label \\bt_p{label}."]
    #[doc = "@bt_pre_not_null{ranges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more unsigned integer ranges."]
    pub fn bt_field_class_enumeration_unsigned_add_mapping(
        field_class: *mut bt_field_class,
        label: *const ::std::os::raw::c_char,
        ranges: *const bt_integer_range_set_unsigned,
    ) -> bt_field_class_enumeration_add_mapping_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the mapping at index \\bt_p{index} from the"]
    #[doc = "\\bt_uenum_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Unsigned enumeration field class from which to borrow the mapping at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the mapping to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the mapping of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_uenum_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of mappings in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_enumeration_get_mapping_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_enumeration_get_mapping_count() &mdash;"]
    #[doc = "Returns the number of mappings contained in an"]
    #[doc = "enumeration field class."]
    pub fn bt_field_class_enumeration_unsigned_borrow_mapping_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_enumeration_unsigned_mapping;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the mapping having the label \\bt_p{label} from the"]
    #[doc = "\\bt_uenum_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "If there's no mapping having the label \\bt_p{label} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Unsigned enumeration field class from which to borrow the mapping"]
    #[doc = "having the label \\bt_p{label}."]
    #[doc = "@param[in] label"]
    #[doc = "Label of the mapping to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the mapping of"]
    #[doc = "\\bt_p{field_class} having the label \\bt_p{label}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_uenum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{label}"]
    pub fn bt_field_class_enumeration_unsigned_borrow_mapping_by_label_const(
        field_class: *const bt_field_class,
        label: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_enumeration_unsigned_mapping;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns an array of all the labels of the mappings of the"]
    #[doc = "\\bt_uenum_fc \\bt_p{field_class} of which the \\bt_p_uint_rg contain"]
    #[doc = "the integral value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "This function sets \\bt_p{*labels} to the resulting array and"]
    #[doc = "\\bt_p{*count} to the number of labels in \\bt_p{*labels}."]
    #[doc = ""]
    #[doc = "On success, if there's no mapping ranges containing the value"]
    #[doc = "\\bt_p{value}, \\bt_p{*count} is 0."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Unsigned enumeration field class from which to get the labels of the"]
    #[doc = "mappings of which the ranges contain \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "Value for which to get the mapped labels in \\bt_p{field_class}."]
    #[doc = "@param[out] labels"]
    #[doc = "@parblock"]
    #[doc = "<strong>On success</strong>, \\bt_p{*labels}"]
    #[doc = "is an array of labels of the mappings of \\bt_p{field_class}"]
    #[doc = "containing \\bt_p{value}."]
    #[doc = ""]
    #[doc = "The number of labels in \\bt_p{*labels} is \\bt_p{*count}."]
    #[doc = ""]
    #[doc = "The array is owned by \\bt_p{field_class} and remains valid as long"]
    #[doc = "as:"]
    #[doc = ""]
    #[doc = "- \\bt_p{field_class} is not modified."]
    #[doc = "- You don't call this function again with \\bt_p{field_class}."]
    #[doc = "@endparblock"]
    #[doc = "@param[out] count"]
    #[doc = "<strong>On success</strong>, \\bt_p{*count} is the number of labels"]
    #[doc = "in \\bt_p{*labels} (can be 0)."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_uenum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{labels}"]
    #[doc = "@bt_pre_not_null{count}"]
    pub fn bt_field_class_enumeration_unsigned_get_mapping_labels_for_value(
        field_class: *const bt_field_class,
        value: u64,
        labels: *mut bt_field_class_enumeration_mapping_label_array,
        count: *mut u64,
    ) -> bt_field_class_enumeration_get_mapping_labels_for_value_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_uint_rg from the \\bt_uenum_fc mapping"]
    #[doc = "\\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] mapping"]
    #[doc = "Unsigned enumeration field class mapping from which to borrow the"]
    #[doc = "unsigned integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Unsigned integer ranges of \\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{mapping}"]
    pub fn bt_field_class_enumeration_unsigned_mapping_borrow_ranges_const(
        mapping: *const bt_field_class_enumeration_unsigned_mapping,
    ) -> *const bt_integer_range_set_unsigned;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_senum_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned signed enumeration field class has the"]
    #[doc = "following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-size \"Field value range\""]
    #[doc = "<td>[-2<sup>63</sup>,&nbsp;2<sup>63</sup>&nbsp;-&nbsp;1]"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-int-prop-base \"Preferred display base\""]
    #[doc = "<td>#BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-enum-prop-mappings \"Mappings\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a signed enumeration field"]
    #[doc = "class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New signed enumeration field class reference, or \\c NULL on memory"]
    #[doc = "error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_enumeration_signed_create(
        trace_class: *mut bt_trace_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a mapping to the \\bt_senum_fc \\bt_p{field_class} having the"]
    #[doc = "label \\bt_p{label} and the \\bt_p_sint_rg \\bt_p{ranges}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Signed enumeration field class to which to add a mapping having"]
    #[doc = "the label \\bt_p{label} and the integer ranges \\bt_p{ranges}."]
    #[doc = "@param[in] label"]
    #[doc = "Label of the mapping to add to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] ranges"]
    #[doc = "Signed integer ranges of the mapping to add to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_senum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{label}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no mapping with the label \\bt_p{label}."]
    #[doc = "@bt_pre_not_null{ranges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more signed integer ranges."]
    pub fn bt_field_class_enumeration_signed_add_mapping(
        field_class: *mut bt_field_class,
        label: *const ::std::os::raw::c_char,
        ranges: *const bt_integer_range_set_signed,
    ) -> bt_field_class_enumeration_add_mapping_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the mapping at index \\bt_p{index} from the"]
    #[doc = "\\bt_senum_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Signed enumeration field class from which to borrow the mapping at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the mapping to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the mapping of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_senum_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of mappings in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_enumeration_get_mapping_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_enumeration_get_mapping_count() &mdash;"]
    #[doc = "Returns the number of mappings contained in an"]
    #[doc = "enumeration field class."]
    pub fn bt_field_class_enumeration_signed_borrow_mapping_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_enumeration_signed_mapping;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the mapping having the label \\bt_p{label} from the"]
    #[doc = "\\bt_senum_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "If there's no mapping having the label \\bt_p{label} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Signed enumeration field class from which to borrow the mapping"]
    #[doc = "having the label \\bt_p{label}."]
    #[doc = "@param[in] label"]
    #[doc = "Label of the mapping to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the mapping of"]
    #[doc = "\\bt_p{field_class} having the label \\bt_p{label}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_senum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{label}"]
    pub fn bt_field_class_enumeration_signed_borrow_mapping_by_label_const(
        field_class: *const bt_field_class,
        label: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_enumeration_signed_mapping;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns an array of all the labels of the mappings of the"]
    #[doc = "\\bt_senum_fc \\bt_p{field_class} of which the \\bt_p_sint_rg contain"]
    #[doc = "the integral value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "This function sets \\bt_p{*labels} to the resulting array and"]
    #[doc = "\\bt_p{*count} to the number of labels in \\bt_p{*labels}."]
    #[doc = ""]
    #[doc = "On success, if there's no mapping ranges containing the value"]
    #[doc = "\\bt_p{value}, \\bt_p{*count} is 0."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Signed enumeration field class from which to get the labels of the"]
    #[doc = "mappings of which the ranges contain \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "Value for which to get the mapped labels in \\bt_p{field_class}."]
    #[doc = "@param[out] labels"]
    #[doc = "@parblock"]
    #[doc = "<strong>On success</strong>, \\bt_p{*labels}"]
    #[doc = "is an array of labels of the mappings of \\bt_p{field_class}"]
    #[doc = "containing \\bt_p{value}."]
    #[doc = ""]
    #[doc = "The number of labels in \\bt_p{*labels} is \\bt_p{*count}."]
    #[doc = ""]
    #[doc = "The array is owned by \\bt_p{field_class} and remains valid as long"]
    #[doc = "as:"]
    #[doc = ""]
    #[doc = "- \\bt_p{field_class} is not modified."]
    #[doc = "- You don't call this function again with \\bt_p{field_class}."]
    #[doc = "@endparblock"]
    #[doc = "@param[out] count"]
    #[doc = "<strong>On success</strong>, \\bt_p{*count} is the number of labels"]
    #[doc = "in \\bt_p{*labels} (can be 0)."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_senum_fc{field_class}"]
    #[doc = "@bt_pre_not_null{labels}"]
    #[doc = "@bt_pre_not_null{count}"]
    pub fn bt_field_class_enumeration_signed_get_mapping_labels_for_value(
        field_class: *const bt_field_class,
        value: i64,
        labels: *mut bt_field_class_enumeration_mapping_label_array,
        count: *mut u64,
    ) -> bt_field_class_enumeration_get_mapping_labels_for_value_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_sint_rg from the \\bt_senum_fc mapping"]
    #[doc = "\\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-enum-prop-mappings \"mappings\" property."]
    #[doc = ""]
    #[doc = "@param[in] mapping"]
    #[doc = "Signed enumeration field class mapping from which to borrow the"]
    #[doc = "signed integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Signed integer ranges of \\bt_p{mapping}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{mapping}"]
    pub fn bt_field_class_enumeration_signed_mapping_borrow_ranges_const(
        mapping: *const bt_field_class_enumeration_signed_mapping,
    ) -> *const bt_integer_range_set_signed;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_string_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned string field class has the following property"]
    #[doc = "value:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a string field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New string field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_string_create(trace_class: *mut bt_trace_class) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the element field class from the \\bt_array_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-array-prop-elem-fc \"element field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Array field class from which to borrow the element field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Element field class of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_array_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_array_borrow_element_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_array_borrow_element_field_class(
        field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the element field class from the \\bt_array_fc"]
    #[doc = "\\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_array_borrow_element_field_class()."]
    pub fn bt_field_class_array_borrow_element_field_class_const(
        field_class: *const bt_field_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_sarray_fc having the element field class"]
    #[doc = "\\bt_p{element_field_class} and the length \\bt_p{length} from the"]
    #[doc = "trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned static array field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-array-prop-elem-fc \"Element field class\""]
    #[doc = "<td>\\bt_p{element_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-sarray-prop-len \"Length\""]
    #[doc = "<td>\\bt_p{length}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a static array field class."]
    #[doc = "@param[in] element_field_class"]
    #[doc = "Class of the element fields of the instances of the static array"]
    #[doc = "field class to create."]
    #[doc = "@param[in] length"]
    #[doc = "Length of the instances of the static array field class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New static array field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{element_field_class}"]
    #[doc = "bt_pre_fc_not_in_tc{element_field_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{element_field_class}"]
    pub fn bt_field_class_array_static_create(
        trace_class: *mut bt_trace_class,
        element_field_class: *mut bt_field_class,
        length: u64,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the length of the \\bt_sarray_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-sarray-prop-len \"length\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Static array field class of which to get the length."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_sarray_fc{field_class}"]
    pub fn bt_field_class_array_static_get_length(field_class: *const bt_field_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_darray_fc having the element field class"]
    #[doc = "\\bt_p{element_field_class} from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "If \\bt_p{length_field_class} is not \\c NULL, then the created dynamic"]
    #[doc = "array field class has a linked length field class."]
    #[doc = "See"]
    #[doc = "\\ref api-tir-fc-link \"Field classes with links to other field classes\""]
    #[doc = "to learn more."]
    #[doc = ""]
    #[doc = "On success, the returned dynamic array field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-array-prop-elem-fc \"Element field class\""]
    #[doc = "<td>\\bt_p{element_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-darray-prop-len-fp \"Length field path\""]
    #[doc = "<td>"]
    #[doc = "\\em None (if \\bt_p{length_field_class} is not \\c NULL, this"]
    #[doc = "property becomes available when the returned field class becomes"]
    #[doc = "part of an \\bt_ev_cls or of a \\bt_stream_cls)"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a dynamic array field class."]
    #[doc = "@param[in] element_field_class"]
    #[doc = "Class of the element fields of the instances of the dynamic array"]
    #[doc = "field class to create."]
    #[doc = "@param[in] length_field_class"]
    #[doc = "@parblock"]
    #[doc = "Linked length field class of the dynamic array field class to"]
    #[doc = "create."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New dynamic array field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{element_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{element_field_class}"]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{length_field_class} is not \\c NULL</strong>,"]
    #[doc = "\\bt_p{length_field_class} is an \\bt_uint_fc."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{element_field_class}"]
    #[doc = "@bt_post_success_frozen{length_field_class}"]
    pub fn bt_field_class_array_dynamic_create(
        trace_class: *mut bt_trace_class,
        element_field_class: *mut bt_field_class,
        length_field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the length field path from the \\bt_darray_fc (with a length"]
    #[doc = "field) \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-darray-prop-len-fp \"length field path\" property."]
    #[doc = ""]
    #[doc = "This property is only available when a \\bt_struct_fc containing"]
    #[doc = "(recursively) \\bt_p{field_class} is passed to one of:"]
    #[doc = ""]
    #[doc = "- bt_stream_class_set_packet_context_field_class()"]
    #[doc = "- bt_stream_class_set_event_common_context_field_class()"]
    #[doc = "- bt_event_class_set_specific_context_field_class()"]
    #[doc = "- bt_event_class_set_payload_field_class()"]
    #[doc = ""]
    #[doc = "In the meantime, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Dynamic array field class from which to borrow the length"]
    #[doc = "field path."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length field path of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_darray_wl_fc{field_class}"]
    pub fn bt_field_class_array_dynamic_with_length_field_borrow_length_field_path_const(
        field_class: *const bt_field_class,
    ) -> *const bt_field_path;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_struct_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned structure field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-struct-prop-members \"Members\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a structure field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New structure field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_field_class_structure_create(trace_class: *mut bt_trace_class)
        -> *mut bt_field_class;
}
pub mod bt_field_class_structure_append_member_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_field_class_structure_append_member()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends a member to the \\bt_struct_fc \\bt_p{field_class} having the"]
    #[doc = "name \\bt_p{name} and the field class \\bt_p{member_field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Structure field class to which to append a member having"]
    #[doc = "the name \\bt_p{name} and the field class \\bt_p{member_field_class}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the member to append to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] member_field_class"]
    #[doc = "Field class of the member to append to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no member with the name \\bt_p{name}."]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{member_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{member_field_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{member_field_class}"]
    pub fn bt_field_class_structure_append_member(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
        member_field_class: *mut bt_field_class,
    ) -> bt_field_class_structure_append_member_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of members contained in the \\bt_struct_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Structure field class of which to get the number of contained"]
    #[doc = "members."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained members in \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    pub fn bt_field_class_structure_get_member_count(field_class: *const bt_field_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the member at index \\bt_p{index} from the"]
    #[doc = "\\bt_struct_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Structure field class from which to borrow the member at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the member to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the member of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of members in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_structure_get_member_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_structure_get_member_count() &mdash;"]
    #[doc = "Returns the number of members contained in a structure field class."]
    #[doc = "@sa bt_field_class_structure_borrow_member_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_structure_borrow_member_by_index(
        field_class: *mut bt_field_class,
        index: u64,
    ) -> *mut bt_field_class_structure_member;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the member at index \\bt_p{index} from the"]
    #[doc = "\\bt_struct_fc \\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_structure_borrow_member_by_index()."]
    pub fn bt_field_class_structure_borrow_member_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_structure_member;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the member having the name \\bt_p{name} from the"]
    #[doc = "\\bt_struct_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "If there's no member having the name \\bt_p{name} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Structure field class from which to borrow the member having the"]
    #[doc = "name \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the member to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the member of"]
    #[doc = "\\bt_p{field_class} having the name \\bt_p{name}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_structure_borrow_member_by_name_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_structure_borrow_member_by_name(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_field_class_structure_member;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the member having the name \\bt_p{name} from the"]
    #[doc = "\\bt_struct_fc \\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_structure_borrow_member_by_name()."]
    pub fn bt_field_class_structure_borrow_member_by_name_const(
        field_class: *const bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_structure_member;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_struct_fc member \\bt_p{member}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@param[in] member"]
    #[doc = "Structure field class member of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{member}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{member} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{member}"]
    pub fn bt_field_class_structure_member_get_name(
        member: *const bt_field_class_structure_member,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field class from the \\bt_struct_fc member"]
    #[doc = "\\bt_p{member}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@param[in] member"]
    #[doc = "Structure field class member from which to borrow the field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Field class of \\bt_p{member}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{member}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_structure_member_borrow_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_structure_member_borrow_field_class(
        member: *mut bt_field_class_structure_member,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field class from the \\bt_struct_fc member"]
    #[doc = "\\bt_p{member} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_structure_member_borrow_field_class()."]
    pub fn bt_field_class_structure_member_borrow_field_class_const(
        member: *const bt_field_class_structure_member,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the \\bt_struct_fc member \\bt_p{member}"]
    #[doc = "to \\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you append a member to a structure field class with"]
    #[doc = "bt_field_class_structure_append_member(), the member's"]
    #[doc = "initial user attributes is an empty \\bt_map_val. Therefore you can"]
    #[doc = "borrow it with"]
    #[doc = "bt_field_class_structure_member_borrow_user_attributes() and fill it"]
    #[doc = "directly instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] member"]
    #[doc = "Structure field class member of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{member}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{member}"]
    #[doc = "@bt_pre_hot{member}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_structure_member_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a structure field class member."]
    pub fn bt_field_class_structure_member_set_user_attributes(
        member: *mut bt_field_class_structure_member,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the \\bt_struct_fc member"]
    #[doc = "\\bt_p{member}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-struct-prop-members \"members\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you append a member to a structure field class with"]
    #[doc = "bt_field_class_structure_append_member(), the member's"]
    #[doc = "initial user attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] member"]
    #[doc = "Structure field class member from which to borrow the user"]
    #[doc = "attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{member} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{member}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_structure_member_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a structure field class member."]
    #[doc = "@sa bt_field_class_structure_member_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_structure_member_borrow_user_attributes(
        member: *mut bt_field_class_structure_member,
    ) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the \\bt_struct_fc member"]
    #[doc = "\\bt_p{member} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_structure_member_borrow_user_attributes()."]
    pub fn bt_field_class_structure_member_borrow_user_attributes_const(
        member: *const bt_field_class_structure_member,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the optional field class from the \\bt_opt_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-opt-prop-fc \"optional field class\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class from which to borrow the optional field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Optional field class of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_opt_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_option_borrow_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_option_borrow_field_class(
        field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the optional field class from the \\bt_opt_fc"]
    #[doc = "\\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_option_borrow_field_class()."]
    pub fn bt_field_class_option_borrow_field_class_const(
        field_class: *const bt_field_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_opt_fc (without a selector field) having the optional"]
    #[doc = "field class \\bt_p{optional_field_class} from the trace class"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned option field class has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-fc \"Optional field class\""]
    #[doc = "<td>\\bt_p{optional_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an option field class."]
    #[doc = "@param[in] optional_field_class"]
    #[doc = "Class of the optional fields of the instances of the option field"]
    #[doc = "class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New option field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{optional_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{optional_field_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{optional_field_class}"]
    pub fn bt_field_class_option_without_selector_create(
        trace_class: *mut bt_trace_class,
        optional_field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the selector field path from the \\bt_opt_fc (with a selector"]
    #[doc = "field) \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-opt-prop-sel-fp \"selector field path\" property."]
    #[doc = ""]
    #[doc = "This property is only available when a \\bt_struct_fc containing"]
    #[doc = "(recursively) \\bt_p{field_class} is passed to one of:"]
    #[doc = ""]
    #[doc = "- bt_stream_class_set_packet_context_field_class()"]
    #[doc = "- bt_stream_class_set_event_common_context_field_class()"]
    #[doc = "- bt_event_class_set_specific_context_field_class()"]
    #[doc = "- bt_event_class_set_payload_field_class()"]
    #[doc = ""]
    #[doc = "In the meantime, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class from which to borrow the selector field path."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Selector field path of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_opt_ws_fc{field_class}"]
    pub fn bt_field_class_option_with_selector_field_borrow_selector_field_path_const(
        field_class: *const bt_field_class,
    ) -> *const bt_field_path;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_opt_fc (with a boolean selector field) having the"]
    #[doc = "optional field class \\bt_p{optional_field_class} from the trace"]
    #[doc = "class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned option field class has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-fc \"Optional field class\""]
    #[doc = "<td>\\bt_p{optional_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-sel-fp \"Selector field path\""]
    #[doc = "<td>"]
    #[doc = "\\em None (this property becomes available when the returned field"]
    #[doc = "class becomes part of an \\bt_ev_cls or of a \\bt_stream_cls)"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-sel-rev \"Selector is reversed?\""]
    #[doc = "<td>#BT_FALSE"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an option field class."]
    #[doc = "@param[in] optional_field_class"]
    #[doc = "Class of the optional fields of the instances of the option field"]
    #[doc = "class to create."]
    #[doc = "@param[in] selector_field_class"]
    #[doc = "Linked selector field class of the option field class to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New option field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{optional_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{optional_field_class}"]
    #[doc = "@bt_pre_not_null{selector_field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{selector_field_class} is a \\bt_bool_fc."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{optional_field_class}"]
    #[doc = "@bt_post_success_frozen{selector_field_class}"]
    pub fn bt_field_class_option_with_selector_field_bool_create(
        trace_class: *mut bt_trace_class,
        optional_field_class: *mut bt_field_class,
        selector_field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the selector of the \\bt_opt_fc (with a boolean"]
    #[doc = "selector field) \\bt_p{field_class} is reversed."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-opt-prop-sel-rev \"selector is reversed?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class of which to set whether or not its selector"]
    #[doc = "is reversed."]
    #[doc = "@param[in] selector_is_reversed"]
    #[doc = "#BT_TRUE to make \\bt_p{field_class} have a reversed selector."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_opt_wbs_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_option_with_selector_field_bool_selector_is_reversed() &mdash;"]
    #[doc = "Returns whether or not the selector of an option field class (with"]
    #[doc = "a boolean selector field) is reversed."]
    pub fn bt_field_class_option_with_selector_field_bool_set_selector_is_reversed(
        field_class: *mut bt_field_class,
        selector_is_reversed: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the selector of the"]
    #[doc = "\\bt_opt_fc (with a boolean selector field) is reversed."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-opt-prop-sel-rev \"selector is reversed?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class of which to get whether or not its selector is"]
    #[doc = "reversed."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the selector of \\bt_p{field_class} is reversed."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_opt_wbs_fc{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_option_with_selector_field_bool_set_selector_is_reversed() &mdash;"]
    #[doc = "Sets whether or not the selector of an option field class (with"]
    #[doc = "a boolean selector field) is reversed."]
    pub fn bt_field_class_option_with_selector_field_bool_selector_is_reversed(
        field_class: *const bt_field_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_opt_fc (with an unsigned integer selector field)"]
    #[doc = "having the optional field class \\bt_p{optional_field_class} from the"]
    #[doc = "trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned option field class has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-fc \"Optional field class\""]
    #[doc = "<td>\\bt_p{optional_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-sel-fp \"Selector field path\""]
    #[doc = "<td>"]
    #[doc = "\\em None (this property becomes available when the returned field"]
    #[doc = "class becomes part of an \\bt_ev_cls or of a \\bt_stream_cls)"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-uint-rs \"Selector's unsigned integer ranges\""]
    #[doc = "<td>\\bt_p{ranges}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an option field class."]
    #[doc = "@param[in] optional_field_class"]
    #[doc = "Class of the optional fields of the instances of the option field"]
    #[doc = "class to create."]
    #[doc = "@param[in] selector_field_class"]
    #[doc = "Linked selector field class of the option field class to create."]
    #[doc = "@param[in] ranges"]
    #[doc = "Selector's unsigned integer ranges of the option field class to"]
    #[doc = "create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New option field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{optional_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{optional_field_class}"]
    #[doc = "@bt_pre_not_null{selector_field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{selector_field_class} is a \\bt_uint_fc."]
    #[doc = "@bt_pre_not_null{ranges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more \\bt_p_uint_rg."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{optional_field_class}"]
    #[doc = "@bt_post_success_frozen{selector_field_class}"]
    #[doc = "@bt_post_success_frozen{ranges}"]
    pub fn bt_field_class_option_with_selector_field_integer_unsigned_create(
        trace_class: *mut bt_trace_class,
        optional_field_class: *mut bt_field_class,
        selector_field_class: *mut bt_field_class,
        ranges: *const bt_integer_range_set_unsigned,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_uint_rg from the \\bt_opt_fc (with an unsigned"]
    #[doc = "integer selector field) \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-fc-opt-prop-uint-rs \"selector's unsigned integer ranges\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class from which to borrow the unsigned integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Unsigned integer ranges of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_opt_wuis_fc{field_class}"]
    pub fn bt_field_class_option_with_selector_field_integer_unsigned_borrow_selector_ranges_const(
        field_class: *const bt_field_class,
    ) -> *const bt_integer_range_set_unsigned;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an \\bt_opt_fc (with a signed integer selector field)"]
    #[doc = "having the optional field class \\bt_p{optional_field_class} from the"]
    #[doc = "trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned option field class has the following property"]
    #[doc = "values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-fc \"Optional field class\""]
    #[doc = "<td>\\bt_p{optional_field_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-sel-fp \"Selector field path\""]
    #[doc = "<td>"]
    #[doc = "\\em None (this property becomes available when the returned field"]
    #[doc = "class becomes part of an \\bt_ev_cls or of a \\bt_stream_cls)"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-opt-prop-sint-rs \"Selector's signed integer ranges\""]
    #[doc = "<td>\\bt_p{ranges}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create an option field class."]
    #[doc = "@param[in] optional_field_class"]
    #[doc = "Class of the optional fields of the instances of the option field"]
    #[doc = "class to create."]
    #[doc = "@param[in] selector_field_class"]
    #[doc = "Linked selector field class of the option field class to create."]
    #[doc = "@param[in] ranges"]
    #[doc = "Selector's signed integer ranges of the option field class to"]
    #[doc = "create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New option field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{optional_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{optional_field_class}"]
    #[doc = "@bt_pre_not_null{selector_field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{selector_field_class} is a \\bt_uint_fc."]
    #[doc = "@bt_pre_not_null{ranges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more \\bt_p_uint_rg."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{optional_field_class}"]
    #[doc = "@bt_post_success_frozen{selector_field_class}"]
    #[doc = "@bt_post_success_frozen{ranges}"]
    pub fn bt_field_class_option_with_selector_field_integer_signed_create(
        trace_class: *mut bt_trace_class,
        optional_field_class: *mut bt_field_class,
        selector_field_class: *mut bt_field_class,
        ranges: *const bt_integer_range_set_signed,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_sint_rg from the \\bt_opt_fc (with a signed"]
    #[doc = "integer selector field) \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-fc-opt-prop-sint-rs \"selector's signed integer ranges\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Option field class from which to borrow the signed integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Signed integer ranges of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_opt_wsis_fc{field_class}"]
    pub fn bt_field_class_option_with_selector_field_integer_signed_borrow_selector_ranges_const(
        field_class: *const bt_field_class,
    ) -> *const bt_integer_range_set_signed;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a \\bt_var_fc from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "If \\bt_p{selector_field_class} is not \\c NULL, then the created variant"]
    #[doc = "field class has a linked selector field class."]
    #[doc = "See"]
    #[doc = "\\ref api-tir-fc-link \"Field classes with links to other field classes\""]
    #[doc = "to learn more."]
    #[doc = ""]
    #[doc = "On success, the returned variant field class has the following"]
    #[doc = "property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-var-prop-sel-fp \"Selector field path\""]
    #[doc = "<td>"]
    #[doc = "\\em None (if \\bt_p{selector_field_class} is not \\c NULL, this"]
    #[doc = "property becomes available when the returned field class becomes"]
    #[doc = "part of an \\bt_ev_cls or of a \\bt_stream_cls)"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-var-prop-opts \"Options\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-fc-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create a variant field class."]
    #[doc = "@param[in] selector_field_class"]
    #[doc = "@parblock"]
    #[doc = "Linked selector field class of the variant field class to create."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New variant field class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{selector_field_class} is not \\c NULL</strong>,"]
    #[doc = "\\bt_p{selector_field_class} is an \\bt_int_fc."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{element_field_class}"]
    #[doc = "@bt_post_success_frozen{selector_field_class}"]
    pub fn bt_field_class_variant_create(
        trace_class: *mut bt_trace_class,
        selector_field_class: *mut bt_field_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of options contained in the \\bt_var_fc"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class of which to get the number of contained"]
    #[doc = "options."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained options in \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_fc{field_class}"]
    pub fn bt_field_class_variant_get_option_count(field_class: *const bt_field_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option at index \\bt_p{index} from the"]
    #[doc = "\\bt_var_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of options in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_variant_get_option_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_get_option_count() &mdash;"]
    #[doc = "Returns the number of options contained in a variant field class."]
    #[doc = "@sa bt_field_class_variant_borrow_option_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_variant_borrow_option_by_index(
        field_class: *mut bt_field_class,
        index: u64,
    ) -> *mut bt_field_class_variant_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option at index \\bt_p{index} from the"]
    #[doc = "\\bt_var_fc \\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_variant_borrow_option_by_index()."]
    pub fn bt_field_class_variant_borrow_option_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_variant_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option having the name \\bt_p{name} from the"]
    #[doc = "\\bt_var_fc \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "If there's no option having the name \\bt_p{name} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option having the"]
    #[doc = "name \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} having the name \\bt_p{name}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_fc{field_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_borrow_option_by_name_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_variant_borrow_option_by_name(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_field_class_variant_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option having the name \\bt_p{name} from the"]
    #[doc = "\\bt_var_fc \\bt_p{field_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_variant_borrow_option_by_name()."]
    pub fn bt_field_class_variant_borrow_option_by_name_const(
        field_class: *const bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_variant_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the \\bt_var_fc option \\bt_p{option}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{option}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{option} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    pub fn bt_field_class_variant_option_get_name(
        option: *const bt_field_class_variant_option,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field class from the \\bt_var_fc option"]
    #[doc = "\\bt_p{option}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option from which to borrow the field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Field class of \\bt_p{option}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_option_borrow_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_variant_option_borrow_field_class(
        option: *mut bt_field_class_variant_option,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field class from the \\bt_var_fc option"]
    #[doc = "\\bt_p{option} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_variant_option_borrow_field_class()."]
    pub fn bt_field_class_variant_option_borrow_field_class_const(
        option: *const bt_field_class_variant_option,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the \\bt_var_fc option \\bt_p{option}"]
    #[doc = "to \\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you append an option to a variant field class with"]
    #[doc = "bt_field_class_variant_without_selector_append_option(),"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_unsigned_append_option(),"]
    #[doc = "or"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_signed_append_option(),"]
    #[doc = "the option's initial user attributes is an empty \\bt_map_val."]
    #[doc = "Therefore you can borrow it with"]
    #[doc = "bt_field_class_variant_option_borrow_user_attributes() and fill it"]
    #[doc = "directly instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{option}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    #[doc = "@bt_pre_hot{option}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_option_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a variant field class option."]
    pub fn bt_field_class_variant_option_set_user_attributes(
        option: *mut bt_field_class_variant_option,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the \\bt_var_fc option \\bt_p{option}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you append an option to a variant field class with"]
    #[doc = "bt_field_class_variant_without_selector_append_option(),"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_unsigned_append_option(),"]
    #[doc = "or"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_signed_append_option(),"]
    #[doc = "the option's initial user attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option from which to borrow the user"]
    #[doc = "attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{option} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_option_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a variant field class option."]
    #[doc = "@sa bt_field_class_variant_option_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_class_variant_option_borrow_user_attributes(
        option: *mut bt_field_class_variant_option,
    ) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the \\bt_var_fc option \\bt_p{option}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_class_variant_option_borrow_user_attributes()."]
    pub fn bt_field_class_variant_option_borrow_user_attributes_const(
        option: *const bt_field_class_variant_option,
    ) -> *const bt_value;
}
pub mod bt_field_class_variant_without_selector_append_option_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "bt_field_class_variant_without_selector_append_option()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR:
        Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an option to the \\bt_var_fc (without a selector field)"]
    #[doc = "\\bt_p{field_class} having the name \\bt_p{name} and the"]
    #[doc = "field class \\bt_p{option_field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class to which to append an option having"]
    #[doc = "the name \\bt_p{name} and the field class \\bt_p{option_field_class}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to append to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] option_field_class"]
    #[doc = "Field class of the option to append to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_var_wos_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no option with the name \\bt_p{name}."]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{option_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{option_field_class}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{option_field_class}"]
    pub fn bt_field_class_variant_without_selector_append_option(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
        option_field_class: *mut bt_field_class,
    ) -> bt_field_class_variant_without_selector_append_option_status::Type;
}
pub mod bt_field_class_variant_with_selector_field_integer_append_option_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_unsigned_append_option()"]
    #[doc = "and"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_signed_append_option()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR: Type =
        -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the selector field path from the \\bt_var_fc (with a selector"]
    #[doc = "field) \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-sel-fp \"selector field path\" property."]
    #[doc = ""]
    #[doc = "This property is only available when a \\bt_struct_fc containing"]
    #[doc = "(recursively) \\bt_p{field_class} is passed to one of:"]
    #[doc = ""]
    #[doc = "- bt_stream_class_set_packet_context_field_class()"]
    #[doc = "- bt_stream_class_set_event_common_context_field_class()"]
    #[doc = "- bt_event_class_set_specific_context_field_class()"]
    #[doc = "- bt_event_class_set_payload_field_class()"]
    #[doc = ""]
    #[doc = "In the meantime, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the selector field path."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Selector field path of \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_ws_fc{field_class}"]
    pub fn bt_field_class_variant_with_selector_field_borrow_selector_field_path_const(
        field_class: *const bt_field_class,
    ) -> *const bt_field_path;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an option to the \\bt_var_fc (with an unsigned integer"]
    #[doc = "selector field) \\bt_p{field_class} having the name \\bt_p{name},"]
    #[doc = "the field class \\bt_p{option_field_class}, and the"]
    #[doc = "\\bt_p_uint_rg \\bt_p{ranges}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class to which to append an option having"]
    #[doc = "the name \\bt_p{name}, the field class \\bt_p{option_field_class},"]
    #[doc = "and the unsigned integer ranges \\bt_p{ranges}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to append to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] option_field_class"]
    #[doc = "Field class of the option to append to \\bt_p{field_class}."]
    #[doc = "@param[in] ranges"]
    #[doc = "Unsigned integer ranges of the option to append to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_var_wuis_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no option with the name \\bt_p{name}."]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{option_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{option_field_class}"]
    #[doc = "@bt_pre_not_null{anges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more unsigned integer ranges."]
    #[doc = "@pre"]
    #[doc = "The unsigned integer ranges in \\bt_p{ranges} do not overlap"]
    #[doc = "any unsigned integer range of any existing option in"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{option_field_class}"]
    pub fn bt_field_class_variant_with_selector_field_integer_unsigned_append_option(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
        option_field_class: *mut bt_field_class,
        ranges: *const bt_integer_range_set_unsigned,
    ) -> bt_field_class_variant_with_selector_field_integer_append_option_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option at index \\bt_p{index} from the"]
    #[doc = "\\bt_var_fc (with an unsigned integer selector field)"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_wuis_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of options in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_variant_get_option_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_get_option_count() &mdash;"]
    #[doc = "Returns the number of options contained in a variant field class."]
    pub fn bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_variant_with_selector_field_integer_unsigned_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option having the name \\bt_p{name} from the"]
    #[doc = "\\bt_var_fc (with an unsigned integer selector field)"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "If there's no option having the name \\bt_p{name} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option having the"]
    #[doc = "name \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} having the name \\bt_p{name}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_wuis_fc{field_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_borrow_option_by_name_const() &mdash;"]
    #[doc = "Borrows an option by name from a variant field class."]
    pub fn bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_name_const(
        field_class: *const bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_variant_with_selector_field_integer_unsigned_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_uint_rg from the \\bt_var_fc (with an unsigned"]
    #[doc = "integer selector field) option \\bt_p{option}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option from which to borrow the"]
    #[doc = "unsigned integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Unsigned integer ranges of \\bt_p{option}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    pub fn bt_field_class_variant_with_selector_field_integer_unsigned_option_borrow_ranges_const(
        option: *const bt_field_class_variant_with_selector_field_integer_unsigned_option,
    ) -> *const bt_integer_range_set_unsigned;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends an option to the \\bt_var_fc (with a signed integer"]
    #[doc = "selector field) \\bt_p{field_class} having the name \\bt_p{name},"]
    #[doc = "the field class \\bt_p{option_field_class}, and the"]
    #[doc = "\\bt_p_sint_rg \\bt_p{ranges}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class to which to append an option having"]
    #[doc = "the name \\bt_p{name} and the field class \\bt_p{option_field_class},"]
    #[doc = "and the signed integer ranges \\bt_p{ranges}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to append to \\bt_p{field_class} (copied)."]
    #[doc = "@param[in] option_field_class"]
    #[doc = "Field class of the option to append to \\bt_p{field_class}."]
    #[doc = "@param[in] ranges"]
    #[doc = "Signed integer ranges of the option to append to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_hot{field_class}"]
    #[doc = "@bt_pre_is_var_wsis_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class} has no option with the name \\bt_p{name}."]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{option_field_class}"]
    #[doc = "@bt_pre_fc_not_in_tc{option_field_class}"]
    #[doc = "@bt_pre_not_null{anges}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{ranges} contains one or more signed integer ranges."]
    #[doc = "@pre"]
    #[doc = "The signed integer ranges in \\bt_p{ranges} do not overlap with"]
    #[doc = "any signed integer range of any existing option in"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{option_field_class}"]
    pub fn bt_field_class_variant_with_selector_field_integer_signed_append_option(
        field_class: *mut bt_field_class,
        name: *const ::std::os::raw::c_char,
        option_field_class: *mut bt_field_class,
        ranges: *const bt_integer_range_set_signed,
    ) -> bt_field_class_variant_with_selector_field_integer_append_option_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option at index \\bt_p{index} from the"]
    #[doc = "\\bt_var_fc (with a signed integer selector field)"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_wsis_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of options in"]
    #[doc = "\\bt_p{field_class} (as returned by"]
    #[doc = "bt_field_class_variant_get_option_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_get_option_count() &mdash;"]
    #[doc = "Returns the number of options contained in a variant field class."]
    pub fn bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_index_const(
        field_class: *const bt_field_class,
        index: u64,
    ) -> *const bt_field_class_variant_with_selector_field_integer_signed_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the option having the name \\bt_p{name} from the"]
    #[doc = "\\bt_var_fc (with a signed integer selector field)"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "If there's no option having the name \\bt_p{name} in"]
    #[doc = "\\bt_p{field_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "Variant field class from which to borrow the option having the"]
    #[doc = "name \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the option to borrow from \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the option of"]
    #[doc = "\\bt_p{field_class} having the name \\bt_p{name}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_var_wsis_fc{field_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_variant_borrow_option_by_name_const() &mdash;"]
    #[doc = "Borrows an option by name from a variant field class."]
    pub fn bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_name_const(
        field_class: *const bt_field_class,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_field_class_variant_with_selector_field_integer_signed_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_p_sint_rg from the \\bt_var_fc (with a signed"]
    #[doc = "integer selector field) option \\bt_p{option}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-fc-var-prop-opts \"options\" property."]
    #[doc = ""]
    #[doc = "@param[in] option"]
    #[doc = "Variant field class option from which to borrow the"]
    #[doc = "signed integer ranges."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Signed integer ranges of \\bt_p{option}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{option}"]
    pub fn bt_field_class_variant_with_selector_field_integer_signed_option_borrow_ranges_const(
        option: *const bt_field_class_variant_with_selector_field_integer_signed_option,
    ) -> *const bt_integer_range_set_signed;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the field class \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "@parblock"]
    #[doc = "Field class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a field class."]
    pub fn bt_field_class_get_ref(field_class: *const bt_field_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the field class \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "@param[in] field_class"]
    #[doc = "@parblock"]
    #[doc = "Field class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a field class."]
    pub fn bt_field_class_put_ref(field_class: *const bt_field_class);
}
pub mod bt_field_path_scope {
    #[doc = "@brief"]
    #[doc = "Field path scopes."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Packet context."]
    pub const BT_FIELD_PATH_SCOPE_PACKET_CONTEXT: Type = 0;
    #[doc = "@brief"]
    #[doc = "Event common context."]
    pub const BT_FIELD_PATH_SCOPE_EVENT_COMMON_CONTEXT: Type = 1;
    #[doc = "@brief"]
    #[doc = "Event specific context."]
    pub const BT_FIELD_PATH_SCOPE_EVENT_SPECIFIC_CONTEXT: Type = 2;
    #[doc = "@brief"]
    #[doc = "Event payload."]
    pub const BT_FIELD_PATH_SCOPE_EVENT_PAYLOAD: Type = 3;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the root scope of the field path \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-field-path-prop-root \"root scope\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_path"]
    #[doc = "Field path of which to get the root scope."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Root scope of \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_path}"]
    pub fn bt_field_path_get_root_scope(
        field_path: *const bt_field_path,
    ) -> bt_field_path_scope::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of items contained in the field path"]
    #[doc = "\\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-field-path-prop-items \"items\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_path"]
    #[doc = "Field path of which to get the number of contained items."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained items in \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_path}"]
    pub fn bt_field_path_get_item_count(field_path: *const bt_field_path) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the item at index \\bt_p{index} from the"]
    #[doc = "field path \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-field-path-prop-items \"items\" property."]
    #[doc = ""]
    #[doc = "@param[in] field_path"]
    #[doc = "Field path from which to borrow the item at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the item to borrow from \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the item of"]
    #[doc = "\\bt_p{field_path} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field_path}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field_path}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of items in"]
    #[doc = "\\bt_p{field_path} (as returned by bt_field_path_get_item_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_path_get_item_count() &mdash;"]
    #[doc = "Returns the number of items contained in a field path."]
    pub fn bt_field_path_borrow_item_by_index_const(
        field_path: *const bt_field_path,
        index: u64,
    ) -> *const bt_field_path_item;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the field path \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "@param[in] field_path"]
    #[doc = "@parblock"]
    #[doc = "Field path of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_field_path_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a field path."]
    pub fn bt_field_path_get_ref(field_path: *const bt_field_path);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the field path \\bt_p{field_path}."]
    #[doc = ""]
    #[doc = "@param[in] field_path"]
    #[doc = "@parblock"]
    #[doc = "Field path of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_field_path_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a field path."]
    pub fn bt_field_path_put_ref(field_path: *const bt_field_path);
}
pub mod bt_field_path_item_type {
    #[doc = "@brief"]
    #[doc = "Field path item type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Index of a \\bt_struct_field member or selected \\bt_var_field"]
    #[doc = "option's field."]
    pub const BT_FIELD_PATH_ITEM_TYPE_INDEX: Type = 1;
    #[doc = "@brief"]
    #[doc = "Common field of an \\bt_array_field."]
    pub const BT_FIELD_PATH_ITEM_TYPE_CURRENT_ARRAY_ELEMENT: Type = 2;
    #[doc = "@brief"]
    #[doc = "Current field of an \\bt_opt_field."]
    pub const BT_FIELD_PATH_ITEM_TYPE_CURRENT_OPTION_CONTENT: Type = 4;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the field path item"]
    #[doc = "\\bt_p{item}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-field-path-prop-items \"items\" property."]
    #[doc = ""]
    #[doc = "@param[in] item"]
    #[doc = "Field path item of which to get the type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{item}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{item}"]
    pub fn bt_field_path_item_get_type(
        item: *const bt_field_path_item,
    ) -> bt_field_path_item_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the index value of the index field path item"]
    #[doc = "\\bt_p{item}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-field-path-prop-items \"items\" property."]
    #[doc = ""]
    #[doc = "@param[in] item"]
    #[doc = "Index field path item of which to get the index value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Index value of \\bt_p{item}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{item}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{item} is an index field path item"]
    #[doc = "(bt_field_path_item_get_type() returns"]
    #[doc = "#BT_FIELD_PATH_ITEM_TYPE_INDEX)."]
    pub fn bt_field_path_item_index_get_index(item: *const bt_field_path_item) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the \\ref api-tir-fc \"class\" of the"]
    #[doc = "field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_field_class_get_type(bt_field_borrow_class(field))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Field of which to get the class's type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of the class of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_class_get_type() &mdash;"]
    #[doc = "Returns the type enumerator of a \\bt_fc."]
    pub fn bt_field_get_class_type(field: *const bt_field) -> bt_field_class_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-fc \"class\" of the field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Field of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_borrow_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_borrow_class(field: *mut bt_field) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-fc \"class\" of the field \\bt_p{field}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_borrow_class()."]
    pub fn bt_field_borrow_class_const(field: *const bt_field) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_bool_field \\bt_p{field} to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Boolean field of which to set the value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_bool_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_bool_get_value() &mdash;"]
    #[doc = "Returns the value of a boolean field."]
    pub fn bt_field_bool_set_value(field: *mut bt_field, value: bt_bool);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_bool_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Boolean field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_bool_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_bool_set_value() &mdash;"]
    #[doc = "Sets the value of a boolean field."]
    pub fn bt_field_bool_get_value(field: *const bt_field) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the bits of the \\bt_ba_field \\bt_p{field} to the bits of"]
    #[doc = "\\bt_p{bits}."]
    #[doc = ""]
    #[doc = "The least significant bit's index is 0."]
    #[doc = ""]
    #[doc = "See \\bt_c_ba_field to learn more."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Bit array field of which to set the bits to \\bt_p{bits}."]
    #[doc = "@param[in] bits"]
    #[doc = "New bits of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_ba_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_bit_array_get_value_as_integer() &mdash;"]
    #[doc = "Returns the bits of a bit array field as an integer."]
    pub fn bt_field_bit_array_set_value_as_integer(field: *mut bt_field, bits: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the bits of the \\bt_ba_field \\bt_p{field} as an"]
    #[doc = "unsigned integer."]
    #[doc = ""]
    #[doc = "The least significant bit's index is 0."]
    #[doc = ""]
    #[doc = "See \\bt_c_ba_field to learn more."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Bit array field of which to get the bits."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Bits of \\bt_p{field} as an unsigned integer."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_ba_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_bit_array_set_value_as_integer() &mdash;"]
    #[doc = "Sets the bits of a bit array field from an integer."]
    pub fn bt_field_bit_array_get_value_as_integer(field: *const bt_field) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_uint_field \\bt_p{field} to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Unsigned integer field of which to set the value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_uint_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{value} is within the"]
    #[doc = "\\ref api-tir-fc-int-prop-size \"field value range\" of the"]
    #[doc = "class of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@sa bt_field_integer_unsigned_get_value() &mdash;"]
    #[doc = "Returns the value of an unsigned integer field."]
    pub fn bt_field_integer_unsigned_set_value(field: *mut bt_field, value: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_uint_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Unsigned integer field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_uint_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_integer_unsigned_set_value() &mdash;"]
    #[doc = "Sets the value of an unsigned integer field."]
    pub fn bt_field_integer_unsigned_get_value(field: *const bt_field) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_sint_field \\bt_p{field} to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Signed integer field of which to set the value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_sint_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{value} is within the"]
    #[doc = "\\ref api-tir-fc-int-prop-size \"field value range\" of the"]
    #[doc = "class of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@sa bt_field_integer_signed_get_value() &mdash;"]
    #[doc = "Returns the value of an signed integer field."]
    pub fn bt_field_integer_signed_set_value(field: *mut bt_field, value: i64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_sint_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Signed integer field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_sint_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_integer_signed_set_value() &mdash;"]
    #[doc = "Sets the value of an signed integer field."]
    pub fn bt_field_integer_signed_get_value(field: *const bt_field) -> i64;
}
pub mod bt_field_enumeration_get_mapping_labels_status {
    #[doc = "@brief"]
    #[doc = "Status codes for"]
    #[doc = "bt_field_enumeration_unsigned_get_mapping_labels() and"]
    #[doc = "bt_field_enumeration_signed_get_mapping_labels()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns an array of all the labels of the mappings of the"]
    #[doc = "\\ref api-tir-fc-enum \"class\" of the \\bt_uenum_field \\bt_p{field}"]
    #[doc = "of which the \\bt_p_uint_rg contain the integral value"]
    #[doc = "of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "(bt_field_enumeration_get_mapping_labels_status)"]
    #[doc = "bt_field_class_enumeration_unsigned_get_mapping_labels_for_value("]
    #[doc = "bt_field_borrow_class_const(field),"]
    #[doc = "bt_field_integer_unsigned_get_value(field),"]
    #[doc = "labels, count)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Unsigned enumeration field having the class from which to get the"]
    #[doc = "labels of the mappings of which the ranges contain its"]
    #[doc = "integral value."]
    #[doc = "@param[out] labels"]
    #[doc = "See"]
    #[doc = "bt_field_class_enumeration_unsigned_get_mapping_labels_for_value()."]
    #[doc = "@param[out] count"]
    #[doc = "See"]
    #[doc = "bt_field_class_enumeration_unsigned_get_mapping_labels_for_value()."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_uenum_field{field}"]
    #[doc = "@bt_pre_not_null{labels}"]
    #[doc = "@bt_pre_not_null{count}"]
    pub fn bt_field_enumeration_unsigned_get_mapping_labels(
        field: *const bt_field,
        labels: *mut bt_field_class_enumeration_mapping_label_array,
        count: *mut u64,
    ) -> bt_field_enumeration_get_mapping_labels_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns an array of all the labels of the mappings of the"]
    #[doc = "\\ref api-tir-fc-enum \"class\" of the \\bt_senum_field \\bt_p{field}"]
    #[doc = "of which the \\bt_p_sint_rg contain the integral value"]
    #[doc = "of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "(bt_field_enumeration_get_mapping_labels_status)"]
    #[doc = "bt_field_class_enumeration_signed_get_mapping_labels_for_value("]
    #[doc = "bt_field_borrow_class_const(field),"]
    #[doc = "bt_field_integer_signed_get_value(field),"]
    #[doc = "labels, count)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Signed enumeration field having the class from which to get the"]
    #[doc = "labels of the mappings of which the ranges contain its"]
    #[doc = "integral value."]
    #[doc = "@param[out] labels"]
    #[doc = "See"]
    #[doc = "bt_field_class_enumeration_signed_get_mapping_labels_for_value()."]
    #[doc = "@param[out] count"]
    #[doc = "See"]
    #[doc = "bt_field_class_enumeration_signed_get_mapping_labels_for_value()."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_senum_field{field}"]
    #[doc = "@bt_pre_not_null{labels}"]
    #[doc = "@bt_pre_not_null{count}"]
    pub fn bt_field_enumeration_signed_get_mapping_labels(
        field: *const bt_field,
        labels: *mut bt_field_class_enumeration_mapping_label_array,
        count: *mut u64,
    ) -> bt_field_enumeration_get_mapping_labels_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_sreal_field \\bt_p{field} to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Single-precision real field of which to set the value to"]
    #[doc = "\\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_sreal_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_real_single_precision_get_value() &mdash;"]
    #[doc = "Returns the value of a single-precision real field."]
    pub fn bt_field_real_single_precision_set_value(field: *mut bt_field, value: f32);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_sreal_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Single-precision real field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_sreal_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_real_single_precision_set_value() &mdash;"]
    #[doc = "Sets the value of a single-precision real field."]
    pub fn bt_field_real_single_precision_get_value(field: *const bt_field) -> f32;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_dreal_field \\bt_p{field} to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Double-precision real field of which to set the value to"]
    #[doc = "\\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_dreal_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_real_double_precision_get_value() &mdash;"]
    #[doc = "Returns the value of a double-precision real field."]
    pub fn bt_field_real_double_precision_set_value(field: *mut bt_field, value: f64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_dreal_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Double-precision real field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_dreal_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_real_double_precision_set_value() &mdash;"]
    #[doc = "Sets the value of a double-precision real field."]
    pub fn bt_field_real_double_precision_get_value(field: *const bt_field) -> f64;
}
pub mod bt_field_string_set_value_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_field_string_set_value()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_STRING_SET_VALUE_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_STRING_SET_VALUE_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the \\bt_string_field \\bt_p{field} to"]
    #[doc = "a copy of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field of which to set the value to \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "New value of \\bt_p{field} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_STRING_SET_VALUE_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_STRING_SET_VALUE_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_field_string_get_value() &mdash;"]
    #[doc = "Returns the value of a string field."]
    #[doc = "@sa bt_field_string_append() &mdash;"]
    #[doc = "Appends a string to a string field."]
    #[doc = "@sa bt_field_string_clear() &mdash;"]
    #[doc = "Clears a string field."]
    pub fn bt_field_string_set_value(
        field: *mut bt_field,
        value: *const ::std::os::raw::c_char,
    ) -> bt_field_string_set_value_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the length of the \\bt_string_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field of which to get the length."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    pub fn bt_field_string_get_length(field: *const bt_field) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the value of the \\bt_string_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field of which to get the value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Value of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{field} is modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_string_set_value() &mdash;"]
    #[doc = "Sets the value of a string field."]
    pub fn bt_field_string_get_value(field: *const bt_field) -> *const ::std::os::raw::c_char;
}
pub mod bt_field_string_append_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_field_string_append() and"]
    #[doc = "bt_field_string_append_with_length()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_STRING_APPEND_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_STRING_APPEND_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends a copy of the string \\bt_p{value} to the current value of"]
    #[doc = "the \\bt_string_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "If you didn't set the value of \\bt_p{field} yet, you must call"]
    #[doc = "bt_field_string_clear() before you call this function."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field to which to append the string \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "String to append to \\bt_p{field} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_STRING_APPEND_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_STRING_APPEND_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_field_string_append_with_length() &mdash;"]
    #[doc = "Appends a string with a given length to a string field."]
    #[doc = "@sa bt_field_string_set_value() &mdash;"]
    #[doc = "Sets the value of a string field."]
    pub fn bt_field_string_append(
        field: *mut bt_field,
        value: *const ::std::os::raw::c_char,
    ) -> bt_field_string_append_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends a copy of the first \\bt_p{length} bytes of the string"]
    #[doc = "\\bt_p{value} to the current value of the \\bt_string_field"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "If you didn't set the value of \\bt_p{field} yet, you must call"]
    #[doc = "bt_field_string_clear() before you call this function."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field to which to append the first \\bt_p{length} bytes of"]
    #[doc = "the string \\bt_p{value}."]
    #[doc = "@param[in] value"]
    #[doc = "String of which to append the first \\bt_p{length} bytes to"]
    #[doc = "\\bt_p{field} (copied)."]
    #[doc = "@param[in] length"]
    #[doc = "Number of bytes of \\bt_p{value} to append to \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_STRING_APPEND_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_STRING_APPEND_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_field_string_append() &mdash;"]
    #[doc = "Appends a string to a string field."]
    #[doc = "@sa bt_field_string_set_value() &mdash;"]
    #[doc = "Sets the value of a string field."]
    pub fn bt_field_string_append_with_length(
        field: *mut bt_field,
        value: *const ::std::os::raw::c_char,
        length: u64,
    ) -> bt_field_string_append_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Clears the \\bt_string_field \\bt_p{field}, making its value an empty"]
    #[doc = "string."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "String field to clear."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_string_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_string_set_value() &mdash;"]
    #[doc = "Sets the value of a string field."]
    pub fn bt_field_string_clear(field: *mut bt_field);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the length of the \\bt_array_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Array field of which to get the length."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_array_field{field}"]
    pub fn bt_field_array_get_length(field: *const bt_field) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field at index \\bt_p{index} from the \\bt_array_field"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "If \\bt_p{field} is a dynamic array field, it must have a length"]
    #[doc = "(call bt_field_array_dynamic_set_length()) before you call this"]
    #[doc = "function."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Array field from which to borrow the field at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the field to borrow from \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the field of \\bt_p{field} at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_array_field{field}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the length of \\bt_p{field} (as returned by"]
    #[doc = "bt_field_array_get_length())."]
    #[doc = ""]
    #[doc = "@sa bt_field_array_borrow_element_field_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_array_borrow_element_field_by_index(
        field: *mut bt_field,
        index: u64,
    ) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field at index \\bt_p{index} from the \\bt_array_field"]
    #[doc = "\\bt_p{field} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_array_borrow_element_field_by_index()."]
    pub fn bt_field_array_borrow_element_field_by_index_const(
        field: *const bt_field,
        index: u64,
    ) -> *const bt_field;
}
pub mod bt_field_array_dynamic_set_length_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_field_array_dynamic_set_length()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the length of the \\bt_darray_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Dynamic array field of which to set the length."]
    #[doc = "@param[in] length"]
    #[doc = "New length of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_darray_field{field}"]
    #[doc = "@bt_pre_hot{field}"]
    pub fn bt_field_array_dynamic_set_length(
        field: *mut bt_field,
        length: u64,
    ) -> bt_field_array_dynamic_set_length_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the member at index \\bt_p{index} from the"]
    #[doc = "\\bt_struct_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Structure field from which to borrow the field of the member at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the member containing the field to borrow from"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the field of the member of \\bt_p{field} at"]
    #[doc = "index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_struct_field{field}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of members in the"]
    #[doc = "\\ref api-tir-fc-struct \"class\" of \\bt_p{field} (as"]
    #[doc = "returned by bt_field_class_structure_get_member_count())."]
    #[doc = ""]
    #[doc = "@sa bt_field_structure_borrow_member_field_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_structure_borrow_member_field_by_index(
        field: *mut bt_field,
        index: u64,
    ) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the member at index \\bt_p{index} from the"]
    #[doc = "\\bt_struct_field \\bt_p{field} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_structure_borrow_member_field_by_index()."]
    pub fn bt_field_structure_borrow_member_field_by_index_const(
        field: *const bt_field,
        index: u64,
    ) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the member having the name \\bt_p{name} from the"]
    #[doc = "\\bt_struct_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "If there's no member having the name \\bt_p{name} in the"]
    #[doc = "\\ref api-tir-fc-struct \"class\" of \\bt_p{field}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Structure field from which to borrow the field of the member having"]
    #[doc = "the name \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the member containing the field to borrow from \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the field of the member of \\bt_p{field}"]
    #[doc = "having the name \\bt_p{name}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_struct_field{field}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_field_structure_borrow_member_field_by_name_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_structure_borrow_member_field_by_name(
        field: *mut bt_field,
        name: *const ::std::os::raw::c_char,
    ) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the member having the name \\bt_p{name} from the"]
    #[doc = "\\bt_struct_field \\bt_p{field} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_structure_borrow_member_field_by_name()."]
    pub fn bt_field_structure_borrow_member_field_by_name_const(
        field: *const bt_field,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the \\bt_opt_field \\bt_p{field}"]
    #[doc = "has a field."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Option field of which to set whether or not it has a field."]
    #[doc = "@param[in] has_field"]
    #[doc = "#BT_TRUE to make \\bt_p{field} have a field."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_opt_field{field}"]
    pub fn bt_field_option_set_has_field(field: *mut bt_field, has_field: bt_bool);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the \\bt_opt_field \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You must call bt_field_option_set_has_field() before you call"]
    #[doc = "this function."]
    #[doc = ""]
    #[doc = "If \\bt_p{field} has no field, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Option field from which to borrow the field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the field of \\bt_p{field},"]
    #[doc = "or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_opt_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_option_set_has_field() &mdash;"]
    #[doc = "Sets whether or not an option field has a field."]
    #[doc = "@sa bt_field_option_borrow_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_option_borrow_field(field: *mut bt_field) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the \\bt_opt_field \\bt_p{field}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_option_borrow_field()."]
    pub fn bt_field_option_borrow_field_const(field: *const bt_field) -> *const bt_field;
}
pub mod bt_field_variant_select_option_by_index_status {
    #[doc = "@brief"]
    #[doc = "Status code for bt_field_variant_select_option_by_index()."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_FIELD_VARIANT_SELECT_OPTION_STATUS_OK: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the selected option of the \\bt_var_field \\bt_p{field}"]
    #[doc = "to the option at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field of which to set the selected option."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the option to set as the selected option of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@retval #BT_FIELD_VARIANT_SELECT_OPTION_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_field{field}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of options in the"]
    #[doc = "\\ref api-tir-fc-var \"class\" of \\bt_p{field} (as"]
    #[doc = "returned by bt_field_class_variant_get_option_count())."]
    pub fn bt_field_variant_select_option_by_index(
        field: *mut bt_field,
        index: u64,
    ) -> bt_field_variant_select_option_by_index_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the selected option of the \\bt_var_field"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You must call bt_field_variant_select_option_by_index() before"]
    #[doc = "you call this function."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field from which to borrow the selected option's field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the field of the selected option of"]
    #[doc = "\\bt_p{field}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{field} exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_variant_select_option_by_index() &mdash;"]
    #[doc = "Sets a variant field's selected option."]
    #[doc = "@sa bt_field_variant_get_selected_option_index() &mdash;"]
    #[doc = "Returns the index of a variant field's selected option."]
    #[doc = "@sa bt_field_variant_borrow_selected_option_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_field_variant_borrow_selected_option_field(field: *mut bt_field) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the field of the selected option of the \\bt_var_field"]
    #[doc = "\\bt_p{field} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_field_variant_borrow_selected_option_field()."]
    pub fn bt_field_variant_borrow_selected_option_field_const(
        field: *const bt_field,
    ) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the index of the selected option of the \\bt_var_field"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field of which to get the index of the selected option."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Index of the selected option of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_field{field}"]
    #[doc = ""]
    #[doc = "@sa bt_field_variant_borrow_selected_option_field_const() &mdash;"]
    #[doc = "Borrows the field of a variant field's selected option."]
    pub fn bt_field_variant_get_selected_option_index(field: *const bt_field) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the class of the selected option of the \\bt_var_field"]
    #[doc = "\\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_field_class_variant_borrow_option_by_index("]
    #[doc = "bt_field_variant_get_selected_option_index(field))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field of which to get the selected option's class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Class of the selected option of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_field{field}"]
    pub fn bt_field_variant_borrow_selected_option_class_const(
        field: *const bt_field,
    ) -> *const bt_field_class_variant_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the class of the selected option of the \\bt_var_field"]
    #[doc = "(with an unsigned integer selector field) \\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_index_const("]
    #[doc = "bt_field_variant_get_selected_option_index(field))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field of which to get the selected option's class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Class of the selected option of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_wuis_field{field}"]
    pub fn bt_field_variant_with_selector_field_integer_unsigned_borrow_selected_option_class_const(
        field: *const bt_field,
    ) -> *const bt_field_class_variant_with_selector_field_integer_unsigned_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the class of the selected option of the \\bt_var_field"]
    #[doc = "(with a signed integer selector field) \\bt_p{field}."]
    #[doc = ""]
    #[doc = "This function returns"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_index_const("]
    #[doc = "bt_field_variant_get_selected_option_index(field))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] field"]
    #[doc = "Variant field of which to get the selected option's class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Class of the selected option of \\bt_p{field}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{field}"]
    #[doc = "@bt_pre_is_var_wsis_field{field}"]
    pub fn bt_field_variant_with_selector_field_integer_signed_borrow_selected_option_class_const(
        field: *const bt_field,
    ) -> *const bt_field_class_variant_with_selector_field_integer_signed_option;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a packet for the \\bt_stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned packet has the following property value:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-pkt-prop-ctx \"Context field\""]
    #[doc = "<td>"]
    #[doc = "Unset instance of the"]
    #[doc = "\\ref api-tir-stream-cls-prop-pc-fc \"packet context field class\" of"]
    #[doc = "the \\ref api-tir-stream-cls \"class\" of \\bt_p{stream}."]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream for which to create the packet."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New packet reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(bt_stream_borrow_class_const(stream))</code>"]
    #[doc = "returns #BT_TRUE."]
    pub fn bt_packet_create(stream: *const bt_stream) -> *mut bt_packet;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream conceptually containing the packet"]
    #[doc = "\\bt_p{packet}."]
    #[doc = ""]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which to borrow the stream conceptually containing it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the stream conceptually containing"]
    #[doc = "\\bt_p{packet}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = ""]
    #[doc = "@sa bt_packet_borrow_stream_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_packet_borrow_stream(packet: *mut bt_packet) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream conceptually containing the packet"]
    #[doc = "\\bt_p{packet} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_packet_borrow_stream()."]
    pub fn bt_packet_borrow_stream_const(packet: *const bt_packet) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the context \\bt_field of the packet \\bt_p{packet}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-pkt-prop-ctx \"context field\" property."]
    #[doc = ""]
    #[doc = "@param[in] packet"]
    #[doc = "Packet of which to borrow the context field."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the context field of"]
    #[doc = "\\bt_p{packet}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{packet}"]
    #[doc = ""]
    #[doc = "@sa bt_packet_borrow_context_field_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_packet_borrow_context_field(packet: *mut bt_packet) -> *mut bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the context \\bt_field of the packet \\bt_p{packet}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_packet_borrow_context_field()."]
    pub fn bt_packet_borrow_context_field_const(packet: *const bt_packet) -> *const bt_field;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the packet \\bt_p{packet}."]
    #[doc = ""]
    #[doc = "@param[in] packet"]
    #[doc = "@parblock"]
    #[doc = "Packet of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_packet_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a packet."]
    pub fn bt_packet_get_ref(packet: *const bt_packet);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the packet \\bt_p{packet}."]
    #[doc = ""]
    #[doc = "@param[in] packet"]
    #[doc = "@parblock"]
    #[doc = "Packet of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_packet_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a packet."]
    pub fn bt_packet_put_ref(packet: *const bt_packet);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default stream class and adds it to the \\bt_trace_cls"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_trace_class_assigns_automatic_stream_class_id(trace_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_stream_class_create_with_id()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned stream class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-id \"Numeric ID\""]
    #[doc = "<td>Automatically assigned by \\bt_p{trace_class}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-def-clock-cls \"Default clock class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pc-fc \"Packet context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-ecc-fc \"Event common context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-auto-ec-id \"Assigns automatic event class IDs?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-auto-stream-id \"Assigns automatic stream IDs?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-pkt \"Supports packets?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pkt-beg-cs \"Packets have a beginning default clock snapshot?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pkt-end-cs \"Packets have an end default clock snapshot?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-disc-ev \"Supports discarded events?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-disc-ev-cs \"Discarded events have default clock snapshots?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-disc-pkt \"Supports discarded packets?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-disc-pkt-cs \"Discarded packets have default clock snapshots?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class to add the created stream class to."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_trace_class_assigns_automatic_stream_class_id(trace_class)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_create_with_id() &mdash;"]
    #[doc = "Creates a stream class with a specific numeric ID and adds it to a"]
    #[doc = "trace class."]
    pub fn bt_stream_class_create(trace_class: *mut bt_trace_class) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default stream class with the numeric ID \\bt_p{id} and adds"]
    #[doc = "it to the \\bt_trace_cls \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_trace_class_assigns_automatic_stream_class_id(trace_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_stream_class_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned stream class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-id \"Numeric ID\""]
    #[doc = "<td>\\bt_p{id}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-def-clock-cls \"Default clock class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pc-fc \"Packet context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-ecc-fc \"Event common context field class\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-auto-ec-id \"Assigns automatic event class IDs?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-auto-stream-id \"Assigns automatic stream IDs?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-pkt \"Supports packets?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pkt-beg-cs \"Packets have a beginning default clock snapshot?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-pkt-end-cs \"Packets have an end default clock snapshot?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-disc-ev \"Supports discarded events?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-disc-ev-cs \"Discarded events have default clock snapshots?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-supports-disc-pkt \"Supports discarded packets?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-disc-pkt-cs \"Discarded packets have default clock snapshots?\""]
    #[doc = "<td>No"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class to add the created stream class to."]
    #[doc = "@param[in] id"]
    #[doc = "Numeric ID of the stream class to create and add to"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream class reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_trace_class_assigns_automatic_stream_class_id(trace_class)</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{trace_class} does not contain a stream class with the numeric"]
    #[doc = "ID \\bt_p{id}."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_create() &mdash;"]
    #[doc = "Creates a stream class with an automatic numeric ID and adds it to a"]
    #[doc = "trace class."]
    pub fn bt_stream_class_create_with_id(
        trace_class: *mut bt_trace_class,
        id: u64,
    ) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_trace_cls which contains the stream class"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the trace class which contains it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Trace class which contains \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_trace_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_trace_class(
        stream_class: *mut bt_stream_class,
    ) -> *mut bt_trace_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_trace_cls which contains the stream class"]
    #[doc = "\\bt_p{stream_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_trace_class()."]
    pub fn bt_stream_class_borrow_trace_class_const(
        stream_class: *const bt_stream_class,
    ) -> *const bt_trace_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_ev_cls contained in the stream"]
    #[doc = "class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get the number of contained event classes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained event classes in \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    pub fn bt_stream_class_get_event_class_count(stream_class: *const bt_stream_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev_cls at index \\bt_p{index} from the"]
    #[doc = "stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the event class at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the event class to borrow from \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the event class of"]
    #[doc = "\\bt_p{stream_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{stream_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of event classes in"]
    #[doc = "\\bt_p{stream_class} (as returned by"]
    #[doc = "bt_stream_class_get_event_class_count())."]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_get_event_class_count() &mdash;"]
    #[doc = "Returns the number of event classes contained in a stream class."]
    #[doc = "@sa bt_stream_class_borrow_event_class_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_event_class_by_index(
        stream_class: *mut bt_stream_class,
        index: u64,
    ) -> *mut bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev_cls at index \\bt_p{index} from the"]
    #[doc = "stream class \\bt_p{stream_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_event_class_by_index()."]
    pub fn bt_stream_class_borrow_event_class_by_index_const(
        stream_class: *const bt_stream_class,
        index: u64,
    ) -> *const bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev_cls having the numeric ID \\bt_p{id} from the"]
    #[doc = "stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "If there's no event class having the numeric ID \\bt_p{id} in"]
    #[doc = "\\bt_p{stream_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the event class having the"]
    #[doc = "numeric ID \\bt_p{id}."]
    #[doc = "@param[in] id"]
    #[doc = "ID of the event class to borrow from \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the event class of"]
    #[doc = "\\bt_p{stream_class} having the numeric ID \\bt_p{id}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{stream_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_event_class_by_id_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_event_class_by_id(
        stream_class: *mut bt_stream_class,
        id: u64,
    ) -> *mut bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_ev_cls having the numeric ID \\bt_p{id} from the"]
    #[doc = "stream class \\bt_p{stream_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_event_class_by_id()."]
    pub fn bt_stream_class_borrow_event_class_by_id_const(
        stream_class: *const bt_stream_class,
        id: u64,
    ) -> *const bt_event_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the numeric ID of the stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-id \"numeric ID\" property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get the numeric ID."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Numeric ID of \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_create_with_id() &mdash;"]
    #[doc = "Creates a stream class with a specific numeric ID and adds it to a"]
    #[doc = "trace class."]
    pub fn bt_stream_class_get_id(stream_class: *const bt_stream_class) -> u64;
}
pub mod bt_stream_class_set_name_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_stream_class_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_STREAM_CLASS_SET_NAME_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_STREAM_CLASS_SET_NAME_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the name of the stream class \\bt_p{stream_class} to"]
    #[doc = "a copy of \\bt_p{name}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set the name to \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "New name of \\bt_p{stream_class} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_STREAM_CLASS_SET_NAME_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_STREAM_CLASS_SET_NAME_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_get_name() &mdash;"]
    #[doc = "Returns the name of a stream class."]
    pub fn bt_stream_class_set_name(
        stream_class: *mut bt_stream_class,
        name: *const ::std::os::raw::c_char,
    ) -> bt_stream_class_set_name_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{stream_class} has no name, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{stream_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{stream_class}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_name() &mdash;"]
    #[doc = "Sets the name of a stream class."]
    pub fn bt_stream_class_get_name(
        stream_class: *const bt_stream_class,
    ) -> *const ::std::os::raw::c_char;
}
pub mod bt_stream_class_set_default_clock_class_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_stream_class_set_default_clock_class()."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_STREAM_CLASS_SET_DEFAULT_CLOCK_CLASS_STATUS_OK: Type = 0;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the default \\bt_clock_cls of the stream class"]
    #[doc = "\\bt_p{stream_class} to \\bt_p{clock_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set the default clock class to"]
    #[doc = "\\bt_p{clock_class}."]
    #[doc = "@param[in] clock_class"]
    #[doc = "New default clock class of \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_STREAM_CLASS_SET_DEFAULT_CLOCK_CLASS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@bt_pre_not_null{clock_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_default_clock_class() &mdash;"]
    #[doc = "Borrows the default clock class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_default_clock_class_const() &mdash;"]
    #[doc = "Borrows the default clock class of a stream class (\\c const version)."]
    pub fn bt_stream_class_set_default_clock_class(
        stream_class: *mut bt_stream_class,
        clock_class: *mut bt_clock_class,
    ) -> bt_stream_class_set_default_clock_class_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls from the stream class"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "If \\bt_p{stream_class} has no default clock class, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the default clock class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the default clock class of"]
    #[doc = "\\bt_p{stream_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_default_clock_class() &mdash;"]
    #[doc = "Sets the default clock class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_default_clock_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_default_clock_class(
        stream_class: *mut bt_stream_class,
    ) -> *mut bt_clock_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the default \\bt_clock_cls from the stream class"]
    #[doc = "\\bt_p{stream_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_default_clock_class()."]
    pub fn bt_stream_class_borrow_default_clock_class_const(
        stream_class: *const bt_stream_class,
    ) -> *const bt_clock_class;
}
pub mod bt_stream_class_set_field_class_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_stream_class_set_packet_context_field_class()"]
    #[doc = "and bt_stream_class_set_event_common_context_field_class()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the packet context \\bt_fc of the stream class"]
    #[doc = "\\bt_p{stream_class} to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-pc-fc \"packet context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "\\bt_p{stream_class} must support packets (see"]
    #[doc = "bt_stream_class_set_supports_packets())."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set the packet context field class to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = "@param[in] field_class"]
    #[doc = "New packet context field class of \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(stream_class)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class}, or any of its contained field classes,"]
    #[doc = "is not already part of a stream class or of an \\bt_ev_cls."]
    #[doc = "@pre"]
    #[doc = "If any of the field classes recursively contained in"]
    #[doc = "\\bt_p{field_class} has a"]
    #[doc = "\\ref api-tir-fc-link \"link to another field class\", it must honor"]
    #[doc = "the field class link rules."]
    #[doc = "@pre"]
    #[doc = "If any of the field classes recursively contained in"]
    #[doc = "\\bt_p{field_class} has a"]
    #[doc = "\\ref api-tir-fc-link \"link to another field class\", it must honor"]
    #[doc = "the field class link rules."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_packet_context_field_class() &mdash;"]
    #[doc = "Borrows the packet context field class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_packet_context_field_class_const() &mdash;"]
    #[doc = "Borrows the packet context field class of a stream class"]
    #[doc = "(\\c const version)."]
    pub fn bt_stream_class_set_packet_context_field_class(
        stream_class: *mut bt_stream_class,
        field_class: *mut bt_field_class,
    ) -> bt_stream_class_set_field_class_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the packet context \\bt_fc from the stream class"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-pc-fc \"packet context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "If \\bt_p{stream_class} has no packet context field class, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the packet context field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the packet context field class of"]
    #[doc = "\\bt_p{stream_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_packet_context_field_class() &mdash;"]
    #[doc = "Sets the packet context field class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_packet_context_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_packet_context_field_class(
        stream_class: *mut bt_stream_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the packet context \\bt_fc from the stream class"]
    #[doc = "\\bt_p{stream_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_packet_context_field_class()."]
    pub fn bt_stream_class_borrow_packet_context_field_class_const(
        stream_class: *const bt_stream_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the event common context \\bt_fc of the stream class"]
    #[doc = "\\bt_p{stream_class} to \\bt_p{field_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-ecc-fc \"event common context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set the event common context field class to"]
    #[doc = "\\bt_p{field_class}."]
    #[doc = "@param[in] field_class"]
    #[doc = "New event common context field class of \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@bt_pre_not_null{field_class}"]
    #[doc = "@bt_pre_is_struct_fc{field_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{field_class}, or any of its contained field classes,"]
    #[doc = "is not already part of a stream class or of an \\bt_ev_cls."]
    #[doc = "@pre"]
    #[doc = "If any of the field classes recursively contained in"]
    #[doc = "\\bt_p{field_class} has a"]
    #[doc = "\\ref api-tir-fc-link \"link to another field class\", it must honor"]
    #[doc = "the field class link rules."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{field_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_event_common_context_field_class() &mdash;"]
    #[doc = "Borrows the event common context field class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_event_common_context_field_class_const() &mdash;"]
    #[doc = "Borrows the event common context field class of a stream class"]
    #[doc = "(\\c const version)."]
    pub fn bt_stream_class_set_event_common_context_field_class(
        stream_class: *mut bt_stream_class,
        field_class: *mut bt_field_class,
    ) -> bt_stream_class_set_field_class_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the event common context \\bt_fc from the stream class"]
    #[doc = "\\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-pc-fc \"event common context field class\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "If \\bt_p{stream_class} has no event common context field class, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the event common context"]
    #[doc = "field class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the event common context field class of"]
    #[doc = "\\bt_p{stream_class}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_event_common_context_field_class() &mdash;"]
    #[doc = "Sets the event common context field class of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_event_common_context_field_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_event_common_context_field_class(
        stream_class: *mut bt_stream_class,
    ) -> *mut bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the event common context \\bt_fc from the stream class"]
    #[doc = "\\bt_p{stream_class} (\\c const version())."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_event_common_context_field_class()."]
    pub fn bt_stream_class_borrow_event_common_context_field_class_const(
        stream_class: *const bt_stream_class,
    ) -> *const bt_field_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the stream class \\bt_p{stream_class}"]
    #[doc = "automatically assigns a numeric ID to an \\bt_ev_cls you create and"]
    #[doc = "add to it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-auto-ec-id \"assigns automatic event class IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set whether or not it assigns automatic"]
    #[doc = "event class IDs."]
    #[doc = "@param[in] assigns_automatic_event_class_id"]
    #[doc = "#BT_TRUE to make \\bt_p{stream_class} assign automatic event class"]
    #[doc = "IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_assigns_automatic_event_class_id() &mdash;"]
    #[doc = "Returns whether or not a stream class automatically assigns"]
    #[doc = "event class IDs."]
    pub fn bt_stream_class_set_assigns_automatic_event_class_id(
        stream_class: *mut bt_stream_class,
        assigns_automatic_event_class_id: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the stream class \\bt_p{stream_class}"]
    #[doc = "automatically assigns a numeric ID to an \\bt_ev_cls you create"]
    #[doc = "and add to it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-auto-ec-id \"assigns automatic event class IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not it assigns automatic"]
    #[doc = "event class IDs."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{stream_class} automatically"]
    #[doc = "assigns event class IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_assigns_automatic_event_class_id() &mdash;"]
    #[doc = "Sets whether or not a stream class automatically assigns"]
    #[doc = "event class IDs."]
    pub fn bt_stream_class_assigns_automatic_event_class_id(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the stream class \\bt_p{stream_class}"]
    #[doc = "automatically assigns a numeric ID to a \\bt_stream you create from"]
    #[doc = "it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-auto-stream-id \"assigns automatic stream IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set whether or not it assigns automatic"]
    #[doc = "stream IDs."]
    #[doc = "@param[in] assigns_automatic_stream_id"]
    #[doc = "#BT_TRUE to make \\bt_p{stream_class} assign automatic stream"]
    #[doc = "IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_assigns_automatic_stream_id() &mdash;"]
    #[doc = "Returns whether or not a stream class automatically assigns"]
    #[doc = "stream IDs."]
    pub fn bt_stream_class_set_assigns_automatic_stream_id(
        stream_class: *mut bt_stream_class,
        assigns_automatic_stream_id: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the stream class \\bt_p{stream_class}"]
    #[doc = "automatically assigns a numeric ID to a \\bt_stream you create"]
    #[doc = "from it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-auto-stream-id \"assigns automatic stream IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not it assigns automatic"]
    #[doc = "stream IDs."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{stream_class} automatically assigns stream IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_assigns_automatic_stream_id() &mdash;"]
    #[doc = "Sets whether or not a stream class automatically assigns"]
    #[doc = "stream IDs."]
    pub fn bt_stream_class_assigns_automatic_stream_id(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} have \\bt_p_pkt and, if so,"]
    #[doc = "if those packets have beginning and/or end default"]
    #[doc = "\\bt_p_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-supports-pkt \"supports packets?\","]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-beg-cs \"packets have a beginning default clock snapshot?\","]
    #[doc = "and"]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-end-cs \"packets have an end default clock snapshot?\""]
    #[doc = "properties."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set whether or not its streams have"]
    #[doc = "packets."]
    #[doc = "@param[in] supports_packets"]
    #[doc = "#BT_TRUE to make the streams of \\bt_p{stream_class} have packets."]
    #[doc = "@param[in] with_beginning_default_clock_snapshot"]
    #[doc = "#BT_TRUE to make the packets of the streams of \\bt_p{stream_class}"]
    #[doc = "have a beginning default clock snapshot."]
    #[doc = "@param[in] with_end_default_clock_snapshot"]
    #[doc = "#BT_TRUE to make the packets of the streams of \\bt_p{stream_class}"]
    #[doc = "have an end default clock snapshot."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_beginning_default_clock_snapshot} is"]
    #[doc = "#BT_TRUE</strong>,"]
    #[doc = "\\bt_p{supports_packets} is also #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_beginning_default_clock_snapshot} is"]
    #[doc = "#BT_TRUE</strong>,"]
    #[doc = "\\bt_p{supports_packets} is also #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_beginning_default_clock_snapshot} or"]
    #[doc = "\\bt_p{with_end_default_clock_snapshot} is #BT_TRUE</strong>,"]
    #[doc = "\\bt_p{stream_class} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_supports_packets() &mdash;"]
    #[doc = "Returns whether or not a stream class's streams have packets."]
    #[doc = "@sa bt_stream_class_packets_have_beginning_default_clock_snapshot() &mdash;"]
    #[doc = "Returns whether or not the packets of a stream class's streams"]
    #[doc = "have a beginning default clock snapshot."]
    #[doc = "@sa bt_stream_class_packets_have_end_default_clock_snapshot() &mdash;"]
    #[doc = "Returns whether or not the packets of a stream class's streams"]
    #[doc = "have an end default clock snapshot."]
    pub fn bt_stream_class_set_supports_packets(
        stream_class: *mut bt_stream_class,
        supports_packets: bt_bool,
        with_beginning_default_clock_snapshot: bt_bool,
        with_end_default_clock_snapshot: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} have \\bt_p_pkt."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-supports-pkt \"supports packets?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams have"]
    #[doc = "packets."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the streams of \\bt_p{stream_class} have packets."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_packets() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams have packets."]
    pub fn bt_stream_class_supports_packets(stream_class: *const bt_stream_class) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_p_pkt of the instances (\\bt_p_stream)"]
    #[doc = "of the stream class \\bt_p{stream_class} have a beginning"]
    #[doc = "default \\bt_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-beg-cs \"packets have a beginning default clock snapshot?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams's packets"]
    #[doc = "have a beginning default clock snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the packets of the streams of \\bt_p{stream_class} have a"]
    #[doc = "beginning default clock snapshot."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_packets() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams have packets."]
    #[doc = "@sa bt_stream_class_packets_have_end_default_clock_snapshot() &mdash;"]
    #[doc = "Returns whether or not the packets of a stream class's streams"]
    #[doc = "have an end default clock snapshot."]
    pub fn bt_stream_class_packets_have_beginning_default_clock_snapshot(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_p_pkt of the instances (\\bt_p_stream)"]
    #[doc = "of the stream class \\bt_p{stream_class} have an end"]
    #[doc = "default \\bt_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-pkt-end-cs \"packets have an end default clock snapshot?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams's packets"]
    #[doc = "have an end default clock snapshot."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the packets of the streams of \\bt_p{stream_class} have"]
    #[doc = "an end default clock snapshot."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_packets() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams have packets."]
    #[doc = "@sa bt_stream_class_packets_have_beginning_default_clock_snapshot() &mdash;"]
    #[doc = "Returns whether or not the packets of a stream class's streams"]
    #[doc = "have a beginning default clock snapshot."]
    pub fn bt_stream_class_packets_have_end_default_clock_snapshot(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} can have discarded events and,"]
    #[doc = "if so, if the \\bt_p_disc_ev_msg of those streams have"]
    #[doc = "beginning and end default \\bt_p_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-supports-disc-ev \"supports discarded events?\""]
    #[doc = "and"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-ev-cs \"discarded events have default clock snapshots?\""]
    #[doc = "properties."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set whether or not its streams can have"]
    #[doc = "discarded events."]
    #[doc = "@param[in] supports_discarded_events"]
    #[doc = "#BT_TRUE to make the streams of \\bt_p{stream_class} be able to"]
    #[doc = "have discarded events."]
    #[doc = "@param[in] with_default_clock_snapshots"]
    #[doc = "#BT_TRUE to make the discarded events messages the streams of"]
    #[doc = "\\bt_p{stream_class} have beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_default_clock_snapshots} is #BT_TRUE</strong>,"]
    #[doc = "\\bt_p{supports_discarded_events} is also #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_default_clock_snapshots} is #BT_TRUE</strong>,"]
    #[doc = "\\bt_p{stream_class} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_supports_discarded_events() &mdash;"]
    #[doc = "Returns whether or not a stream class's streams can have"]
    #[doc = "discarded events."]
    #[doc = "@sa bt_stream_class_discarded_events_have_default_clock_snapshots() &mdash;"]
    #[doc = "Returns whether or not the discarded events messages of a"]
    #[doc = "stream class's streams have beginning and end default clock"]
    #[doc = "snapshots."]
    pub fn bt_stream_class_set_supports_discarded_events(
        stream_class: *mut bt_stream_class,
        supports_discarded_events: bt_bool,
        with_default_clock_snapshots: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} can have discarded events."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-supports-disc-ev \"supports discarded events?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams can have"]
    #[doc = "discarded events."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the streams of \\bt_p{stream_class} can have discarded"]
    #[doc = "events."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_discarded_events() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams can have discarded"]
    #[doc = "events."]
    pub fn bt_stream_class_supports_discarded_events(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_p_disc_ev_msg of the instances"]
    #[doc = "(\\bt_p_stream) of the stream class \\bt_p{stream_class} have"]
    #[doc = "beginning and end default \\bt_p_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-ev-cs \"discarded events have default clock snapshots?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams's discarded"]
    #[doc = "events messages have a beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the discarded events messages of the streams of"]
    #[doc = "\\bt_p{stream_class} have beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_discarded_events() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams can have discarded"]
    #[doc = "events."]
    pub fn bt_stream_class_discarded_events_have_default_clock_snapshots(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} can have discarded packets and,"]
    #[doc = "if so, if the \\bt_p_disc_pkt_msg of those streams have"]
    #[doc = "beginning and end default \\bt_p_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-supports-disc-pkt \"supports discarded packets?\""]
    #[doc = "and"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-pkt-cs \"discarded packets have default clock snapshots?\""]
    #[doc = "properties."]
    #[doc = ""]
    #[doc = "\\bt_p{stream_class} must support packets (see"]
    #[doc = "bt_stream_class_set_supports_packets())."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set whether or not its streams can have"]
    #[doc = "discarded packets."]
    #[doc = "@param[in] supports_discarded_packets"]
    #[doc = "#BT_TRUE to make the streams of \\bt_p{stream_class} be able to"]
    #[doc = "have discarded packets."]
    #[doc = "@param[in] with_default_clock_snapshots"]
    #[doc = "#BT_TRUE to make the discarded packets messages the streams of"]
    #[doc = "\\bt_p{stream_class} have beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_supports_packets(stream_class)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_default_clock_snapshots} is #BT_TRUE</strong>,"]
    #[doc = "\\bt_p{supports_discarded_packets} is also #BT_TRUE."]
    #[doc = "@pre"]
    #[doc = "<strong>If \\bt_p{with_default_clock_snapshots} is #BT_TRUE</strong>,"]
    #[doc = "\\bt_p{stream_class} has a"]
    #[doc = "\\ref api-tir-stream-cls-prop-def-clock-cls \"default clock class\"."]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_supports_discarded_packets() &mdash;"]
    #[doc = "Returns whether or not a stream class's streams can have"]
    #[doc = "discarded packets."]
    #[doc = "@sa bt_stream_class_discarded_packets_have_default_clock_snapshots() &mdash;"]
    #[doc = "Returns whether or not the discarded packets messages of a"]
    #[doc = "stream class's streams have beginning and end default clock"]
    #[doc = "snapshots."]
    pub fn bt_stream_class_set_supports_discarded_packets(
        stream_class: *mut bt_stream_class,
        supports_discarded_packets: bt_bool,
        with_default_clock_snapshots: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the instances (\\bt_p_stream) of the"]
    #[doc = "stream class \\bt_p{stream_class} can have discarded packets."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-supports-disc-pkt \"supports discarded packets?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams can have"]
    #[doc = "discarded packets."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the streams of \\bt_p{stream_class} can have discarded"]
    #[doc = "packets."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_discarded_packets() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams can have discarded"]
    #[doc = "packets."]
    pub fn bt_stream_class_supports_discarded_packets(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the \\bt_p_disc_pkt_msg of the instances"]
    #[doc = "(\\bt_p_stream) of the stream class \\bt_p{stream_class} have"]
    #[doc = "beginning and end default \\bt_p_cs."]
    #[doc = ""]
    #[doc = "See the"]
    #[doc = "\\ref api-tir-stream-cls-prop-disc-ev-cs \"discarded packets have default clock snapshots?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to get whether or not its streams's discarded"]
    #[doc = "packets messages have a beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if the discarded packets messages of the streams of"]
    #[doc = "\\bt_p{stream_class} have beginning and end default clock snapshots."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_supports_discarded_packets() &mdash;"]
    #[doc = "Sets whether or not a stream class's streams can have discarded"]
    #[doc = "packets."]
    pub fn bt_stream_class_discarded_packets_have_default_clock_snapshots(
        stream_class: *const bt_stream_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the stream class \\bt_p{stream_class} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default stream class with bt_stream_class_create()"]
    #[doc = "or bt_stream_class_create_with_id(), the stream class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val. Therefore you can borrow it with"]
    #[doc = "bt_stream_class_borrow_user_attributes() and fill it directly"]
    #[doc = "instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@bt_pre_hot{stream_class}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a stream class."]
    pub fn bt_stream_class_set_user_attributes(
        stream_class: *mut bt_stream_class,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default stream class with bt_stream_class_create()"]
    #[doc = "or bt_stream_class_create_with_id(), the stream class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{stream_class} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a stream class."]
    #[doc = "@sa bt_stream_class_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_class_borrow_user_attributes(
        stream_class: *mut bt_stream_class,
    ) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the stream class \\bt_p{stream_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_class_borrow_user_attributes()."]
    pub fn bt_stream_class_borrow_user_attributes_const(
        stream_class: *const bt_stream_class,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "@parblock"]
    #[doc = "Stream class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a stream class."]
    pub fn bt_stream_class_get_ref(stream_class: *const bt_stream_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the stream class \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "@parblock"]
    #[doc = "Stream class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a stream class."]
    pub fn bt_stream_class_put_ref(stream_class: *const bt_stream_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a stream from the \\bt_stream_cls \\bt_p{stream_class} and"]
    #[doc = "adds it to the \\bt_trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "This function instantiates \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_assigns_automatic_stream_id(stream_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_TRUE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_stream_create_with_id()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned stream has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-id \"Numeric ID\""]
    #[doc = "<td>Automatically assigned by \\bt_p{stream_class} and \\bt_p{trace}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to create the stream."]
    #[doc = "@param[in] trace"]
    #[doc = "Trace to add the created stream to."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_assigns_automatic_stream_id(stream_class)</code>"]
    #[doc = "returns #BT_TRUE."]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream_class}"]
    #[doc = "@bt_post_success_frozen{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_create_with_id() &mdash;"]
    #[doc = "Creates a stream with a specific numeric ID and adds it to a"]
    #[doc = "trace."]
    pub fn bt_stream_create(
        stream_class: *mut bt_stream_class,
        trace: *mut bt_trace,
    ) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a stream with the numeric ID \\bt_p{id}"]
    #[doc = "from the \\bt_stream_cls \\bt_p{stream_class} and adds"]
    #[doc = "it to the \\bt_trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "This function instantiates \\bt_p{stream_class}."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "Only use this function if"]
    #[doc = ""]
    #[doc = "@code"]
    #[doc = "bt_stream_class_assigns_automatic_stream_id(stream_class)"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "returns #BT_FALSE."]
    #[doc = ""]
    #[doc = "Otherwise, use bt_stream_create()."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "On success, the returned stream has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-id \"Numeric ID\""]
    #[doc = "<td>\\bt_p{id}"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-stream-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] stream_class"]
    #[doc = "Stream class from which to create the stream."]
    #[doc = "@param[in] trace"]
    #[doc = "Trace to add the created stream to."]
    #[doc = "@param[in] id"]
    #[doc = "Numeric ID of the stream to create and add to \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New stream reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream_class}"]
    #[doc = "@pre"]
    #[doc = "<code>bt_stream_class_assigns_automatic_stream_id(stream_class)</code>"]
    #[doc = "returns #BT_FALSE."]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{trace} does not contain an instance of \\bt_p{stream_class}"]
    #[doc = "with the numeric ID \\bt_p{id}."]
    #[doc = ""]
    #[doc = "@bt_post_success_frozen{stream_class}"]
    #[doc = "@bt_post_success_frozen{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_create() &mdash;"]
    #[doc = "Creates a stream with an automatic numeric ID and adds it to a"]
    #[doc = "trace."]
    pub fn bt_stream_create_with_id(
        stream_class: *mut bt_stream_class,
        trace: *mut bt_trace,
        id: u64,
    ) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-stream-cls \"class\" of the stream"]
    #[doc = "\\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_borrow_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_borrow_class(stream: *mut bt_stream) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-stream-cls \"class\" of the stream"]
    #[doc = "\\bt_p{stream} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_borrow_class()."]
    pub fn bt_stream_borrow_class_const(stream: *const bt_stream) -> *const bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_trace which contains the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to borrow the trace containing it."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the trace containing \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_borrow_trace_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_borrow_trace(stream: *mut bt_stream) -> *mut bt_trace;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_trace which contains the stream \\bt_p{stream}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_borrow_trace()."]
    pub fn bt_stream_borrow_trace_const(stream: *const bt_stream) -> *const bt_trace;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the numeric ID of the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-prop-id \"numeric ID\" property."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to get the numeric ID."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Numeric ID of \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_create_with_id() &mdash;"]
    #[doc = "Creates a stream with a specific numeric ID and adds it to a"]
    #[doc = "trace."]
    pub fn bt_stream_get_id(stream: *const bt_stream) -> u64;
}
pub mod bt_stream_set_name_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_stream_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_STREAM_SET_NAME_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_STREAM_SET_NAME_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the name of the stream \\bt_p{stream} to"]
    #[doc = "a copy of \\bt_p{name}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to set the name to \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "New name of \\bt_p{stream} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_STREAM_CLASS_SET_NAME_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_STREAM_CLASS_SET_NAME_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@bt_pre_hot{stream}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_get_name() &mdash;"]
    #[doc = "Returns the name of a stream."]
    pub fn bt_stream_set_name(
        stream: *mut bt_stream,
        name: *const ::std::os::raw::c_char,
    ) -> bt_stream_set_name_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{stream} has no name, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{stream}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{stream}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_class_set_name() &mdash;"]
    #[doc = "Sets the name of a stream."]
    pub fn bt_stream_get_name(stream: *const bt_stream) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the stream \\bt_p{stream} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default stream with bt_stream_create()"]
    #[doc = "or bt_stream_create_with_id(), the stream's initial user"]
    #[doc = "attributes is an empty \\bt_map_val. Therefore you can borrow it with"]
    #[doc = "bt_stream_borrow_user_attributes() and fill it directly"]
    #[doc = "instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = "@bt_pre_hot{stream}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a stream."]
    pub fn bt_stream_set_user_attributes(stream: *mut bt_stream, user_attributes: *const bt_value);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-stream-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default stream with bt_stream_create()"]
    #[doc = "or bt_stream_create_with_id(), the stream's initial user"]
    #[doc = "attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "Stream from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{stream} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{stream}"]
    #[doc = ""]
    #[doc = "@sa bt_stream_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a stream."]
    #[doc = "@sa bt_stream_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_stream_borrow_user_attributes(stream: *mut bt_stream) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the stream \\bt_p{stream}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_stream_borrow_user_attributes()."]
    pub fn bt_stream_borrow_user_attributes_const(stream: *const bt_stream) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "@parblock"]
    #[doc = "Stream of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_stream_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a stream."]
    pub fn bt_stream_get_ref(stream: *const bt_stream);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the stream \\bt_p{stream}."]
    #[doc = ""]
    #[doc = "@param[in] stream"]
    #[doc = "@parblock"]
    #[doc = "Stream of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_stream_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a stream."]
    pub fn bt_stream_put_ref(stream: *const bt_stream);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default trace class from the \\bt_self_comp"]
    #[doc = "\\bt_p{self_component}."]
    #[doc = ""]
    #[doc = "On success, the returned trace class has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-cls-prop-auto-sc-id \"Assigns automatic stream class IDs?\""]
    #[doc = "<td>Yes"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-cls-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] self_component"]
    #[doc = "Self component from which to create the default trace class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New trace class reference, or \\c NULL on memory error."]
    pub fn bt_trace_class_create(self_component: *mut bt_self_component) -> *mut bt_trace_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_stream_cls contained in the trace"]
    #[doc = "class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class of which to get the number of contained stream classes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained stream classes in \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    pub fn bt_trace_class_get_stream_class_count(trace_class: *const bt_trace_class) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls at index \\bt_p{index} from the"]
    #[doc = "trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to borrow the stream class at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the stream class to borrow from \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream class of"]
    #[doc = "\\bt_p{trace_class} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of stream classes in"]
    #[doc = "\\bt_p{trace_class} (as returned by"]
    #[doc = "bt_trace_class_get_stream_class_count())."]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_get_stream_class_count() &mdash;"]
    #[doc = "Returns the number of stream classes contained in a trace class."]
    #[doc = "@sa bt_trace_class_borrow_stream_class_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_class_borrow_stream_class_by_index(
        trace_class: *mut bt_trace_class,
        index: u64,
    ) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls at index \\bt_p{index} from the"]
    #[doc = "trace class \\bt_p{trace_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_class_borrow_stream_class_by_index()."]
    pub fn bt_trace_class_borrow_stream_class_by_index_const(
        trace_class: *const bt_trace_class,
        index: u64,
    ) -> *const bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls having the numeric ID \\bt_p{id} from the"]
    #[doc = "trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "If there's no stream class having the numeric ID \\bt_p{id} in"]
    #[doc = "\\bt_p{trace_class}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to borrow the stream class having the"]
    #[doc = "numeric ID \\bt_p{id}."]
    #[doc = "@param[in] id"]
    #[doc = "ID of the stream class to borrow from \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream class of"]
    #[doc = "\\bt_p{trace_class} having the numeric ID \\bt_p{id}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace_class}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_borrow_stream_class_by_id_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_class_borrow_stream_class_by_id(
        trace_class: *mut bt_trace_class,
        id: u64,
    ) -> *mut bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream_cls having the numeric ID \\bt_p{id} from the"]
    #[doc = "trace class \\bt_p{trace_class} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_class_borrow_stream_class_by_id()."]
    pub fn bt_trace_class_borrow_stream_class_by_id_const(
        trace_class: *const bt_trace_class,
        id: u64,
    ) -> *const bt_stream_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets whether or not the trace class \\bt_p{trace_class} automatically"]
    #[doc = "assigns a numeric ID to a \\bt_stream_cls you create and add to it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-cls-prop-auto-sc-id \"assigns automatic stream class IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class of which to set whether or not it assigns automatic"]
    #[doc = "stream class IDs."]
    #[doc = "@param[in] assigns_automatic_stream_class_id"]
    #[doc = "#BT_TRUE to make \\bt_p{trace_class} assign automatic stream class"]
    #[doc = "IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_hot{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_assigns_automatic_stream_class_id() &mdash;"]
    #[doc = "Returns whether or not a trace class automatically assigns"]
    #[doc = "stream class IDs."]
    pub fn bt_trace_class_set_assigns_automatic_stream_class_id(
        trace_class: *mut bt_trace_class,
        assigns_automatic_stream_class_id: bt_bool,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the trace class \\bt_p{trace_class}"]
    #[doc = "automatically assigns a numeric ID to a \\bt_stream_cls you create"]
    #[doc = "and add to it."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-cls-prop-auto-sc-id \"assigns automatic stream class IDs?\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class of which to get whether or not it assigns automatic"]
    #[doc = "stream class IDs."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{trace_class} automatically"]
    #[doc = "assigns stream class IDs."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_set_assigns_automatic_stream_class_id() &mdash;"]
    #[doc = "Sets whether or not a trace class automatically assigns"]
    #[doc = "stream class IDs."]
    pub fn bt_trace_class_assigns_automatic_stream_class_id(
        trace_class: *const bt_trace_class,
    ) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the trace class \\bt_p{trace_class} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default trace class with bt_trace_class_create()"]
    #[doc = "or bt_trace_class_create_with_id(), the trace class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val. Therefore you can borrow it with"]
    #[doc = "bt_trace_class_borrow_user_attributes() and fill it directly"]
    #[doc = "instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class of which to set the user attributes to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_hot{trace_class}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a trace class."]
    pub fn bt_trace_class_set_user_attributes(
        trace_class: *mut bt_trace_class,
        user_attributes: *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-cls-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default trace class with bt_trace_class_create()"]
    #[doc = "or bt_trace_class_create_with_id(), the trace class's initial user"]
    #[doc = "attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{trace_class} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a trace class."]
    #[doc = "@sa bt_trace_class_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_class_borrow_user_attributes(trace_class: *mut bt_trace_class)
        -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the trace class \\bt_p{trace_class}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_class_borrow_user_attributes()."]
    pub fn bt_trace_class_borrow_user_attributes_const(
        trace_class: *const bt_trace_class,
    ) -> *const bt_value;
}
#[doc = "@brief"]
#[doc = "User function for bt_trace_class_add_destruction_listener()."]
#[doc = ""]
#[doc = "This is the user function type for a trace class destruction listener."]
#[doc = ""]
#[doc = "@param[in] trace_class"]
#[doc = "Trace class being destroyed (\\ref api-fund-freezing \"frozen\")."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_trace_class_add_destruction_listener()."]
#[doc = ""]
#[doc = "@bt_pre_not_null{trace_class}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "The reference count of \\bt_p{trace_class} is not changed."]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_trace_class_add_destruction_listener() &mdash;"]
#[doc = "Adds a destruction listener to a trace class."]
pub type bt_trace_class_destruction_listener_func = ::std::option::Option<
    unsafe extern "C" fn(
        trace_class: *const bt_trace_class,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub mod bt_trace_class_add_listener_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_class_add_destruction_listener()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_CLASS_ADD_LISTENER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_CLASS_ADD_LISTENER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a destruction listener having the function \\bt_p{user_func}"]
    #[doc = "to the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "All the destruction listener user functions of a trace class are called"]
    #[doc = "when it's being destroyed."]
    #[doc = ""]
    #[doc = "If \\bt_p{listener_id} is not \\c NULL, then this function, on success,"]
    #[doc = "sets \\bt_p{*listener_id} to the ID of the added destruction listener"]
    #[doc = "within \\bt_p{trace_class}. You can then use this ID to remove the"]
    #[doc = "added destruction listener with"]
    #[doc = "bt_trace_class_remove_destruction_listener()."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class to add the destruction listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the destruction listener to add to"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added destruction listener within"]
    #[doc = "\\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_CLASS_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_CLASS_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_remove_destruction_listener() &mdash;"]
    #[doc = "Removes a destruction listener from a trace class."]
    pub fn bt_trace_class_add_destruction_listener(
        trace_class: *const bt_trace_class,
        user_func: bt_trace_class_destruction_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_trace_class_add_listener_status::Type;
}
pub mod bt_trace_class_remove_listener_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_class_remove_destruction_listener()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Removes the destruction listener having the ID \\bt_p{listener_id}"]
    #[doc = "from the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "The destruction listener to remove from \\bt_p{trace_class} was"]
    #[doc = "previously added with bt_trace_class_add_destruction_listener()."]
    #[doc = ""]
    #[doc = "You can call this function when \\bt_p{trace_class} is"]
    #[doc = "\\ref api-fund-freezing \"frozen\"."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to remove the destruction listener having"]
    #[doc = "the ID \\bt_p{listener_id}."]
    #[doc = "@param[in] listener_id"]
    #[doc = "ID of the destruction listener to remove from \\bt_p{trace_class}\u{ad}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace_class}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{listener_id} is the ID of an existing destruction listener"]
    #[doc = "in \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_add_destruction_listener() &mdash;"]
    #[doc = "Adds a destruction listener to a trace class."]
    pub fn bt_trace_class_remove_destruction_listener(
        trace_class: *const bt_trace_class,
        listener_id: bt_listener_id,
    ) -> bt_trace_class_remove_listener_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "@parblock"]
    #[doc = "Trace class of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a trace class."]
    pub fn bt_trace_class_get_ref(trace_class: *const bt_trace_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace class \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "@parblock"]
    #[doc = "Trace class of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_trace_class_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a trace class."]
    pub fn bt_trace_class_put_ref(trace_class: *const bt_trace_class);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a default trace from the \\bt_trace_cls \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "This function instantiates \\bt_p{trace_class}."]
    #[doc = ""]
    #[doc = "On success, the returned trace has the following property values:"]
    #[doc = ""]
    #[doc = "<table>"]
    #[doc = "<tr>"]
    #[doc = "<th>Property"]
    #[doc = "<th>Value"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-prop-name \"Name\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-prop-uuid \"UUID\""]
    #[doc = "<td>\\em None"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-prop-env \"Environment\""]
    #[doc = "<td>Empty"]
    #[doc = "<tr>"]
    #[doc = "<td>\\ref api-tir-trace-prop-user-attrs \"User attributes\""]
    #[doc = "<td>Empty \\bt_map_val"]
    #[doc = "</table>"]
    #[doc = ""]
    #[doc = "@param[in] trace_class"]
    #[doc = "Trace class from which to create the default trace."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New trace reference, or \\c NULL on memory error."]
    pub fn bt_trace_create(trace_class: *mut bt_trace_class) -> *mut bt_trace;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-trace-cls \"class\" of the trace"]
    #[doc = "\\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to borrow the class."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "\\em Borrowed reference of the class of \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_borrow_class_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_borrow_class(trace: *mut bt_trace) -> *mut bt_trace_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\ref api-tir-trace-cls \"class\" of the trace"]
    #[doc = "\\bt_p{trace} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_borrow_class()."]
    pub fn bt_trace_borrow_class_const(trace: *const bt_trace) -> *const bt_trace_class;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of \\bt_p_stream contained in the trace"]
    #[doc = "\\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to get the number of contained streams."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of contained streams in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    pub fn bt_trace_get_stream_count(trace: *const bt_trace) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream at index \\bt_p{index} from the"]
    #[doc = "trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to borrow the stream at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the stream to borrow from \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of"]
    #[doc = "\\bt_p{trace} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of streams in"]
    #[doc = "\\bt_p{trace} (as returned by"]
    #[doc = "bt_trace_get_stream_count())."]
    #[doc = ""]
    #[doc = "@sa bt_trace_get_stream_count() &mdash;"]
    #[doc = "Returns the number of streams contained in a trace."]
    #[doc = "@sa bt_trace_borrow_stream_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_borrow_stream_by_index(trace: *mut bt_trace, index: u64) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream at index \\bt_p{index} from the"]
    #[doc = "trace \\bt_p{trace} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_borrow_stream_by_index()."]
    pub fn bt_trace_borrow_stream_by_index_const(
        trace: *const bt_trace,
        index: u64,
    ) -> *const bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream having the numeric ID \\bt_p{id} from the"]
    #[doc = "trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "If there's no stream having the numeric ID \\bt_p{id} in"]
    #[doc = "\\bt_p{trace}, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to borrow the stream having the"]
    #[doc = "numeric ID \\bt_p{id}."]
    #[doc = "@param[in] id"]
    #[doc = "ID of the stream to borrow from \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the stream of"]
    #[doc = "\\bt_p{trace} having the numeric ID \\bt_p{id}, or \\c NULL"]
    #[doc = "if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "exists."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_borrow_stream_by_id_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_borrow_stream_by_id(trace: *mut bt_trace, id: u64) -> *mut bt_stream;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the \\bt_stream having the numeric ID \\bt_p{id} from the"]
    #[doc = "trace \\bt_p{trace} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_borrow_stream_by_id()."]
    pub fn bt_trace_borrow_stream_by_id_const(trace: *const bt_trace, id: u64) -> *const bt_stream;
}
pub mod bt_trace_set_name_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_SET_NAME_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_SET_NAME_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the name of the trace \\bt_p{trace} to a copy of \\bt_p{name}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to set the name to \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "New name of \\bt_p{trace} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_SET_NAME_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_SET_NAME_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_hot{trace}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_get_name() &mdash;"]
    #[doc = "Returns the name of a trace."]
    pub fn bt_trace_set_name(
        trace: *mut bt_trace,
        name: *const ::std::os::raw::c_char,
    ) -> bt_trace_set_name_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the name of the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-name \"name\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{trace} has no name, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to get the name."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Name of \\bt_p{trace}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_set_name() &mdash;"]
    #[doc = "Sets the name of a trace."]
    pub fn bt_trace_get_name(trace: *const bt_trace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the"]
    #[doc = "<a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier\">UUID</a>"]
    #[doc = "of the trace \\bt_p{trace} to a copy of \\bt_p{uuid}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-uuid \"UUID\" property."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to set the UUID to \\bt_p{uuid}."]
    #[doc = "@param[in] uuid"]
    #[doc = "New UUID of \\bt_p{trace} (copied)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_hot{trace}"]
    #[doc = "@bt_pre_not_null{uuid}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_get_uuid() &mdash;"]
    #[doc = "Returns the UUID of a trace."]
    pub fn bt_trace_set_uuid(trace: *mut bt_trace, uuid: bt_uuid);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the UUID of the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-uuid \"UUID\" property."]
    #[doc = ""]
    #[doc = "If \\bt_p{trace} has no UUID, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to get the UUID."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "UUID of \\bt_p{trace}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_set_uuid() &mdash;"]
    #[doc = "Sets the UUID of a trace."]
    pub fn bt_trace_get_uuid(trace: *const bt_trace) -> bt_uuid;
}
pub mod bt_trace_set_environment_entry_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_set_name()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the environment entry of the trace \\bt_p{trace}"]
    #[doc = "named \\bt_p{name} to the signed integer \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-env \"environment\" property."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{trace} already contains an environment entry named"]
    #[doc = "\\bt_p{name}, this function replaces the existing entry's value with"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace in which to insert or replace an environment entry named"]
    #[doc = "\\bt_p{name} with the value \\bt_p{value}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the entry to insert or replace in \\bt_p{trace} (copied)."]
    #[doc = "@param[in] value"]
    #[doc = "Value of the environment entry to insert or replace in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_hot{trace}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_set_environment_entry_string() &mdash;"]
    #[doc = "Sets a trace environment entry's value to a string."]
    pub fn bt_trace_set_environment_entry_integer(
        trace: *mut bt_trace,
        name: *const ::std::os::raw::c_char,
        value: i64,
    ) -> bt_trace_set_environment_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the value of the environment entry of the trace \\bt_p{trace}"]
    #[doc = "named \\bt_p{name} to the string \\bt_p{value}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-env \"environment\" property."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{trace} already contains an environment entry named"]
    #[doc = "\\bt_p{name}, this function replaces the existing entry's value with"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace in which to insert or replace an environment entry named"]
    #[doc = "\\bt_p{name} with the value \\bt_p{value}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the entry to insert or replace in \\bt_p{trace} (copied)."]
    #[doc = "@param[in] value"]
    #[doc = "Value of the environment entry to insert or replace in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_hot{trace}"]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_set_environment_entry_integer() &mdash;"]
    #[doc = "Sets a trace environment entry's value to a signed integer."]
    pub fn bt_trace_set_environment_entry_string(
        trace: *mut bt_trace,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bt_trace_set_environment_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the number of environment entries contained in the trace"]
    #[doc = "\\bt_p{trace}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-env \"environment\" property."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to get the number of environment entries."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Number of environment entries in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    pub fn bt_trace_get_environment_entry_count(trace: *const bt_trace) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the environment entry at index \\bt_p{index} from the"]
    #[doc = "trace \\bt_p{trace}, setting \\bt_p{*name} to its name and"]
    #[doc = "\\bt_p{*value} to its value."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-env \"environment\" property."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to borrow the environment entry at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the environment entry to borrow from \\bt_p{trace}."]
    #[doc = "@param[in] name"]
    #[doc = "@parblock"]
    #[doc = "<strong>On success</strong>, \\bt_p{*name} is the name of the"]
    #[doc = "environment entry at index \\bt_p{index} in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = "@param[in] value"]
    #[doc = "@parblock"]
    #[doc = "<strong>On success</strong>, \\bt_p{*value} is a \\em borrowed"]
    #[doc = "reference of the environment entry at index \\bt_p{index} in"]
    #[doc = "\\bt_p{trace}."]
    #[doc = ""]
    #[doc = "\\bt_p{*value} is either a \\bt_sint_val"]
    #[doc = "(#BT_VALUE_TYPE_SIGNED_INTEGER) or a \\bt_string_val"]
    #[doc = "(#BT_VALUE_TYPE_STRING)."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the number of environment entries in"]
    #[doc = "\\bt_p{trace} (as returned by"]
    #[doc = "bt_trace_get_environment_entry_count())."]
    #[doc = "@bt_pre_not_null{name}"]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_get_environment_entry_count() &mdash;"]
    #[doc = "Returns the number of environment entries contained in a trace."]
    pub fn bt_trace_borrow_environment_entry_by_index_const(
        trace: *const bt_trace,
        index: u64,
        name: *mut *const ::std::os::raw::c_char,
        value: *mut *const bt_value,
    );
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the value of the environment entry named \\bt_p{name}"]
    #[doc = "in the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-env \"environment\" property."]
    #[doc = ""]
    #[doc = "If there's no environment entry named \\bt_p{name} in \\bt_p{trace}, this"]
    #[doc = "function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to borrow the value of the environment entry"]
    #[doc = "named \\bt_p{name}."]
    #[doc = "@param[in] name"]
    #[doc = "Name of the environment entry to borrow from \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the value of the environment entry named"]
    #[doc = "\\bt_p{name} in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "The returned value is either a \\bt_sint_val"]
    #[doc = "(#BT_VALUE_TYPE_SIGNED_INTEGER) or a \\bt_string_val"]
    #[doc = "(#BT_VALUE_TYPE_STRING)."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid as long as \\bt_p{trace}"]
    #[doc = "is not modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_not_null{name}"]
    pub fn bt_trace_borrow_environment_entry_value_by_name_const(
        trace: *const bt_trace,
        name: *const ::std::os::raw::c_char,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the user attributes of the trace \\bt_p{trace} to"]
    #[doc = "\\bt_p{user_attributes}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default trace with bt_trace_create(), the trace's"]
    #[doc = "initial user attributes is an empty \\bt_map_val. Therefore you can"]
    #[doc = "borrow it with bt_trace_borrow_user_attributes() and fill it"]
    #[doc = "directly instead of setting a new one with this function."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace of which to set the user attributes to \\bt_p{user_attributes}."]
    #[doc = "@param[in] user_attributes"]
    #[doc = "New user attributes of \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_hot{trace}"]
    #[doc = "@bt_pre_not_null{user_attributes}"]
    #[doc = "@bt_pre_is_map_val{user_attributes}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_borrow_user_attributes() &mdash;"]
    #[doc = "Borrows the user attributes of a trace."]
    pub fn bt_trace_set_user_attributes(trace: *mut bt_trace, user_attributes: *const bt_value);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "See the \\ref api-tir-trace-prop-user-attrs \"user attributes\""]
    #[doc = "property."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "When you create a default trace with bt_trace_create(), the trace's"]
    #[doc = "initial user attributes is an empty \\bt_map_val."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to borrow the user attributes."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "User attributes of \\bt_p{trace} (a \\bt_map_val)."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_set_user_attributes() &mdash;"]
    #[doc = "Sets the user attributes of a trace."]
    #[doc = "@sa bt_trace_borrow_user_attributes_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_trace_borrow_user_attributes(trace: *mut bt_trace) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the user attributes of the trace \\bt_p{trace}"]
    #[doc = "(\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_trace_borrow_user_attributes()."]
    pub fn bt_trace_borrow_user_attributes_const(trace: *const bt_trace) -> *const bt_value;
}
#[doc = "@brief"]
#[doc = "User function for bt_trace_add_destruction_listener()."]
#[doc = ""]
#[doc = "This is the user function type for a trace destruction listener."]
#[doc = ""]
#[doc = "@param[in] trace"]
#[doc = "Trace being destroyed (\\ref api-fund-freezing \"frozen\")."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_trace_add_destruction_listener()."]
#[doc = ""]
#[doc = "@bt_pre_not_null{trace}"]
#[doc = ""]
#[doc = "@post"]
#[doc = "The reference count of \\bt_p{trace} is not changed."]
#[doc = "@bt_post_no_error"]
#[doc = ""]
#[doc = "@sa bt_trace_add_destruction_listener() &mdash;"]
#[doc = "Adds a destruction listener to a trace."]
pub type bt_trace_destruction_listener_func = ::std::option::Option<
    unsafe extern "C" fn(trace: *const bt_trace, user_data: *mut ::std::os::raw::c_void),
>;
pub mod bt_trace_add_listener_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_add_destruction_listener()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_ADD_LISTENER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_ADD_LISTENER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Adds a destruction listener having the function \\bt_p{user_func}"]
    #[doc = "to the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "All the destruction listener user functions of a trace are called"]
    #[doc = "when it's being destroyed."]
    #[doc = ""]
    #[doc = "If \\bt_p{listener_id} is not \\c NULL, then this function, on success,"]
    #[doc = "sets \\bt_p{*listener_id} to the ID of the added destruction listener"]
    #[doc = "within \\bt_p{trace}. You can then use this ID to remove the"]
    #[doc = "added destruction listener with bt_trace_remove_destruction_listener()."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace to add the destruction listener to."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function of the destruction listener to add to"]
    #[doc = "\\bt_p{trace}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = "@param[out] listener_id"]
    #[doc = "<strong>On success and if not \\c NULL</strong>, \\bt_p{*listener_id}"]
    #[doc = "is the ID of the added destruction listener within"]
    #[doc = "\\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_ADD_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_ADD_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    #[doc = ""]
    #[doc = "@sa bt_trace_remove_destruction_listener() &mdash;"]
    #[doc = "Removes a destruction listener from a trace."]
    pub fn bt_trace_add_destruction_listener(
        trace: *const bt_trace,
        user_func: bt_trace_destruction_listener_func,
        user_data: *mut ::std::os::raw::c_void,
        listener_id: *mut bt_listener_id,
    ) -> bt_trace_add_listener_status::Type;
}
pub mod bt_trace_remove_listener_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_trace_remove_destruction_listener()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_TRACE_REMOVE_LISTENER_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_TRACE_REMOVE_LISTENER_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Removes the destruction listener having the ID \\bt_p{listener_id}"]
    #[doc = "from the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "The destruction listener to remove from \\bt_p{trace} was"]
    #[doc = "previously added with bt_trace_add_destruction_listener()."]
    #[doc = ""]
    #[doc = "You can call this function when \\bt_p{trace} is"]
    #[doc = "\\ref api-fund-freezing \"frozen\"."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "Trace from which to remove the destruction listener having"]
    #[doc = "the ID \\bt_p{listener_id}."]
    #[doc = "@param[in] listener_id"]
    #[doc = "ID of the destruction listener to remove from \\bt_p{trace}\u{ad}."]
    #[doc = ""]
    #[doc = "@retval #BT_TRACE_REMOVE_LISTENER_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_TRACE_REMOVE_LISTENER_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{trace}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{listener_id} is the ID of an existing destruction listener"]
    #[doc = "in \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@sa bt_trace_add_destruction_listener() &mdash;"]
    #[doc = "Adds a destruction listener to a trace."]
    pub fn bt_trace_remove_destruction_listener(
        trace: *const bt_trace,
        listener_id: bt_listener_id,
    ) -> bt_trace_remove_listener_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "@parblock"]
    #[doc = "Trace of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_trace_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a trace."]
    pub fn bt_trace_get_ref(trace: *const bt_trace);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the trace \\bt_p{trace}."]
    #[doc = ""]
    #[doc = "@param[in] trace"]
    #[doc = "@parblock"]
    #[doc = "Trace of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_trace_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a trace."]
    pub fn bt_trace_put_ref(trace: *const bt_trace);
}
pub mod bt_util_clock_cycles_to_ns_from_origin_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_util_clock_cycles_to_ns_from_origin()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Integer overflow while computing the result."]
    pub const BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR: Type = -75;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Converts the clock value \\bt_p{cycles} from cycles to nanoseconds"]
    #[doc = "from the clock's origin and sets \\bt_p{*ns_from_origin} to the"]
    #[doc = "result."]
    #[doc = ""]
    #[doc = "This function considers the clock's frequency in Hz (\\bt_p{frequency}),"]
    #[doc = "an offset from its origin in seconds (\\bt_p{offset_seconds}) which"]
    #[doc = "can be negative, and an additional offset in cycles"]
    #[doc = "(\\bt_p{offset_cycles})."]
    #[doc = ""]
    #[doc = "This function:"]
    #[doc = ""]
    #[doc = "-# Converts the \\bt_p{offset_cycles} value to seconds using"]
    #[doc = "\\bt_p{frequency}."]
    #[doc = "-# Converts the \\bt_p{cycles} value to seconds using \\bt_p{frequency}."]
    #[doc = "-# Adds the values of 1., 2., and \\bt_p{offset_seconds}."]
    #[doc = "-# Converts the value of 3. to nanoseconds and sets"]
    #[doc = "\\bt_p{*ns_from_origin} to this result."]
    #[doc = ""]
    #[doc = "The following illustration shows the possible scenarios:"]
    #[doc = ""]
    #[doc = "@image html clock-terminology.png"]
    #[doc = ""]
    #[doc = "\\bt_p{offset_seconds} can be negative. For example, considering:"]
    #[doc = ""]
    #[doc = "- A 1000&nbsp;Hz clock."]
    #[doc = "- \\bt_p{offset_seconds} set to -10&nbsp;seconds."]
    #[doc = "- \\bt_p{offset_cycles} set to 500&nbsp;cycles"]
    #[doc = "(that is, 0.5&nbsp;seconds)."]
    #[doc = "- \\bt_p{cycles} set to 2000&nbsp;cycles (that is, 2&nbsp;seconds)."]
    #[doc = ""]
    #[doc = "The computed value is -7.5&nbsp;seconds, so this function sets"]
    #[doc = "\\bt_p{*ns_from_origin} to -7,500,000,000."]
    #[doc = ""]
    #[doc = "This function can fail and return the"]
    #[doc = "#BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR status"]
    #[doc = "code if any step of the computation process causes an integer overflow."]
    #[doc = ""]
    #[doc = "@param[in] cycles"]
    #[doc = "Clock's value (cycles)."]
    #[doc = "@param[in] frequency"]
    #[doc = "Clock's frequency (Hz, or cycles/second)."]
    #[doc = "@param[in] offset_seconds"]
    #[doc = "Offset, in seconds, from the clock's origin to add to"]
    #[doc = "\\bt_p{cycles} (once converted to seconds)."]
    #[doc = "@param[in] offset_cycles"]
    #[doc = "Offset, in cycles, to add to \\bt_p{cycles}."]
    #[doc = "@param[out] ns_from_origin"]
    #[doc = "<strong>On success</strong>, \\bt_p{*ns_from_origin} is \\bt_p{cycles}"]
    #[doc = "converted to nanoseconds from origin considering the clock's"]
    #[doc = "properties."]
    #[doc = ""]
    #[doc = "@retval #BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR"]
    #[doc = "Integer overflow while computing the result."]
    #[doc = ""]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is not 0."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is not <code>UINT64_C(-1)</code>."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{frequency} is greater than \\bt_p{offset_cycles}."]
    #[doc = "@pre"]
    #[doc = "\\bt_p{offset_cycles} is less than \\bt_p{frequency}."]
    #[doc = "@bt_pre_not_null{ns_from_origin}"]
    #[doc = ""]
    #[doc = "@sa bt_clock_class_cycles_to_ns_from_origin() &mdash;"]
    #[doc = "Converts a stream clock value from cycles to nanoseconds from the"]
    #[doc = "origin of a given clock class."]
    pub fn bt_util_clock_cycles_to_ns_from_origin(
        cycles: u64,
        frequency: u64,
        offset_seconds: i64,
        offset_cycles: u64,
        ns_from_origin: *mut i64,
    ) -> bt_util_clock_cycles_to_ns_from_origin_status::Type;
}
pub mod bt_value_type {
    #[doc = "@brief"]
    #[doc = "Value type enumerators."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "@brief"]
    #[doc = "Null value."]
    pub const BT_VALUE_TYPE_NULL: Type = 1;
    #[doc = "@brief"]
    #[doc = "Boolean value."]
    pub const BT_VALUE_TYPE_BOOL: Type = 2;
    #[doc = "@brief"]
    #[doc = "Integer value."]
    #[doc = ""]
    #[doc = "No value has this type: use it with bt_value_type_is()."]
    pub const BT_VALUE_TYPE_INTEGER: Type = 4;
    #[doc = "@brief"]
    #[doc = "Unsigned integer value."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_VALUE_TYPE_INTEGER."]
    pub const BT_VALUE_TYPE_UNSIGNED_INTEGER: Type = 12;
    #[doc = "@brief"]
    #[doc = "Signed integer value."]
    #[doc = ""]
    #[doc = "This type conceptually inherits #BT_VALUE_TYPE_INTEGER."]
    pub const BT_VALUE_TYPE_SIGNED_INTEGER: Type = 20;
    #[doc = "@brief"]
    #[doc = "Real value."]
    pub const BT_VALUE_TYPE_REAL: Type = 32;
    #[doc = "@brief"]
    #[doc = "String value."]
    pub const BT_VALUE_TYPE_STRING: Type = 64;
    #[doc = "@brief"]
    #[doc = "Array value."]
    pub const BT_VALUE_TYPE_ARRAY: Type = 128;
    #[doc = "@brief"]
    #[doc = "Map value."]
    pub const BT_VALUE_TYPE_MAP: Type = 256;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the type enumerator of the value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Value of which to get the type enumerator"]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Type enumerator of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_type_is() &mdash;"]
    #[doc = "Returns whether or not the type of a value conceptually is a given"]
    #[doc = "type."]
    #[doc = "@sa bt_value_is_null() &mdash;"]
    #[doc = "Returns whether or not a value is a null value."]
    #[doc = "@sa bt_value_is_bool() &mdash;"]
    #[doc = "Returns whether or not a value is a boolean value."]
    #[doc = "@sa bt_value_is_unsigned_integer() &mdash;"]
    #[doc = "Returns whether or not a value is an unsigned integer value."]
    #[doc = "@sa bt_value_is_signed_integer() &mdash;"]
    #[doc = "Returns whether or not a value is a signed integer value."]
    #[doc = "@sa bt_value_is_real() &mdash;"]
    #[doc = "Returns whether or not a value is a real value."]
    #[doc = "@sa bt_value_is_string() &mdash;"]
    #[doc = "Returns whether or not a value is a string value."]
    #[doc = "@sa bt_value_is_array() &mdash;"]
    #[doc = "Returns whether or not a value is an array value."]
    #[doc = "@sa bt_value_is_map() &mdash;"]
    #[doc = "Returns whether or not a value is a map value."]
    pub fn bt_value_get_type(value: *const bt_value) -> bt_value_type::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "The null value singleton."]
    #[doc = ""]
    #[doc = "This is the \\em only instance of a null value."]
    #[doc = ""]
    #[doc = "Like any type of value, the null value is a shared object: if you get a"]
    #[doc = "new null value reference with bt_value_get_ref(), you must eventually"]
    #[doc = "put it with bt_value_put_ref(). The null value singleton's reference"]
    #[doc = "count must never reach 0: libbabeltrace2 logs a warning message when"]
    #[doc = "this programming error occurs."]
    #[doc = ""]
    #[doc = "Because all null values point to the same null value singleton, you can"]
    #[doc = "directly compare a value to the \\c bt_value_null variable."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "@parblock"]
    #[doc = "\\c bt_value_null is different from \\c NULL: the former is a true"]
    #[doc = "\\bt_name value object while the latter is a C definition which"]
    #[doc = "usually means \"no pointer\"."]
    #[doc = ""]
    #[doc = "For example, bt_value_map_borrow_entry_value() can return"]
    #[doc = "\\c bt_value_null if the requested key is mapped to a null value, but"]
    #[doc = "it can also return \\c NULL if the key is not found."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_value_is_null() &mdash;"]
    #[doc = "Returns whether or not a value is a null value."]
    pub static bt_value_null: *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a boolean value initialized to #BT_FALSE."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_BOOL."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New boolean value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_create_init() &mdash;"]
    #[doc = "Creates a boolean value with a given initial raw value."]
    pub fn bt_value_bool_create() -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a boolean value initialized to \\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_BOOL."]
    #[doc = ""]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the boolean value to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New boolean value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_create() &mdash;"]
    #[doc = "Creates a boolean value initialized to #BT_FALSE."]
    pub fn bt_value_bool_create_init(raw_value: bt_bool) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the raw value of the boolean value \\bt_p{value} to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Boolean value of which to set the raw value to \\bt_p{raw_value}."]
    #[doc = "@param[in] raw_value"]
    #[doc = "New raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_bool_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_get() &mdash;"]
    #[doc = "Returns the raw value of a boolean value."]
    pub fn bt_value_bool_set(value: *mut bt_value, raw_value: bt_bool);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the raw value of the boolean value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Boolean value of which to get the raw value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_bool_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_set() &mdash;"]
    #[doc = "Sets the raw value of a boolean value."]
    pub fn bt_value_bool_get(value: *const bt_value) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an unsigned integer value initialized to 0."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_UNSIGNED_INTEGER."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New unsigned integer value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_unsigned_create_init() &mdash;"]
    #[doc = "Creates an unsigned integer value with a given initial raw value."]
    pub fn bt_value_integer_unsigned_create() -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an unsigned integer value initialized to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_UNSIGNED_INTEGER."]
    #[doc = ""]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the unsigned integer value to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New unsigned integer value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_create() &mdash;"]
    #[doc = "Creates an unsigned integer value initialized to 0."]
    pub fn bt_value_integer_unsigned_create_init(raw_value: u64) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the raw value of the unsigned integer value \\bt_p{value} to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Unsigned integer value of which to set the raw value to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = "@param[in] raw_value"]
    #[doc = "New raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_uint_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_unsigned_get() &mdash;"]
    #[doc = "Returns the raw value of an unsigned integer value."]
    pub fn bt_value_integer_unsigned_set(value: *mut bt_value, raw_value: u64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the raw value of the unsigned integer value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Unsigned integer value of which to get the raw value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_uint_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_unsigned_set() &mdash;"]
    #[doc = "Sets the raw value of an unsigned integer value."]
    pub fn bt_value_integer_unsigned_get(value: *const bt_value) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a signed integer value initialized to 0."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_SIGNED_INTEGER."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New signed integer value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_signed_create_init() &mdash;"]
    #[doc = "Creates a signed integer value with a given initial raw value."]
    pub fn bt_value_integer_signed_create() -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a signed integer value initialized to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_SIGNED_INTEGER."]
    #[doc = ""]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the signed integer value to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New signed integer value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_bool_create() &mdash;"]
    #[doc = "Creates a signed integer value initialized to 0."]
    pub fn bt_value_integer_signed_create_init(raw_value: i64) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the raw value of the signed integer value \\bt_p{value} to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Signed integer value of which to set the raw value to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = "@param[in] raw_value"]
    #[doc = "New raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_sint_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_signed_get() &mdash;"]
    #[doc = "Returns the raw value of a signed integer value."]
    pub fn bt_value_integer_signed_set(value: *mut bt_value, raw_value: i64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the raw value of the signed integer value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Signed integer value of which to get the raw value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_sint_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_integer_signed_set() &mdash;"]
    #[doc = "Sets the raw value of a signed integer value."]
    pub fn bt_value_integer_signed_get(value: *const bt_value) -> i64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a real value initialized to 0."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_REAL."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New real value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_real_create_init() &mdash;"]
    #[doc = "Creates a real value with a given initial raw value."]
    pub fn bt_value_real_create() -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a real value initialized to \\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_REAL."]
    #[doc = ""]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the real value to create."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New real value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_real_create() &mdash;"]
    #[doc = "Creates a real value initialized to 0."]
    pub fn bt_value_real_create_init(raw_value: f64) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the raw value of the real value \\bt_p{value} to"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Real value of which to set the raw value to \\bt_p{raw_value}."]
    #[doc = "@param[in] raw_value"]
    #[doc = "New raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_real_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_real_get() &mdash;"]
    #[doc = "Returns the raw value of a real value."]
    pub fn bt_value_real_set(value: *mut bt_value, raw_value: f64);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the raw value of the real value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Real value of which to get the raw value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_real_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_real_set() &mdash;"]
    #[doc = "Sets the raw value of a real value."]
    pub fn bt_value_real_get(value: *const bt_value) -> f64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an empty string value."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_STRING."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New string value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@sa bt_value_string_create_init() &mdash;"]
    #[doc = "Creates a string value with a given initial raw value."]
    pub fn bt_value_string_create() -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns a string value initialized to a copy of"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_STRING."]
    #[doc = ""]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the string value to create (copied)."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New string value reference, or \\c NULL on memory error."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{raw_value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_string_create() &mdash;"]
    #[doc = "Creates an empty string value."]
    pub fn bt_value_string_create_init(raw_value: *const ::std::os::raw::c_char) -> *mut bt_value;
}
pub mod bt_value_string_set_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_string_set()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_STRING_SET_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_STRING_SET_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the raw value of the string value \\bt_p{value} to a copy of"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "String value of which to set the raw value to a copy of"]
    #[doc = "\\bt_p{raw_value}."]
    #[doc = "@param[in] raw_value"]
    #[doc = "New raw value of \\bt_p{value} (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_STRING_SET_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_STRING_SET_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_string_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{raw_value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_string_get() &mdash;"]
    #[doc = "Returns the raw value of a string value."]
    pub fn bt_value_string_set(
        value: *mut bt_value,
        raw_value: *const ::std::os::raw::c_char,
    ) -> bt_value_string_set_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the raw value of the string value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "String value of which to get the raw value."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Raw value of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{value} is modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_string_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_string_set() &mdash;"]
    #[doc = "Sets the raw value of a string value."]
    pub fn bt_value_string_get(value: *const bt_value) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an empty array value."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_ARRAY."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New array value reference, or \\c NULL on memory error."]
    pub fn bt_value_array_create() -> *mut bt_value;
}
pub mod bt_value_array_append_element_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the <code>bt_value_array_append_*()</code>"]
    #[doc = "functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Appends the value \\bt_p{element_value} to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "To append a null value, pass #bt_value_null as \\bt_p{element_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append \\bt_p{element_value}."]
    #[doc = "@param[in] element_value"]
    #[doc = "Value to append to \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{element_value}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{element_value} does not contain \\bt_p{value}, recursively."]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_bool_element() &mdash;"]
    #[doc = "Creates and appends a boolean value to an array value."]
    #[doc = "@sa bt_value_array_append_unsigned_integer_element() &mdash;"]
    #[doc = "Creates and appends an unsigned integer value to an array value."]
    #[doc = "@sa bt_value_array_append_signed_integer_element() &mdash;"]
    #[doc = "Creates and appends a signed integer value to an array value."]
    #[doc = "@sa bt_value_array_append_real_element() &mdash;"]
    #[doc = "Creates and appends a real value to an array value."]
    #[doc = "@sa bt_value_array_append_string_element() &mdash;"]
    #[doc = "Creates and appends a string value to an array value."]
    #[doc = "@sa bt_value_array_append_empty_array_element() &mdash;"]
    #[doc = "Creates and appends an empty array value to an array value."]
    #[doc = "@sa bt_value_array_append_empty_map_element() &mdash;"]
    #[doc = "Creates and appends an empty map value to an array value."]
    pub fn bt_value_array_append_element(
        value: *mut bt_value,
        element_value: *mut bt_value,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a boolean value initialized to \\bt_p{raw_value} and appends"]
    #[doc = "it to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created boolean value."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Raw value of the boolean value to create and append to \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_bool_element(
        value: *mut bt_value,
        raw_value: bt_bool,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an unsigned integer value initialized to \\bt_p{raw_value}"]
    #[doc = "and appends it to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created unsigned integer value."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Raw value of the unsigned integer value to create and append to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_unsigned_integer_element(
        value: *mut bt_value,
        raw_value: u64,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a signed integer value initialized to \\bt_p{raw_value} and"]
    #[doc = "appends it to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created signed integer value."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Raw value of the signed integer value to create and append to"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_signed_integer_element(
        value: *mut bt_value,
        raw_value: i64,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a real value initialized to \\bt_p{raw_value} and appends"]
    #[doc = "it to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created real value."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Raw value of the real value to create and append to \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_real_element(
        value: *mut bt_value,
        raw_value: f64,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a string value initialized to a copy of \\bt_p{raw_value} and"]
    #[doc = "appends it to the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created string value."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Raw value of the string value to create and append to \\bt_p{value}"]
    #[doc = "(copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_string_element(
        value: *mut bt_value,
        raw_value: *const ::std::os::raw::c_char,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an empty array value and appends it to the array"]
    #[doc = "value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{element_value} is not \\c NULL, this function sets"]
    #[doc = "\\bt_p{*element_value} to a \\em borrowed reference of the created empty"]
    #[doc = "array value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created empty array value."]
    #[doc = "@param[out] element_value"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*element_value}"]
    #[doc = "is a \\em borrowed reference of the created empty array value."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_empty_array_element(
        value: *mut bt_value,
        element_value: *mut *mut bt_value,
    ) -> bt_value_array_append_element_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an empty map value and appends it to the array"]
    #[doc = "value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{element_value} is not \\c NULL, this function sets"]
    #[doc = "\\bt_p{*element_value} to a \\em borrowed reference of the created empty"]
    #[doc = "map value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value to which to append the created empty array value."]
    #[doc = "@param[out] element_value"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*element_value}"]
    #[doc = "is a \\em borrowed reference of the created empty map value."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends an existing value to an array value."]
    pub fn bt_value_array_append_empty_map_element(
        value: *mut bt_value,
        element_value: *mut *mut bt_value,
    ) -> bt_value_array_append_element_status::Type;
}
pub mod bt_value_array_set_element_by_index_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_array_set_element_by_index()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Sets the element of the array value \\bt_p{value} at index"]
    #[doc = "\\bt_p{index} to the value \\bt_p{element_value}."]
    #[doc = ""]
    #[doc = "On success, this function replaces the existing element of \\bt_p{value}"]
    #[doc = "at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value of which to set the element at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the element to set in \\bt_p{value}."]
    #[doc = "@param[in] element_value"]
    #[doc = "Value to set as the element of \\bt_p{value} at index \\bt_p{index}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the length of \\bt_p{value} (as returned by"]
    #[doc = "bt_value_array_get_length())."]
    #[doc = "@bt_pre_not_null{element_value}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{element_value} does not contain \\bt_p{value}, recursively."]
    #[doc = ""]
    #[doc = "@post"]
    #[doc = "<strong>On success</strong>, the length of \\bt_p{value} is"]
    #[doc = "incremented."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_append_element() &mdash;"]
    #[doc = "Appends a value to an array value."]
    pub fn bt_value_array_set_element_by_index(
        value: *mut bt_value,
        index: u64,
        element_value: *mut bt_value,
    ) -> bt_value_array_set_element_by_index_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the element at index \\bt_p{index} from the array value"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value from which to borrow the element at index \\bt_p{index}."]
    #[doc = "@param[in] index"]
    #[doc = "Index of the element to borrow from \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the element of \\bt_p{value} at index"]
    #[doc = "\\bt_p{index}."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{value} is modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{index} is less than the length of \\bt_p{value} (as returned by"]
    #[doc = "bt_value_array_get_length())."]
    #[doc = ""]
    #[doc = "@sa bt_value_array_borrow_element_by_index_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    pub fn bt_value_array_borrow_element_by_index(
        value: *mut bt_value,
        index: u64,
    ) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the element at index \\bt_p{index} from the array value"]
    #[doc = "\\bt_p{value} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_value_array_borrow_element_by_index()."]
    pub fn bt_value_array_borrow_element_by_index_const(
        value: *const bt_value,
        index: u64,
    ) -> *const bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the length of the array value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Array value of which to get the length."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Length (number of contained elements) of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_array_is_empty() &mdash;"]
    #[doc = "Returns whether or not an array value is empty."]
    pub fn bt_value_array_get_length(value: *const bt_value) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates and returns an empty map value."]
    #[doc = ""]
    #[doc = "The returned value has the type #BT_VALUE_TYPE_MAP."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "New map value reference, or \\c NULL on memory error."]
    pub fn bt_value_map_create() -> *mut bt_value;
}
pub mod bt_value_map_insert_entry_status {
    #[doc = "@brief"]
    #[doc = "Status codes for the <code>bt_value_map_insert_*()</code> functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Inserts or replaces an entry with the key \\bt_p{key} and the value"]
    #[doc = "\\bt_p{entry_value} in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "To insert an entry having a null value, pass #bt_value_null as"]
    #[doc = "\\bt_p{entry_value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with"]
    #[doc = "\\bt_p{entry_value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and value \\bt_p{entry_value}."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] entry_value"]
    #[doc = "Value of the entry to insert or replace in \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = "@bt_pre_not_null{entry_value}"]
    #[doc = "@pre"]
    #[doc = "\\bt_p{entry_value} does not contain \\bt_p{value}, recursively."]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_bool_entry() &mdash;"]
    #[doc = "Creates a boolean value and uses it to insert an entry in a map"]
    #[doc = "value."]
    #[doc = "@sa bt_value_map_insert_unsigned_integer_entry() &mdash;"]
    #[doc = "Creates an unsigned integer value and uses it to insert an entry in"]
    #[doc = "a map value."]
    #[doc = "@sa bt_value_map_insert_signed_integer_entry() &mdash;"]
    #[doc = "Creates a signed value and uses it to insert an entry in a map"]
    #[doc = "value."]
    #[doc = "@sa bt_value_map_insert_real_entry() &mdash;"]
    #[doc = "Creates a real value and uses it to insert an entry in a map value."]
    #[doc = "@sa bt_value_map_insert_string_entry() &mdash;"]
    #[doc = "Creates a string value and uses it to insert an entry in a map"]
    #[doc = "value."]
    #[doc = "@sa bt_value_map_insert_empty_array_entry() &mdash;"]
    #[doc = "Creates an empty array value and uses it to insert an entry in a map"]
    #[doc = "value."]
    #[doc = "@sa bt_value_map_insert_empty_map_entry() &mdash;"]
    #[doc = "Creates a map value and uses it to insert an entry in a map value."]
    pub fn bt_value_map_insert_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        entry_value: *mut bt_value,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a boolean value initialized to \\bt_p{raw_value} and"]
    #[doc = "inserts or replaces an entry with the key \\bt_p{key} and this value"]
    #[doc = "in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created boolean value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created boolean value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the boolean value to create."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_bool_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        raw_value: bt_bool,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an unsigned integer value initialized to \\bt_p{raw_value}"]
    #[doc = "and inserts or replaces an entry with the key \\bt_p{key} and this"]
    #[doc = "value in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created unsigned integer value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created unsigned integer value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the unsigned integer value to create."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_unsigned_integer_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        raw_value: u64,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a signed integer value initialized to \\bt_p{raw_value} and"]
    #[doc = "inserts or replaces an entry with the key \\bt_p{key} and this value"]
    #[doc = "in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created signed integer value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created signed integer value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the signed integer value to create."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_signed_integer_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        raw_value: i64,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a real value initialized to \\bt_p{raw_value} and inserts or"]
    #[doc = "replaces an entry with the key \\bt_p{key} and this value in the map"]
    #[doc = "value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created real value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created real value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the real value to create."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_real_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        raw_value: f64,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates a string value initialized to a copy of \\bt_p{raw_value} and"]
    #[doc = "inserts or replaces an entry with the key \\bt_p{key} and this value"]
    #[doc = "in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created string value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created string value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[in] raw_value"]
    #[doc = "Initial raw value of the string value to create (copied)."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_string_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        raw_value: *const ::std::os::raw::c_char,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an empty array value and inserts or replaces an entry with"]
    #[doc = "the key \\bt_p{key} and this value in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{entry_value} is not \\c NULL, this function sets"]
    #[doc = "\\bt_p{*entry_value} to a \\em borrowed reference of the created empty"]
    #[doc = "array value."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created empty array value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created empty array value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[out] entry_value"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*entry_value} is"]
    #[doc = "a \\em borrowed reference of the created empty array value."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_empty_array_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        entry_value: *mut *mut bt_value,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Creates an empty map value and inserts or replaces an entry with"]
    #[doc = "the key \\bt_p{key} and this value in the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{entry_value} is not \\c NULL, this function sets"]
    #[doc = "\\bt_p{*entry_value} to a \\em borrowed reference of the created empty map"]
    #[doc = "value."]
    #[doc = ""]
    #[doc = "On success, if \\bt_p{value} already contains an entry with key"]
    #[doc = "\\bt_p{key}, this function replaces the existing entry's value with the"]
    #[doc = "created empty map value."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value in which to insert or replace an entry with key \\bt_p{key}"]
    #[doc = "and the created empty map value."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry to insert or replace in \\bt_p{value} (copied)."]
    #[doc = "@param[out] entry_value"]
    #[doc = "<strong>On success, if not \\c NULL</strong>, \\bt_p{*entry_value} is"]
    #[doc = "a \\em borrowed reference of the created empty map value."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_hot{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_insert_entry() &mdash;"]
    #[doc = "Inserts an entry with an existing value in a map value."]
    pub fn bt_value_map_insert_empty_map_entry(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
        entry_value: *mut *mut bt_value,
    ) -> bt_value_map_insert_entry_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the value of the entry with the key \\bt_p{key} in the map"]
    #[doc = "value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "If no entry with key \\bt_p{key} exists in \\bt_p{value}, this function"]
    #[doc = "returns \\c NULL."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value from which to borrow the value of the entry with the"]
    #[doc = "key \\bt_p{key}."]
    #[doc = "@param[in] key"]
    #[doc = "Key of the entry from which to borrow the value in \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "\\em Borrowed reference of the value of the entry with key \\bt_p{key}"]
    #[doc = "in \\bt_p{value}, or \\c NULL if none."]
    #[doc = ""]
    #[doc = "The returned pointer remains valid until \\bt_p{value} is modified."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_array_val{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_borrow_entry_value_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    #[doc = "@sa bt_value_map_has_entry() &mdash;"]
    #[doc = "Returns whether or not a map value has an entry with a given key."]
    pub fn bt_value_map_borrow_entry_value(
        value: *mut bt_value,
        key: *const ::std::os::raw::c_char,
    ) -> *mut bt_value;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Borrows the value of the entry with the key \\bt_p{key} in the map"]
    #[doc = "value \\bt_p{value} (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_value_map_borrow_entry_value()."]
    pub fn bt_value_map_borrow_entry_value_const(
        value: *const bt_value,
        key: *const ::std::os::raw::c_char,
    ) -> *const bt_value;
}
pub mod bt_value_map_foreach_entry_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_value_map_foreach_entry_func."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Interrupt the iteration process."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_INTERRUPT: Type = 4;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User function for bt_value_map_foreach_entry()."]
#[doc = ""]
#[doc = "This is the type of the user function that bt_value_map_foreach_entry()"]
#[doc = "calls for each entry of the map value."]
#[doc = ""]
#[doc = "@param[in] key"]
#[doc = "Key of the map value entry."]
#[doc = "@param[in] value"]
#[doc = "Value of the map value entry."]
#[doc = "@param[in] user_data"]
#[doc = "User data, as passed as the \\bt_p{user_data} parameter of"]
#[doc = "bt_value_map_foreach_entry()."]
#[doc = ""]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_INTERRUPT"]
#[doc = "Interrupt the iteration process."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{key}"]
#[doc = "@bt_pre_not_null{value}"]
#[doc = ""]
#[doc = "@sa bt_value_map_foreach_entry() &mdash;"]
#[doc = "Iterates the entries of a map value."]
pub type bt_value_map_foreach_entry_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *mut bt_value,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_value_map_foreach_entry_func_status::Type,
>;
pub mod bt_value_map_foreach_entry_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_map_foreach_entry()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "User function interrupted the iteration process."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_STATUS_INTERRUPTED: Type = 4;
    #[doc = "@brief"]
    #[doc = "User function error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_STATUS_USER_ERROR: Type = -2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Iterates the entries of the map value \\bt_p{value}, calling"]
    #[doc = "\\bt_p{user_func} for each entry."]
    #[doc = ""]
    #[doc = "This function iterates the entries of \\bt_p{value} in no particular"]
    #[doc = "order."]
    #[doc = ""]
    #[doc = "@attention"]
    #[doc = "You must \\em not modify \\bt_p{value} during the iteration process."]
    #[doc = ""]
    #[doc = "\\bt_p{user_func} receives \\bt_p{user_data} as its last parameter."]
    #[doc = ""]
    #[doc = "The iteration process stops when one of:"]
    #[doc = ""]
    #[doc = "- \\bt_p{user_func} was called for each entry."]
    #[doc = "- \\bt_p{user_func} does not return"]
    #[doc = "#BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_OK."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value of which to iterate the entries."]
    #[doc = "@param[in] user_func"]
    #[doc = "User function to call for each entry of \\bt_p{value}."]
    #[doc = "@param[in] user_data"]
    #[doc = "User data to pass as the \\bt_p{user_data} parameter of each call to"]
    #[doc = "\\bt_p{user_func}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_STATUS_INTERRUPTED"]
    #[doc = "\\bt_p{user_func} returned"]
    #[doc = "#BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_INTERRUPT to interrupt the"]
    #[doc = "iteration process."]
    #[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_STATUS_USER_ERROR"]
    #[doc = "\\bt_p{user_func} returned"]
    #[doc = "#BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_ERROR."]
    #[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_STATUS_ERROR"]
    #[doc = "Other error caused the <code>bt_value_map_foreach_entry()</code>"]
    #[doc = "function itself."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_not_null{user_func}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_foreach_entry_const() &mdash;"]
    #[doc = "\\c const version of this function."]
    #[doc = "@sa bt_value_map_borrow_entry_value() &mdash;"]
    #[doc = "Borrows the value of a specific map value entry."]
    pub fn bt_value_map_foreach_entry(
        value: *mut bt_value,
        user_func: bt_value_map_foreach_entry_func,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_value_map_foreach_entry_status::Type;
}
pub mod bt_value_map_foreach_entry_const_func_status {
    #[doc = "@brief"]
    #[doc = "Status codes for #bt_value_map_foreach_entry_const_func."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Interrupt the iteration process."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_INTERRUPT: Type = 4;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "User error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_ERROR: Type = -1;
}
#[doc = "@brief"]
#[doc = "User function for bt_value_map_foreach_entry_const_func()."]
#[doc = ""]
#[doc = "This is the type of the user function that"]
#[doc = "bt_value_map_foreach_entry_const_func() calls for each entry of the map"]
#[doc = "value."]
#[doc = ""]
#[doc = "@param[in] key"]
#[doc = "Key of the map value entry."]
#[doc = "@param[in] value"]
#[doc = "Value of the map value entry."]
#[doc = "@param[in] user_data"]
#[doc = "User data."]
#[doc = ""]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_OK"]
#[doc = "Success."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_INTERRUPT"]
#[doc = "Interrupt the iteration process."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_MEMORY_ERROR"]
#[doc = "Out of memory."]
#[doc = "@retval #BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_ERROR"]
#[doc = "User error."]
#[doc = ""]
#[doc = "@bt_pre_not_null{key}"]
#[doc = "@bt_pre_not_null{value}"]
#[doc = ""]
#[doc = "@sa bt_value_map_foreach_entry_const() &mdash;"]
#[doc = "Iterates the entries of a \\c const map value."]
pub type bt_value_map_foreach_entry_const_func = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *const bt_value,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_value_map_foreach_entry_const_func_status::Type,
>;
pub mod bt_value_map_foreach_entry_const_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_map_foreach_entry_const()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "User function interrupted the iteration process."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_INTERRUPTED: Type = 4;
    #[doc = "@brief"]
    #[doc = "User function error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_USER_ERROR: Type = -2;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_MEMORY_ERROR: Type = -12;
    #[doc = "@brief"]
    #[doc = "Other error."]
    pub const BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_ERROR: Type = -1;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Iterates the entries of the map value \\bt_p{value}, calling"]
    #[doc = "\\bt_p{user_func} for each entry (\\c const version)."]
    #[doc = ""]
    #[doc = "See bt_value_map_foreach_entry()."]
    #[doc = ""]
    #[doc = "@sa bt_value_map_borrow_entry_value_const() &mdash;"]
    #[doc = "Borrows the value of a specific map value entry."]
    pub fn bt_value_map_foreach_entry_const(
        value: *const bt_value,
        user_func: bt_value_map_foreach_entry_const_func,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bt_value_map_foreach_entry_const_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the size of the map value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value of which to get the size."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Size (number of contained entries) of \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_is_empty() &mdash;"]
    #[doc = "Returns whether or not a map value is empty."]
    pub fn bt_value_map_get_size(value: *const bt_value) -> u64;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the map value \\bt_p{value} has an entry with"]
    #[doc = "the key \\bt_p{key}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value to check."]
    #[doc = "@param[in] key"]
    #[doc = "Key to check."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{value} has an entry with the key \\bt_p{key}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_not_null{key}"]
    #[doc = ""]
    #[doc = "@sa bt_value_map_borrow_entry_value_const() &mdash;"]
    #[doc = "Borrows the value of a specific map value entry."]
    pub fn bt_value_map_has_entry(
        value: *const bt_value,
        key: *const ::std::os::raw::c_char,
    ) -> bt_bool;
}
pub mod bt_value_map_extend_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_map_extend()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_MAP_EXTEND_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_MAP_EXTEND_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Extends the map value \\bt_p{value} with the map value"]
    #[doc = "\\bt_p{extension_value}."]
    #[doc = ""]
    #[doc = "For each entry in \\bt_p{extension_value}, this function calls"]
    #[doc = "bt_value_map_insert_entry() to insert or replace it in the map value"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "For example, with:"]
    #[doc = ""]
    #[doc = "<dl>"]
    #[doc = "<dt>"]
    #[doc = "\\bt_p{value}"]
    #[doc = "</dt>"]
    #[doc = "<dd>"]
    #[doc = "@code{.json}"]
    #[doc = "{"]
    #[doc = "\"man\": \"giant\","]
    #[doc = "\"strange\": 23"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</dd>"]
    #[doc = ""]
    #[doc = "<dt>"]
    #[doc = "\\bt_p{extension_value}"]
    #[doc = "</dt>"]
    #[doc = "<dd>"]
    #[doc = "@code{.json}"]
    #[doc = "{"]
    #[doc = "\"balance\": -17"]
    #[doc = "\"strange\": false"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = "</dd>"]
    #[doc = "</dl>"]
    #[doc = ""]
    #[doc = "The map value \\bt_p{value} becomes:"]
    #[doc = ""]
    #[doc = "@code{.json}"]
    #[doc = "{"]
    #[doc = "\"man\": \"giant\","]
    #[doc = "\"strange\": false,"]
    #[doc = "\"balance\": -17"]
    #[doc = "}"]
    #[doc = "@endcode"]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Map value to extend."]
    #[doc = "@param[in] extension_value"]
    #[doc = "Extension map value."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_MAP_EXTEND_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_MAP_EXTEND_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_is_map_val{value}"]
    #[doc = "@bt_pre_not_null{extension_value}"]
    #[doc = "@bt_pre_is_map_val{extension_value}"]
    #[doc = ""]
    #[doc = "@sa bt_value_copy() &mdash;"]
    #[doc = "Deep-copies a value."]
    pub fn bt_value_map_extend(
        value: *mut bt_value,
        extension_value: *const bt_value,
    ) -> bt_value_map_extend_status::Type;
}
pub mod bt_value_copy_status {
    #[doc = "@brief"]
    #[doc = "Status codes for bt_value_copy()."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "@brief"]
    #[doc = "Success."]
    pub const BT_VALUE_COPY_STATUS_OK: Type = 0;
    #[doc = "@brief"]
    #[doc = "Out of memory."]
    pub const BT_VALUE_COPY_STATUS_MEMORY_ERROR: Type = -12;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Deep-copies a value object."]
    #[doc = ""]
    #[doc = "This function deep-copies \\bt_p{value} and sets \\bt_p{*copy} to the"]
    #[doc = "result."]
    #[doc = ""]
    #[doc = "Because \\bt_p{*copy} is a deep copy, it does not contain, recursively,"]
    #[doc = "any reference that \\bt_p{value} contains, but the raw values are"]
    #[doc = "identical."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "Value to deep-copy."]
    #[doc = "@param[in] copy_value"]
    #[doc = "<strong>On success</strong>, \\bt_p{*copy_value} is a deep copy of"]
    #[doc = "\\bt_p{value}."]
    #[doc = ""]
    #[doc = "@retval #BT_VALUE_COPY_STATUS_OK"]
    #[doc = "Success."]
    #[doc = "@retval #BT_VALUE_COPY_STATUS_MEMORY_ERROR"]
    #[doc = "Out of memory."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{value}"]
    #[doc = "@bt_pre_not_null{copy_value}"]
    pub fn bt_value_copy(
        value: *const bt_value,
        copy_value: *mut *mut bt_value,
    ) -> bt_value_copy_status::Type;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns whether or not the value \\bt_p{a_value} is equal,"]
    #[doc = "recursively, to \\bt_p{b_value}."]
    #[doc = ""]
    #[doc = "@note"]
    #[doc = "If you want to know whether or not a value is a null value, you can"]
    #[doc = "also directly compare its pointer to the #bt_value_null variable."]
    #[doc = ""]
    #[doc = "@param[in] a_value"]
    #[doc = "Value A."]
    #[doc = "@param[in] b_value"]
    #[doc = "Value B."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "#BT_TRUE if \\bt_p{a_value} is equal, recursively, to \\bt_p{b_value}."]
    #[doc = ""]
    #[doc = "@bt_pre_not_null{a_value}"]
    #[doc = "@bt_pre_not_null{b_value}"]
    pub fn bt_value_is_equal(a_value: *const bt_value, b_value: *const bt_value) -> bt_bool;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Increments the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "@parblock"]
    #[doc = "Value of which to increment the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_value_put_ref() &mdash;"]
    #[doc = "Decrements the reference count of a value."]
    pub fn bt_value_get_ref(value: *const bt_value);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Decrements the \\ref api-fund-shared-object \"reference count\" of"]
    #[doc = "the value \\bt_p{value}."]
    #[doc = ""]
    #[doc = "@param[in] value"]
    #[doc = "@parblock"]
    #[doc = "Value of which to decrement the reference count."]
    #[doc = ""]
    #[doc = "Can be \\c NULL."]
    #[doc = "@endparblock"]
    #[doc = ""]
    #[doc = "@sa bt_value_get_ref() &mdash;"]
    #[doc = "Increments the reference count of a value."]
    pub fn bt_value_put_ref(value: *const bt_value);
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the major version of libbabeltrace2."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Major version of the library."]
    pub fn bt_version_get_major() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the minor version of libbabeltrace2."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Minor version of the library."]
    pub fn bt_version_get_minor() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the patch version of libbabeltrace2."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Patch version of the library."]
    pub fn bt_version_get_patch() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the development stage of libbabeltrace2's version."]
    #[doc = ""]
    #[doc = "The development stage \\em can contain a version suffix such as"]
    #[doc = "<code>-pre5</code> or <code>-rc1</code>."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Development stage of the library's version, or \\c NULL if none."]
    pub fn bt_version_get_development_stage() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the version control system (VCS) revision's description of"]
    #[doc = "libbabeltrace2's version."]
    #[doc = ""]
    #[doc = "The VCS revision description is only available for a non-release build"]
    #[doc = "of the library."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Version control system revision's description of the library's"]
    #[doc = "version, or \\c NULL if none."]
    pub fn bt_version_get_vcs_revision_description() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns libbabeltrace2's release name."]
    #[doc = ""]
    #[doc = "If the release name is not available, which can be the case for a"]
    #[doc = "development build, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Library's release name, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "@sa bt_version_get_name_description() &mdash;"]
    #[doc = "Returns the description of libbabeltrace2's release name."]
    pub fn bt_version_get_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns libbabeltrace2's release name's description."]
    #[doc = ""]
    #[doc = "If the release name's description is not available, which can be the"]
    #[doc = "case for a development build, this function returns \\c NULL."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Library's release name's description, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "@sa bt_version_get_name() &mdash;"]
    #[doc = "Returns libbabeltrace2's release name."]
    pub fn bt_version_get_name_description() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the extra name of libbabeltrace2's version."]
    #[doc = ""]
    #[doc = "The extra name of the library's version can be set at build time for a"]
    #[doc = "custom build."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "Library's version extra name, or \\c NULL if not available."]
    pub fn bt_version_get_extra_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the extra description of libbabeltrace2's version."]
    #[doc = ""]
    #[doc = "The extra description of the library's version can be set at build time"]
    #[doc = "for a custom build."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Library's version extra description, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "Can contain newlines."]
    #[doc = "@endparblock"]
    pub fn bt_version_get_extra_description() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief"]
    #[doc = "Returns the extra patch names of libbabeltrace2's version."]
    #[doc = ""]
    #[doc = "The extra patch names of the library's version can be set at build time"]
    #[doc = "for a custom build."]
    #[doc = ""]
    #[doc = "@returns"]
    #[doc = "@parblock"]
    #[doc = "Library's version extra patch names, or \\c NULL if not available."]
    #[doc = ""]
    #[doc = "Each line of the returned string contains the name of a patch"]
    #[doc = "applied to Babeltrace's source tree for a custom build."]
    #[doc = "@endparblock"]
    pub fn bt_version_get_extra_patch_names() -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
